<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Elasticsearch查询流程</title>
    <link href="/2025/05/25/es%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B_%E5%89%AF%E6%9C%AC/"/>
    <url>/2025/05/25/es%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B_%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>Elasticsearch 的查询过程涉及多个关键数据结构，其中 <strong>Term Index</strong> 和 <strong>Posting List</strong> 是倒排索引（Inverted Index）的核心组成部分。以下是详细流程及这些组件的具体作用：</p><hr><h5 id="1-数据写入与索引构建"><a href="#1-数据写入与索引构建" class="headerlink" title="1. 数据写入与索引构建"></a><strong>1. 数据写入与索引构建</strong></h5><p>在查询之前，数据会通过以下步骤建立倒排索引：</p><ol><li><strong>文本分词</strong>：将文档内容按分词器（如 <code>standard</code>、<code>ik</code>）拆分为词项（Term）。</li><li><strong>生成倒排索引</strong>：<ul><li><strong>Term Dictionary</strong>：存储所有唯一词项（如 “apple”、”banana”），按字典序排列。</li><li><strong>Term Index</strong>：基于 FST（Finite State Transducer）的词项索引，用于快速定位 Term 在 Term Dictionary 中的位置。</li><li><strong>Posting List</strong>：记录每个 Term 对应的文档列表（DocID）、词频（TF）、位置（Position）等元数据。</li></ul></li></ol><hr><h5 id="2-查询过程详解"><a href="#2-查询过程详解" class="headerlink" title="2. 查询过程详解"></a><strong>2. 查询过程详解</strong></h5><p>以 <strong>Term Query</strong>（精确匹配词项）为例，查询流程如下：</p><h5 id="1-解析查询请求"><a href="#1-解析查询请求" class="headerlink" title="(1) 解析查询请求"></a><strong>(1) 解析查询请求</strong></h5><p>用户发起查询 <code>GET /index/_search &#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;text&quot;: &quot;apple&quot; &#125; &#125; &#125;</code>，Elasticsearch 解析请求，确定目标字段（<code>text</code>）和查询词项（<code>apple</code>）。</p><h5 id="2-定位-Term"><a href="#2-定位-Term" class="headerlink" title="(2) 定位 Term"></a><strong>(2) 定位 Term</strong></h5><ul><li><strong>Term Index（FST）</strong>：<ul><li>在内存中快速匹配词项前缀，缩小查找范围。</li><li>例如：查找 “apple” 时，FST 跳过不相关前缀（如 “appl” 之前的项），定位到 “apple” 在 Term Dictionary 中的大致位置。</li></ul></li><li><strong>Term Dictionary</strong>：<ul><li>基于 FST 的定位结果，从磁盘或内存中检索完整词项 “apple”。</li></ul></li></ul><h5 id="3-获取-Posting-List"><a href="#3-获取-Posting-List" class="headerlink" title="(3) 获取 Posting List"></a><strong>(3) 获取 Posting List</strong></h5><ul><li><strong>Posting List 结构</strong>：<ul><li><strong>DocIDs</strong>：包含 “apple” 的文档 ID 列表（如 <code>[1, 3, 5]</code>）。</li><li><strong>词频（TF）</strong>：每个文档中 “apple” 出现的次数。</li><li><strong>位置（Position）</strong>：词项在文档中的具体位置（用于短语查询）。</li></ul></li><li><strong>存储优化</strong>：<ul><li><strong>压缩算法</strong>：如 Frame Of Reference（FOR）或 Roaring Bitmaps，减少存储空间。</li><li><strong>分块存储</strong>：Posting List 按块划分，支持快速跳跃遍历。</li></ul></li></ul><h5 id="4-合并-Posting-List（复杂查询）"><a href="#4-合并-Posting-List（复杂查询）" class="headerlink" title="(4) 合并 Posting List（复杂查询）"></a><strong>(4) 合并 Posting List（复杂查询）</strong></h5><p>对于组合查询（如 <code>&quot;apple AND banana&quot;</code>）：</p><ol><li><p>分别获取 “apple” 和 “banana” 的 Posting List。</p></li><li><p><strong>合并操作</strong>：</p><ul><li><strong>交集（AND）</strong>：使用跳表（Skip List）或位图（Bitmap）快速找到共同 DocID。</li><li><strong>并集（OR）</strong>：合并去重 DocID。</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">// 伪代码示例：跳表交集合并</span><br>   <span class="hljs-keyword">while</span> <span class="hljs-comment">(cursor1 &lt; list1.size()</span> &amp;&amp; cursor<span class="hljs-number">2</span> &lt; list<span class="hljs-number">2.</span>size<span class="hljs-comment">()</span>) &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-comment">(list1[cursor1] == list2[cursor2])</span> &#123;<br>           result.add<span class="hljs-comment">(list1[cursor1])</span>;<br>           cursor<span class="hljs-number">1</span>++; cursor<span class="hljs-number">2</span>++;<br>       &#125; else <span class="hljs-keyword">if</span> <span class="hljs-comment">(list1[cursor1] &lt; list2[cursor2])</span> &#123;<br>           cursor<span class="hljs-number">1</span> = skipTo<span class="hljs-comment">(cursor1, list2[cursor2])</span>;<br>       &#125; else &#123;<br>           cursor<span class="hljs-number">2</span> = skipTo<span class="hljs-comment">(cursor2, list1[cursor1])</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="5-相关性评分与排序"><a href="#5-相关性评分与排序" class="headerlink" title="(5) 相关性评分与排序"></a><strong>(5) 相关性评分与排序</strong></h5><ul><li><p><strong>评分模型</strong>：使用 BM25 或 TF-IDF 计算文档相关性得分。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># BM25 公式简化版</span><br><span class="hljs-attribute">score</span> = IDF * (TF * (k1 + <span class="hljs-number">1</span>)) / (TF + k1 * (<span class="hljs-number">1</span> - b + b * (doc_length / avg_doc_length)))<br></code></pre></td></tr></table></figure></li><li><p><strong>排序</strong>：按得分降序排列 DocID，筛选 Top N 结果。</p></li></ul><h5 id="6-获取文档内容"><a href="#6-获取文档内容" class="headerlink" title="(6) 获取文档内容"></a><strong>(6) 获取文档内容</strong></h5><p>根据排序后的 DocID，从正排索引（行式存储的 <code>_source</code>）中提取完整文档内容并返回。</p><hr><h5 id="3-关键优化技术"><a href="#3-关键优化技术" class="headerlink" title="3. 关键优化技术"></a><strong>3. 关键优化技术</strong></h5><table><thead><tr><th align="left"><strong>组件</strong></th><th align="left"><strong>优化手段</strong></th><th align="left"><strong>目的</strong></th></tr></thead><tbody><tr><td align="left"><strong>Term Index</strong></td><td align="left">FST 压缩算法</td><td align="left">减少内存占用，加快前缀匹配速度</td></tr><tr><td align="left"><strong>Posting List</strong></td><td align="left">Roaring Bitmaps + 分块压缩</td><td align="left">高效存储和合并大规模 DocID 集合</td></tr><tr><td align="left"><strong>查询合并</strong></td><td align="left">跳表（Skip List）位图运算</td><td align="left">加速 AND&#x2F;OR 逻辑操作</td></tr><tr><td align="left"><strong>评分缓存</strong></td><td align="left">缓存频繁查询的评分结果</td><td align="left">减少重复计算，提升响应速度</td></tr></tbody></table><hr><h5 id="4-示例：短语查询（Phrase-Query）"><a href="#4-示例：短语查询（Phrase-Query）" class="headerlink" title="4. 示例：短语查询（Phrase Query）"></a><strong>4. 示例：短语查询（Phrase Query）</strong></h5><p>查询 <code>&quot;quick brown fox&quot;</code> 时：</p><ol><li>分别获取 “quick”、”brown”、”fox” 的 Posting List。</li><li>检查它们在文档中的位置是否连续（如 <code>quick@pos=1, brown@pos=2, fox@pos=3</code>）。</li><li>合并满足连续位置的 DocID，生成最终结果。</li></ol><hr><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><ul><li><strong>Term Index</strong>：内存中的前缀索引，用于快速定位词项，减少磁盘访问。</li><li><strong>Posting List</strong>：存储词项的文档分布信息，支持高效合并和评分。</li><li><strong>性能核心</strong>：通过 FST、压缩算法和合并优化，Elasticsearch 能在毫秒级处理海量数据查询。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何通过influxDB做趋势分析</title>
    <link href="/2025/05/24/%E4%BD%BF%E7%94%A8influxDB%E5%81%9A%E8%B6%8B%E5%8A%BF%E5%88%86%E6%9E%90/"/>
    <url>/2025/05/24/%E4%BD%BF%E7%94%A8influxDB%E5%81%9A%E8%B6%8B%E5%8A%BF%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>在InfluxDB中进行趋势分析，可以通过内置函数、聚合操作和可视化工具来识别数据随时间的变化模式。以下是分步骤的实现方案：</p><hr><h5 id="一、数据准备与基础查询"><a href="#一、数据准备与基础查询" class="headerlink" title="一、数据准备与基础查询"></a><strong>一、数据准备与基础查询</strong></h5><h5 id="1-示例数据结构"><a href="#1-示例数据结构" class="headerlink" title="1. 示例数据结构"></a><strong>1. 示例数据结构</strong></h5><p>假设存储充电桩功率数据的Measurement为 <code>power_metrics</code>，包含以下字段：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">measurement: power_metrics<br><span class="hljs-keyword">tags:</span> device_id (充电桩ID), region (区域)<br>fields: power (功率，单位kW)<br><span class="hljs-keyword">time:</span> 数据时间戳<br></code></pre></td></tr></table></figure><h5 id="2-基础趋势查询"><a href="#2-基础趋势查询" class="headerlink" title="2. 基础趋势查询"></a><strong>2. 基础趋势查询</strong></h5><p>使用 <code>MEAN()</code> 计算每小时平均功率：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> MEAN(&quot;power&quot;) <span class="hljs-keyword">AS</span> avg_power <br><span class="hljs-keyword">FROM</span> &quot;power_metrics&quot; <br><span class="hljs-keyword">WHERE</span> <span class="hljs-type">time</span> &gt; now() - <span class="hljs-number">7</span>d <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">time</span>(<span class="hljs-number">1</span>h), &quot;device_id&quot;<br></code></pre></td></tr></table></figure><hr><h5 id="二、核心趋势分析方法"><a href="#二、核心趋势分析方法" class="headerlink" title="二、核心趋势分析方法"></a><strong>二、核心趋势分析方法</strong></h5><h5 id="1-移动平均（平滑趋势）"><a href="#1-移动平均（平滑趋势）" class="headerlink" title="1. 移动平均（平滑趋势）"></a><strong>1. 移动平均（平滑趋势）</strong></h5><p>使用 <code>MOVING_AVERAGE()</code> 消除短期波动，观察长期趋势：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">SELECT</span> MOVING_AVERAGE(<span class="hljs-meta">MEAN</span>(<span class="hljs-string">&quot;power&quot;</span>), 24) <span class="hljs-keyword">AS</span> daily_smooth <br><span class="hljs-keyword">FROM</span> <span class="hljs-string">&quot;power_metrics&quot;</span> <br><span class="hljs-keyword">WHERE</span> device_id = <span class="hljs-string">&#x27;CZ-1001&#x27;</span> <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-meta">time</span>(1h)<br></code></pre></td></tr></table></figure><ul><li><strong>说明</strong>：计算过去24小时窗口的移动平均，适合识别日级趋势。</li></ul><h5 id="2-同比-环比分析"><a href="#2-同比-环比分析" class="headerlink" title="2. 同比&#x2F;环比分析"></a><strong>2. 同比&#x2F;环比分析</strong></h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> MEAN(&quot;power&quot;) <br><span class="hljs-keyword">FROM</span> &quot;power_metrics&quot; <br><span class="hljs-keyword">WHERE</span> device_id = <span class="hljs-string">&#x27;CZ-1001&#x27;</span> <br>  <span class="hljs-keyword">AND</span> <span class="hljs-type">time</span> &gt;= <span class="hljs-string">&#x27;2023-10-01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">time</span> &lt;= <span class="hljs-string">&#x27;2023-10-08&#x27;</span> <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">time</span>(<span class="hljs-number">1</span>d)<br></code></pre></td></tr></table></figure><p><strong>同比（周同比）</strong>：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> MEAN(&quot;power&quot;) <br><span class="hljs-keyword">FROM</span> &quot;power_metrics&quot; <br><span class="hljs-keyword">WHERE</span> device_id = <span class="hljs-string">&#x27;CZ-1001&#x27;</span> <br>  <span class="hljs-keyword">AND</span> (<span class="hljs-type">time</span> &gt;= <span class="hljs-string">&#x27;2023-10-01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">time</span> &lt;= <span class="hljs-string">&#x27;2023-10-08&#x27;</span>) <br>    <span class="hljs-keyword">OR</span> (<span class="hljs-type">time</span> &gt;= <span class="hljs-string">&#x27;2022-10-01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">time</span> &lt;= <span class="hljs-string">&#x27;2022-10-08&#x27;</span>) <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">time</span>(<span class="hljs-number">1</span>d)<br></code></pre></td></tr></table></figure><h5 id="3-趋势预测（线性回归）"><a href="#3-趋势预测（线性回归）" class="headerlink" title="3. 趋势预测（线性回归）"></a><strong>3. 趋势预测（线性回归）</strong></h5><p>使用Flux语言的 <code>linearRegression()</code> 预测未来趋势：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">from</span>(<span class="hljs-attribute">bucket</span>: <span class="hljs-string">&quot;energy&quot;</span>)<br>  |&gt; <span class="hljs-selector-tag">range</span>(<span class="hljs-attribute">start</span>: -<span class="hljs-number">7</span>d)<br>  |&gt; <span class="hljs-selector-tag">filter</span>(<span class="hljs-attribute">fn</span>: (r) =&gt; r._measurement == <span class="hljs-string">&quot;power_metrics&quot;</span> <span class="hljs-keyword">and</span> r.device_id == <span class="hljs-string">&quot;CZ-1001&quot;</span>)<br>  |&gt; <span class="hljs-selector-tag">aggregateWindow</span>(<span class="hljs-attribute">every</span>: <span class="hljs-number">1</span>h, <span class="hljs-attribute">fn</span>: mean)<br>  |&gt; <span class="hljs-selector-tag">linearRegression</span>(<br>    <span class="hljs-attribute">x</span>: <span class="hljs-string">&quot;_time&quot;</span>, <br>    <span class="hljs-attribute">y</span>: <span class="hljs-string">&quot;_value&quot;</span>, <br>    <span class="hljs-attribute">predict</span>: <span class="hljs-number">24</span>h  <span class="hljs-comment">// 预测未来24小时</span><br>  )<br></code></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="三、-Grafana趋势看板"><a href="#三、-Grafana趋势看板" class="headerlink" title="三、 Grafana趋势看板"></a><strong>三、 Grafana趋势看板</strong></h5><ul><li><p><strong>查询模板</strong>：</p><p>sql</p><p>复制</p><p>下载</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">SELECT</span> MOVING_AVERAGE(<span class="hljs-meta">MEAN</span>(<span class="hljs-string">&quot;power&quot;</span>), 24) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&quot;power_metrics&quot;</span> <span class="hljs-keyword">WHERE</span> $timeFilter <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-meta">time</span>($__interval)<br></code></pre></td></tr></table></figure></li><li><p><strong>图表类型</strong>：</p><ul><li><strong>折线图</strong>：展示原始数据与移动平均。</li><li><strong>热力图</strong>：按时间-设备分布显示功率趋势。</li><li><strong>预测面板</strong>：叠加线性回归预测结果。</li></ul></li></ul><h5 id="2-告警规则"><a href="#2-告警规则" class="headerlink" title="2. 告警规则"></a><strong>2. 告警规则</strong></h5><p>在Grafana中配置趋势相关告警：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># Alert Rule示例：连续<span class="hljs-number">3</span>小时功率下降超过<span class="hljs-number">20</span>%<br>- alert: PowerDropTrend<br><span class="hljs-symbol">  expr:</span> <br>    (avg_over_time(power_metrics&#123;device_id=<span class="hljs-string">&quot;CZ-1001&quot;</span>&#125;[<span class="hljs-number">1h</span>]) <br>    - avg_over_time(power_metrics&#123;device_id=<span class="hljs-string">&quot;CZ-1001&quot;</span>&#125;[<span class="hljs-number">1h</span>] offset <span class="hljs-number">3h</span>)) <br>    / avg_over_time(power_metrics&#123;device_id=<span class="hljs-string">&quot;CZ-1001&quot;</span>&#125;[<span class="hljs-number">1h</span>] offset <span class="hljs-number">3h</span>) <br>    &lt; -<span class="hljs-number">0.2</span><br><span class="hljs-symbol">  for:</span> <span class="hljs-number">3h</span><br></code></pre></td></tr></table></figure><hr><h5 id="四、性能优化"><a href="#四、性能优化" class="headerlink" title="四、性能优化"></a><strong>四、性能优化</strong></h5><h5 id="1-预聚合策略"><a href="#1-预聚合策略" class="headerlink" title="1. 预聚合策略"></a><strong>1. 预聚合策略</strong></h5><p>创建连续查询（CQ）预先计算趋势数据：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> CONTINUOUS QUERY &quot;cq_1h_power&quot; <br><span class="hljs-keyword">ON</span> &quot;energy&quot; <br><span class="hljs-keyword">BEGIN</span> <br>  <span class="hljs-keyword">SELECT</span> MEAN(&quot;power&quot;) <span class="hljs-keyword">AS</span> avg_power <br>  <span class="hljs-keyword">INTO</span> &quot;power_1h&quot; <br>  <span class="hljs-keyword">FROM</span> &quot;power_metrics&quot; <br>  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">time</span>(<span class="hljs-number">1</span>h), device_id <br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><h5 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2. 索引优化"></a><strong>2. 索引优化</strong></h5><ul><li><strong>Tag索引</strong>：对高频查询的Tag（如<code>device_id</code>）创建索引。</li><li><strong>时间分区</strong>：按时间范围分片（如按天分片），加速范围查询。</li></ul><hr><h5 id="五、常见问题与解决"><a href="#五、常见问题与解决" class="headerlink" title="五、常见问题与解决"></a><strong>五、常见问题与解决</strong></h5><h5 id="1-数据缺失导致趋势断裂"><a href="#1-数据缺失导致趋势断裂" class="headerlink" title="1. 数据缺失导致趋势断裂"></a><strong>1. 数据缺失导致趋势断裂</strong></h5><ul><li><p><strong>填充策略</strong>：使用 <code>fill()</code> 补零或插值。 </p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">SELECT</span> <span class="hljs-meta">MEAN</span>(<span class="hljs-string">&quot;power&quot;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&quot;power_metrics&quot;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-meta">time</span>(1h) fill(linear)<br></code></pre></td></tr></table></figure></li></ul><h5 id="2-时区不一致"><a href="#2-时区不一致" class="headerlink" title="2. 时区不一致"></a><strong>2. 时区不一致</strong></h5><ul><li><p><strong>指定时区</strong>： </p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">SELECT</span> <span class="hljs-meta">MEAN</span>(<span class="hljs-string">&quot;power&quot;</span>) <br><span class="hljs-keyword">FROM</span> <span class="hljs-string">&quot;power_metrics&quot;</span> <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-meta">time</span>(1d, <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>通过 <strong>移动平均、聚合窗口、线性回归</strong> 等内置函数，结合 <strong>Grafana可视化</strong> 和 <strong>外部分析工具</strong>，InfluxDB可高效实现时间序列趋势分析。关键优化点包括预聚合、索引管理和查询模板化。对于复杂场景（如季节性分解），建议结合Flux和外部数据处理工具（Python&#x2F;Pandas）扩展分析能力。</p>]]></content>
    
    
    
    <tags>
      
      <tag>influxDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis高性能（2）I/O多路复用</title>
    <link href="/2024/05/26/redis%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%882%EF%BC%89I:O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/2024/05/26/redis%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%882%EF%BC%89I:O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>以Get请求为例，处理一个Get请求，需要监听客户端请求（bind&#x2F;listen），和客户端建立连接（accept），从socket中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向socket中写回数据（send）。</p><p>下图显示了这一过程，其中，bind&#x2F;listen、accept、recv、parse和send属于网络IO处理，而get属于键值数据操作。既然Redis是单线程，那么，最基本的一种实现是在一个线程中依次执行上面说的这些操作。</p><p><img src="https://static001.geekbang.org/resource/image/e1/c9/e18499ab244e4428a0e60b4da6575bc9.jpg" alt="img"></p><p>但是，在这里的网络IO操作中，有潜在的阻塞点，分别是accept()和recv()。当Redis监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在accept()函数这里，导致其他客户端无法和Redis建立连接。类似的，当Redis通过recv()从一个客户端读取数据时，如果数据一直没有到达，Redis也会一直阻塞在recv()。</p><p>这就导致Redis整个线程阻塞，无法处理其他客户端请求，效率很低。不过，幸运的是，socket网络模型本身支持非阻塞模式。</p><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>Socket网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上，如果想要使用socket非阻塞模式，就必须要了解这三个函数的调用返回类型和设置模式。接下来，我们就重点学习下它们。</p><p>在socket模型中，不同操作调用后会返回不同的套接字类型。socket()方法会返回主动套接字，然后调用listen()方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用accept()方法接收到达的客户端连接，并返回已连接套接字。</p><p><img src="https://static001.geekbang.org/resource/image/1c/4a/1ccc62ab3eb2a63c4965027b4248f34a.jpg" alt="img"></p><p>针对监听套接字，我们可以设置非阻塞模式：当Redis调用accept()但一直未有连接请求到达时，Redis线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用accept()时，已经存在监听套接字了。</p><p>虽然Redis线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知Redis。</p><p>类似的，我们也可以针对已连接套接字设置非阻塞模式：Redis调用recv()后，如果已连接套接字上一直没有数据到达，Redis线程同样可以返回处理其他操作。我们也需要有机制继续监听该已连接套接字，并在有数据达到时通知Redis。</p><p>这样才能保证Redis线程，既不会像基本IO模型中一直在阻塞点等待，也不会导致Redis无法处理实际到达的连接请求或数据。</p><p>到此，Linux中的IO多路复用机制就要登场了。</p><h3 id="IO多路复用机制"><a href="#IO多路复用机制" class="headerlink" title="IO多路复用机制"></a>IO多路复用机制</h3><p>Linux中的IO多路复用机制是指一个线程处理多个IO流，就是我们经常听到的select&#x2F;epoll机制。简单来说，在Redis只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给Redis线程处理，这就实现了一个Redis线程处理多个IO流的效果。</p><p>下图就是基于多路复用的Redis IO模型。图中的多个FD就是刚才所说的多个套接字。Redis网络框架调用epoll机制，让内核监听这些套接字。此时，Redis线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis可以同时和多个客户端连接并处理请求，从而提升并发性。</p><p><img src="https://static001.geekbang.org/resource/image/00/ea/00ff790d4f6225aaeeebba34a71d8bea.jpg" alt="img"></p><p>为了在请求到达时能通知到Redis线程，select&#x2F;epoll提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。</p><p>那么，回调机制是怎么工作的呢？其实，select&#x2F;epoll一旦监测到FD上有请求到达时，就会触发相应的事件。</p><p>这些事件会被放进一个事件队列，Redis单线程对该事件队列不断进行处理。这样一来，Redis无需一直轮询是否有请求实际发生，这就可以避免造成CPU资源浪费。同时，Redis在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为Redis一直在对事件队列进行处理，所以能及时响应客户端请求，提升Redis的响应性能。</p><p>为了方便你理解，我再以连接请求和读数据请求为例，具体解释一下。</p><p>这两个请求分别对应Accept事件和Read事件，Redis分别对这两个事件注册accept和get回调函数。当Linux内核监听到有连接请求或读数据请求时，就会触发Accept事件和Read事件，此时，内核就会回调Redis相应的accept和get函数进行处理。</p><p>这就像病人去医院瞧病。在医生实际诊断前，每个病人（等同于请求）都需要先分诊、测体温、登记等。如果这些工作都由医生来完成，医生的工作效率就会很低。所以，医院都设置了分诊台，分诊台会一直处理这些诊断前的工作（类似于Linux内核监听请求），然后再转交给医生做实际诊断。这样即使一个医生（相当于Redis单线程），效率也能提升。</p><p>不过，需要注意的是，即使你的应用场景中部署了不同的操作系统，多路复用机制也是适用的。因为这个机制的实现有很多种，既有基于Linux系统下的select和epoll实现，也有基于FreeBSD的kqueue实现，以及基于Solaris的evport实现，这样，你可以根据Redis实际运行的操作系统，选择相应的多路复用实现。</p><p>Redis单线程是指它对网络IO和数据读写的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题。单线程的Redis也能获得高性能，跟多路复用的IO模型密切相关，因为这避免了accept()和send()&#x2F;recv()潜在的网络IO操作阻塞点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis高性能（1）数据结构</title>
    <link href="/2024/05/26/redis%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/05/26/redis%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>redis高性能的原因是什么，好记性不如烂笔头，写个系列把以往笔记写下来，这是开篇。讲之前先把redis为什么是单线程解释一下</p><h3 id="redis是单线程吗"><a href="#redis是单线程吗" class="headerlink" title="redis是单线程吗"></a>redis是单线程吗</h3><p>我们经常能听到别人说：redis是单线程，其实这里主要是指Redis的网络IO（redis 6.0版本支持多线程处理网络I O）和键值对读写（也就是执行命令）是由一个线程来完成的，这也是redis对外提供键值存储服务的主要流程。但redis的其他功能，比如<strong>持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</strong></p><p>所以，严格来说，redis并不是单线程。</p><h3 id="为什么执行命令使用单线程"><a href="#为什么执行命令使用单线程" class="headerlink" title="为什么执行命令使用单线程"></a>为什么执行命令使用单线程</h3><p>使用多线程，可以增加系统吞吐率，或是可以增加系统扩展性。那为什么redis在执行命令时要采用单线程的方式呢？一个关键的瓶颈在于，系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销。</p><p>拿redis举例。redis有List的数据类型，并提供出队（LPOP）和入队（LPUSH）操作。假设Redis采用多线程设计，线程A对一个List做LPUSH操作，并对队列长度加1。同时，线程B对该List执行LPOP操作，并对队列长度减1。为了保证队列长度的正确性，Redis需要让线程A和B的LPUSH和LPOP串行执行，这样一来，Redis可以无误地记录它们对List长度的修改。否则，可能会得到错误的长度结果。这就是多线程编程模式面临的共享资源的并发访问控制问题。并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。</p><p>而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis直接采用了单线程模式。</p><h3 id="为什么单线程redis可以那么快"><a href="#为什么单线程redis可以那么快" class="headerlink" title="为什么单线程redis可以那么快"></a>为什么单线程redis可以那么快</h3><p>那么回到主题，redis能使用单线程模型达到每秒数十万级别的处理能力，为什么？</p><p>一方面，Redis的大部分操作在<strong>内存</strong>上完成，再加上它采用了<strong>高效的数据结构</strong>，例如哈希表和跳表，这是它实现高性能的一个重要原因。另一方面，就是redis采用了<strong>I&#x2F;O多路复用机制</strong>，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。</p><p>1.大部分操作在内存</p><p>2.高效的数据结构</p><p>3.I&#x2F;O多路复用</p><p>我们先来看第二点，高效的数据结构</p><h3 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h3><p>redis有String，Set，Sorted Set，Hash，List 5种<strong>数据类型</strong></p><p>有简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组6种<strong>数据结构</strong></p><p>对应关系如下图：</p><p><img src="https://static001.geekbang.org/resource/image/f2/2d/f204bdcf37f31c7abcee065daed8dd2d.jpg" alt="img"></p><p><img src="https://static001.geekbang.org/resource/image/82/50/828caba0dc490f541b0c2ae9f0ef3350.jpg" alt="img"></p><p>String类型的底层实现只有一种数据结构，也就是简单动态字符串。而List、Hash、Set和Sorted Set这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p><p>想一下这几个问题</p><ul><li>这些数据结构中键和值本身之间用什么结构组织？</li><li>为什么集合类型有那么多的底层结构，它们都是怎么组织数据的，都很快吗？</li><li>什么是简单动态字符串，和常用的字符串是一回事吗？</li></ul><h5 id="键和值用什么结构组织？"><a href="#键和值用什么结构组织？" class="headerlink" title="键和值用什么结构组织？"></a>键和值用什么结构组织？</h5><p>为了实现从键到值的快速访问，Redis<strong>使用了一个哈希表来保存所有键值对</strong>。</p><p>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</p><p>看到这里，你可能会问了：“如果值是集合类型的话，作为数组元素的哈希桶怎么来保存呢？”其实，哈希桶中的元素保存的并不是值本身，而是<strong>指向具体值的指针</strong>。这也就是说，不管值是String，还是集合类型，哈希桶中的元素都是指向它们的指针。</p><p>在下图中，可以看到，哈希桶中的entry元素中保存了<code>*key</code>和<code>*value</code>指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过<code>*value</code>指针被查找到。</p><p><img src="https://static001.geekbang.org/resource/image/8d/54/8dfc3abd55a2262049b9b77394186554.jpg" alt="img"></p><p>因为这个哈希表保存了所有的键值对，所以，把它称为<strong>全局哈希表</strong>。哈希表的最大好处很明显，就是让我们可以用O(1)的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的entry元素。</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/assets/b6cbc5161388fdf4c9b49f3802ef53e7-20221015223128-adrxmxz.jpg" alt="img"></p><p>每次创建一个 <code>key-value</code> 键值对，<code>Redis</code> 都会创建两个对象，一个是键对象，一个是值对象。而且需要注意的是<strong>在 <code>Redis</code> 中，值对象并不是直接存储，而是被包装成 <code>redisObject</code> 对象</strong>，并同时将键对象和值对象通过 <code>dictEntry</code> 对象进行封装，如下就是一个 <code>dictEntry</code> 对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-type">void</span> *key;<span class="hljs-comment">//指向key，即sds</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;<span class="hljs-comment">//指向value</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个key-value键值对(哈希值相同的键值对会形成一个链表，从而解决哈希冲突问题)</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p><code>redisObject</code> 对象的定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<span class="hljs-comment">//对象类型（4位=0.5字节）</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<span class="hljs-comment">//编码（4位=0.5字节）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;<span class="hljs-comment">//记录对象最后一次被应用程序访问的时间（24位=3字节）</span><br>    <span class="hljs-type">int</span> refcount;<span class="hljs-comment">//引用计数。等于0时表示可以被垃圾回收（32位=4字节）</span><br>    <span class="hljs-type">void</span> *ptr;<span class="hljs-comment">//指向底层实际的数据存储结构，如：sds等(8字节)</span><br>&#125; robj;<br></code></pre></td></tr></table></figure><p>当我们在 <code>Redis</code> 客户端中执行命令 <code>set name lonely_wolf</code> ，就会得到下图所示的一个结构（省略了部分属性）：</p><p><img src="https://img2020.cnblogs.com/blog/2232223/202101/2232223-20210111115915584-1768318059.png" alt="img"></p><p>查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说，<strong>不管哈希表里有10万个键还是100万个键，我们只需要一次计算就能找到相应的键</strong>。</p><p>但是，如果你只是了解了哈希表的O(1)复杂度和快速查找特性，那么，当你往Redis中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是<strong>哈希表的冲突问题和rehash可能带来的操作阻塞。</strong></p><h3 id="数据结构优化实践"><a href="#数据结构优化实践" class="headerlink" title="数据结构优化实践"></a>数据结构优化实践</h3><p>举个例子。之前我做的一个业务场景是这样子的：将跑步路线ID和路线详情ID做一一对应的关联。当时我第一想法就是用redis String，因为都是单对单。但后面评审的时候，组内有同事指出：假设有一亿个跑步路线，就需要用到6GB的内存，大内存的redis实例在生成RDB时响应会变慢，可想而知这不是一个好的设计方案。先来说下为什么String类型内存开销大。</p><p> redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以，redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。</p><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在，例如指向 String 类型的 SDS 结构所在的内存地址，可以看一下下面的示意图。</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/assets/3409948e9d3e8aa5cd7cafb9b66c2857-20221015223128-9rrrq48.jpg" alt="img"></p><p>我们前面说过，redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对。也就是说，每一个key，都会有一个dictEntry的内存开销。</p><p>那么用什么数据结构可以节省内存呢？Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。</p><p>在用集合类型保存键值对时，一个键对应了一个集合的数据，但是在我的这个业务场景中，一个路线 ID 只对应一个路线详情 ID，该怎么用集合类型呢？</p><p>在保存单值的键值对时，可以采用基于 Hash 类型的二级编码方法。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value，这样一来，就可以把单值数据保存到 Hash 集合中了。</p><p>以路线 ID 1101000060 和图片存储对象 ID 3302000080 为例，可以把图片 ID 的前 7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象 ID 分别作为 Hash 类型值中的 key 和 value。</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 中的内部主题（Internal Topic）__consumer_offsets。</title>
    <link href="/2023/11/01/Kafka%20%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E4%B8%BB%E9%A2%98%EF%BC%88Internal%20Topic%EF%BC%89__consumer_offsets%E3%80%82/"/>
    <url>/2023/11/01/Kafka%20%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E4%B8%BB%E9%A2%98%EF%BC%88Internal%20Topic%EF%BC%89__consumer_offsets%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>Kafka 中神秘的内部主题（Internal Topic）__consumer_offsets。</p><p>__consumer_offsets 在 Kafka 源码中有个更为正式的名字，叫<strong>位移主题</strong>，即 Offsets Topic。</p><p> 老版本 Consumer 的位移管理是依托于 Apache ZooKeeper 的，它会自动或手动地将位移数据提交到 ZooKeeper 中保存。当 Consumer 重启后，它能自动从 ZooKeeper 中读取位移数据，从而在上次消费截止的地方继续消费。这种设计使得 Kafka Broker 不需要保存位移数据，减少了 Broker 端需要持有的状态空间，因而有利于实现高伸缩性。</p><p>但是，ZooKeeper 其实并不适用于这种高频的写操作，因此，Kafka 社区自 0.8.2.x 版本开始，就在酝酿修改这种设计，并最终在新版本 Consumer 中正式推出了全新的位移管理机制，自然也包括这个新的位移主题。</p><p>新版本 Consumer 的位移管理机制其实也很简单，就是<strong>将 Consumer 的位移数据作为一条条普通的 Kafka 消息，提交到 __consumer_offsets 中。可以这么说，__consumer_offsets 的主要作用是保存 Kafka 消费者的位移信息。</strong>它要求这个提交过程不仅要实现高持久性，还要支持高频的写操作。显然，Kafka 的主题设计天然就满足这两个条件，因此，使用 Kafka 主题来保存位移这件事情，实际上就是一个水到渠成的想法了。</p><p>这里想再次强调一下，和创建的其他主题一样，位移主题就是普通的 Kafka 主题。可以手动地创建它、修改它，甚至是删除它。只不过，它同时也是一个内部主题，大部分情况下，其实并不需要“搭理”它，也不用花心思去管理它，把它丢给 Kafka 就完事了。</p><p>虽说位移主题是一个普通的 Kafka 主题，但<strong>它的消息格式却是 Kafka 自己定义的</strong>，用户不能修改，也就是说不能随意地向这个主题写消息，因为一旦写入的消息不满足 Kafka 规定的格式，那么 Kafka 内部无法成功解析，就会造成 Broker 的崩溃。事实上，Kafka Consumer 有 API 帮提交位移，也就是向位移主题写消息。千万不要自己写个 Producer 随意向该主题发送消息。</p><p>这个主题存的到底是什么格式的消息呢？所谓的消息格式，可以简单地理解为是一个 KV 对。Key 和 Value 分别表示消息的键值和消息体，在 Kafka 中它们就是字节数组而已。想象一下，如果让来设计这个主题，觉得消息格式应该长什么样子呢？先不说社区的设计方案，自己先来设计一下。</p><p>首先从 Key 说起。一个 Kafka 集群中的 Consumer 数量会有很多，既然这个主题保存的是 Consumer 的位移数据，那么消息格式中必须要有字段来标识这个位移数据是哪个 Consumer 的。这种数据放在哪个字段比较合适呢？显然放在 Key 中比较合适。</p><p>*<em>位移主题的 Key 中应该保存 3 部分内容：Group Id,topic名，分区号</em>***。</p><p>接下来，再来看看消息体的设计。也许会觉得消息体应该很简单，保存一个位移值就可以了。实际上，社区的方案要复杂得多，比如消息体还保存了位移提交的一些其他元数据，诸如时间戳和用户自定义的数据等。保存这些元数据是为了帮助 Kafka 执行各种各样后续的操作，比如删除过期位移消息等。但总体来说，还是可以简单地认为消息体就是保存了位移值。</p><p>当然了，位移主题的消息格式可不是只有这一种。事实上，它有 3 种消息格式。除了刚刚说的这种格式，还有 2 种格式：</p><ol><li>用于保存 Consumer Group 信息的消息。</li><li>用于删除 Group 过期位移甚至是删除 Group 的消息。</li></ol><p>第 1 种格式非常神秘，以至于几乎无法在搜索引擎中搜到它的身影。不过，只需要记住它是用来注册 Consumer Group 的就可以了。</p><p>第 2 种格式相对更加有名一些。它有个专属的名字：tombstone 消息，即墓碑消息，也称 delete mark。下次在 Google 或百度中见到这些词，不用感到惊讶，它们指的是一个东西。这些消息只出现在源码中而不暴露给。它的主要特点是它的消息体是 null，即空消息体。</p><p>那么，何时会写入这类消息呢？一旦某个 Consumer Group 下的所有 Consumer 实例都停止了，而且它们的位移数据都已被删除时，Kafka 会向位移主题的对应分区写入 tombstone 消息，表明要彻底删除这个 Group 的信息。</p><p>好了，消息格式就说这么多，下面来说说位移主题是怎么被创建的。通常来说，<strong>当 Kafka 集群中的第一个 Consumer 程序启动时，Kafka 会自动创建位移主题</strong>。说过，位移主题就是普通的 Kafka 主题，那么它自然也有对应的分区数。但如果是 Kafka 自动创建的，分区数是怎么设置的呢？这就要看 Broker 端参数 offsets.topic.num.partitions 的取值了。它的默认值是 50，因此 Kafka 会自动创建一个 50 分区的位移主题。如果曾经惊讶于 Kafka 日志路径下冒出很多 __consumer_offsets-xxx 这样的目录，那么现在应该明白了吧，这就是 Kafka 自动帮创建的位移主题啊。</p><p>除了分区数，副本数或备份因子是怎么控制的呢？答案也很简单，这就是 Broker 端另一个参数 offsets.topic.replication.factor 要做的事情了。它的默认值是 3。</p><p>总结一下，<strong>如果位移主题是 Kafka 自动创建的，那么该主题的分区数是 50，副本数是 3</strong>。</p><p>目前 Kafka Consumer 提交位移的方式有两种：<strong>自动提交位移和手动提交位移。</strong></p><p>Consumer 端有个参数叫 enable.auto.commit，如果值是 true，则 Consumer 在后台默默地为定期提交位移，提交间隔由一个专属的参数 auto.commit.interval.ms 来控制。自动提交位移有一个显著的优点，就是省事，不用操心位移提交的事情，就能保证消息消费不会丢失。但这一点同时也是缺点。因为它太省事了，以至于丧失了很大的灵活性和可控性，完全没法把控 Consumer 端的位移管理。</p><p>事实上，很多与 Kafka 集成的大数据框架都是禁用自动提交位移的，如 Spark、Flink 等。这就引出了另一种位移提交方式：<strong>手动提交位移</strong>，即设置 enable.auto.commit &#x3D; false。一旦设置了 false，作为 Consumer 应用开发的就要承担起位移提交的责任。Kafka Consumer API 为提供了位移提交的方法，如 consumer.commitSync 等。当调用这些方法时，Kafka 会向位移主题写入相应的消息。</p><p>如果选择的是自动提交位移，那么就可能存在一个问题：只要 Consumer 一直启动着，它就会无限期地向位移主题写入消息。</p><p>来举个极端一点的例子。假设 Consumer 当前消费到了某个主题的最新一条消息，位移是 100，之后该主题没有任何新消息产生，故 Consumer 无消息可消费了，所以位移永远保持在 100。由于是自动提交位移，位移主题中会不停地写入位移 &#x3D;100 的消息。显然 Kafka 只需要保留这类消息中的最新一条就可以了，之前的消息都是可以删除的。这就要求 Kafka 必须要有针对位移主题消息特点的消息删除策略，否则这种消息会越来越多，最终撑爆整个磁盘。</p><p>Kafka 是怎么删除位移主题中的过期消息的呢？答案就是 Compaction。国内很多文献都将其翻译成压缩，个人是有一点保留意见的。在英语中，压缩的专有术语是 Compression，它的原理和 Compaction 很不相同，更倾向于翻译成压实，或干脆采用 JVM 垃圾回收中的术语：整理。</p><p>不管怎么翻译，Kafka 使用<strong>Compact 策略</strong>来删除位移主题中的过期消息，避免该主题无限期膨胀。那么应该如何定义 Compact 策略中的过期呢？对于同一个 Key 的两条消息 M1 和 M2，如果 M1 的发送时间早于 M2，那么 M1 就是过期消息。Compact 的过程就是扫描日志的所有消息，剔除那些过期的消息，然后把剩下的消息整理在一起。在这里贴一张来自官网的图片，来说明 Compact 过程。</p><p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAACqaADAAQAAAABAAABjQAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/+IbkElDQ19QUk9GSUxFAAEBAAAbgGFwcGwCEAAAbW50clJHQiBYWVogB+MAAQAWAAoAAwABYWNzcEFQUEwAAAAAQVBQTAAAAAAAAAAAAAAAAAAAAAAAAPbWAAEAAAAA0y1hcHBsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARZGVzYwAAAVAAAABiZHNjbQAAAbQAAASEY3BydAAABjgAAAAjd3RwdAAABlwAAAAUclhZWgAABnAAAAAUZ1hZWgAABoQAAAAUYlhZWgAABpgAAAAUclRSQwAABqwAAAgMYWFyZwAADrgAAAAgdmNndAAADtgAAAYSbmRpbgAAFOwAAAY+Y2hhZAAAGywAAAAsbW1vZAAAG1gAAAAoYlRSQwAABqwAAAgMZ1RSQwAABqwAAAgMYWFiZwAADrgAAAAgYWFnZwAADrgAAAAgZGVzYwAAAAAAAAAIRGlzcGxheQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG1sdWMAAAAAAAAAJgAAAAxockhSAAAAFAAAAdhrb0tSAAAADAAAAexuYk5PAAAAEgAAAfhpZAAAAAAAEgAAAgpodUhVAAAAFAAAAhxjc0NaAAAAFgAAAjBkYURLAAAAHAAAAkZubE5MAAAAFgAAAmJmaUZJAAAAEAAAAnhpdElUAAAAFAAAAohlc0VTAAAAEgAAApxyb1JPAAAAEgAAApxmckNBAAAAFgAAAq5hcgAAAAAAFAAAAsR1a1VBAAAAHAAAAthoZUlMAAAAFgAAAvR6aFRXAAAADAAAAwp2aVZOAAAADgAAAxZza1NLAAAAFgAAAyR6aENOAAAADAAAAwpydVJVAAAAJAAAAzplbkdCAAAAFAAAA15mckZSAAAAFgAAA3JtcwAAAAAAEgAAA4hoaUlOAAAAEgAAA5p0aFRIAAAADAAAA6xjYUVTAAAAGAAAA7hlbkFVAAAAFAAAA15lc1hMAAAAEgAAApxkZURFAAAAEAAAA9BlblVTAAAAEgAAA+BwdEJSAAAAGAAAA/JwbFBMAAAAEgAABAplbEdSAAAAIgAABBxzdlNFAAAAEAAABD50clRSAAAAFAAABE5wdFBUAAAAFgAABGJqYUpQAAAADAAABHgATABDAEQAIAB1ACAAYgBvAGoAac7st+wAIABMAEMARABGAGEAcgBnAGUALQBMAEMARABMAEMARAAgAFcAYQByAG4AYQBTAHoA7QBuAGUAcwAgAEwAQwBEAEIAYQByAGUAdgBuAP0AIABMAEMARABMAEMARAAtAGYAYQByAHYAZQBzAGsA5gByAG0ASwBsAGUAdQByAGUAbgAtAEwAQwBEAFYA5AByAGkALQBMAEMARABMAEMARAAgAGMAbwBsAG8AcgBpAEwAQwBEACAAYwBvAGwAbwByAEEAQwBMACAAYwBvAHUAbABlAHUAciAPAEwAQwBEACAGRQZEBkgGRgYpBBoEPgQ7BEwEPgRABD4EMgQ4BDkAIABMAEMARCAPAEwAQwBEACAF5gXRBeIF1QXgBdlfaYJyACAATABDAEQATABDAEQAIABNAOAAdQBGAGEAcgBlAGIAbgD9ACAATABDAEQEJgQyBDUEQgQ9BD4EOQAgBBYEGgAtBDQEOARBBD8EOwQ1BDkAQwBvAGwAbwB1AHIAIABMAEMARABMAEMARAAgAGMAbwB1AGwAZQB1AHIAVwBhAHIAbgBhACAATABDAEQJMAkCCRcJQAkoACAATABDAEQATABDAEQAIA4qDjUATABDAEQAIABlAG4AIABjAG8AbABvAHIARgBhAHIAYgAtAEwAQwBEAEMAbwBsAG8AcgAgAEwAQwBEAEwAQwBEACAAQwBvAGwAbwByAGkAZABvAEsAbwBsAG8AcgAgAEwAQwBEA4gDswPHA8EDyQO8A7cAIAO/A7gDzAO9A7cAIABMAEMARABGAOQAcgBnAC0ATABDAEQAUgBlAG4AawBsAGkAIABMAEMARABMAEMARAAgAGEAIABDAG8AcgBlAHMwqzDpMPwATABDAER0ZXh0AAAAAENvcHlyaWdodCBBcHBsZSBJbmMuLCAyMDE5AABYWVogAAAAAAAA81IAAQAAAAEWz1hZWiAAAAAAAABjhQAAN/AAAAn6WFlaIAAAAAAAAG3zAACwCgAAIE1YWVogAAAAAAAAJV4AABgGAACo5mN1cnYAAAAAAAAEAAAAAAUACgAPABQAGQAeACMAKAAtADIANgA7AEAARQBKAE8AVABZAF4AYwBoAG0AcgB3AHwAgQCGAIsAkACVAJoAnwCjAKgArQCyALcAvADBAMYAywDQANUA2wDgAOUA6wDwAPYA+wEBAQcBDQETARkBHwElASsBMgE4AT4BRQFMAVIBWQFgAWcBbgF1AXwBgwGLAZIBmgGhAakBsQG5AcEByQHRAdkB4QHpAfIB+gIDAgwCFAIdAiYCLwI4AkECSwJUAl0CZwJxAnoChAKOApgCogKsArYCwQLLAtUC4ALrAvUDAAMLAxYDIQMtAzgDQwNPA1oDZgNyA34DigOWA6IDrgO6A8cD0wPgA+wD+QQGBBMEIAQtBDsESARVBGMEcQR+BIwEmgSoBLYExATTBOEE8AT+BQ0FHAUrBToFSQVYBWcFdwWGBZYFpgW1BcUF1QXlBfYGBgYWBicGNwZIBlkGagZ7BowGnQavBsAG0QbjBvUHBwcZBysHPQdPB2EHdAeGB5kHrAe/B9IH5Qf4CAsIHwgyCEYIWghuCIIIlgiqCL4I0gjnCPsJEAklCToJTwlkCXkJjwmkCboJzwnlCfsKEQonCj0KVApqCoEKmAquCsUK3ArzCwsLIgs5C1ELaQuAC5gLsAvIC+EL+QwSDCoMQwxcDHUMjgynDMAM2QzzDQ0NJg1ADVoNdA2ODakNww3eDfgOEw4uDkkOZA5/DpsOtg7SDu4PCQ8lD0EPXg96D5YPsw/PD+wQCRAmEEMQYRB+EJsQuRDXEPURExExEU8RbRGMEaoRyRHoEgcSJhJFEmQShBKjEsMS4xMDEyMTQxNjE4MTpBPFE+UUBhQnFEkUahSLFK0UzhTwFRIVNBVWFXgVmxW9FeAWAxYmFkkWbBaPFrIW1hb6Fx0XQRdlF4kXrhfSF/cYGxhAGGUYihivGNUY+hkgGUUZaxmRGbcZ3RoEGioaURp3Gp4axRrsGxQbOxtjG4obshvaHAIcKhxSHHscoxzMHPUdHh1HHXAdmR3DHeweFh5AHmoelB6+HukfEx8+H2kflB+/H+ogFSBBIGwgmCDEIPAhHCFIIXUhoSHOIfsiJyJVIoIiryLdIwojOCNmI5QjwiPwJB8kTSR8JKsk2iUJJTglaCWXJccl9yYnJlcmhya3JugnGCdJJ3onqyfcKA0oPyhxKKIo1CkGKTgpaymdKdAqAio1KmgqmyrPKwIrNitpK50r0SwFLDksbiyiLNctDC1BLXYtqy3hLhYuTC6CLrcu7i8kL1ovkS/HL/4wNTBsMKQw2zESMUoxgjG6MfIyKjJjMpsy1DMNM0YzfzO4M/E0KzRlNJ402DUTNU01hzXCNf02NzZyNq426TckN2A3nDfXOBQ4UDiMOMg5BTlCOX85vDn5OjY6dDqyOu87LTtrO6o76DwnPGU8pDzjPSI9YT2hPeA+ID5gPqA+4D8hP2E/oj/iQCNAZECmQOdBKUFqQaxB7kIwQnJCtUL3QzpDfUPARANER0SKRM5FEkVVRZpF3kYiRmdGq0bwRzVHe0fASAVIS0iRSNdJHUljSalJ8Eo3Sn1KxEsMS1NLmkviTCpMcky6TQJNSk2TTdxOJU5uTrdPAE9JT5NP3VAnUHFQu1EGUVBRm1HmUjFSfFLHUxNTX1OqU/ZUQlSPVNtVKFV1VcJWD1ZcVqlW91dEV5JX4FgvWH1Yy1kaWWlZuFoHWlZaplr1W0VblVvlXDVchlzWXSddeF3JXhpebF69Xw9fYV+zYAVgV2CqYPxhT2GiYfViSWKcYvBjQ2OXY+tkQGSUZOllPWWSZedmPWaSZuhnPWeTZ+loP2iWaOxpQ2maafFqSGqfavdrT2una/9sV2yvbQhtYG25bhJua27Ebx5veG/RcCtwhnDgcTpxlXHwcktypnMBc11zuHQUdHB0zHUodYV14XY+dpt2+HdWd7N4EXhueMx5KnmJeed6RnqlewR7Y3vCfCF8gXzhfUF9oX4BfmJ+wn8jf4R/5YBHgKiBCoFrgc2CMIKSgvSDV4O6hB2EgITjhUeFq4YOhnKG14c7h5+IBIhpiM6JM4mZif6KZIrKizCLlov8jGOMyo0xjZiN/45mjs6PNo+ekAaQbpDWkT+RqJIRknqS45NNk7aUIJSKlPSVX5XJljSWn5cKl3WX4JhMmLiZJJmQmfyaaJrVm0Kbr5wcnImc951kndKeQJ6unx2fi5/6oGmg2KFHobaiJqKWowajdqPmpFakx6U4pammGqaLpv2nbqfgqFKoxKk3qamqHKqPqwKrdavprFys0K1ErbiuLa6hrxavi7AAsHWw6rFgsdayS7LCszizrrQltJy1E7WKtgG2ebbwt2i34LhZuNG5SrnCuju6tbsuu6e8IbybvRW9j74KvoS+/796v/XAcMDswWfB48JfwtvDWMPUxFHEzsVLxcjGRsbDx0HHv8g9yLzJOsm5yjjKt8s2y7bMNcy1zTXNtc42zrbPN8+40DnQutE80b7SP9LB00TTxtRJ1MvVTtXR1lXW2Ndc1+DYZNjo2WzZ8dp22vvbgNwF3IrdEN2W3hzeot8p36/gNuC94UThzOJT4tvjY+Pr5HPk/OWE5g3mlucf56noMui86Ubp0Opb6uXrcOv77IbtEe2c7ijutO9A78zwWPDl8XLx//KM8xnzp/Q09ML1UPXe9m32+/eK+Bn4qPk4+cf6V/rn+3f8B/yY/Sn9uv5L/tz/bf//cGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAAClt2Y2d0AAAAAAAAAAAAAwEAAAIAAABWAS4B6wKEAy0DzwSGBUYGAwbLB5gIbglMCikLBwvsDNINtw6nD6YQrxG4EsITyxTQFdgW3xfoGOsZ8Rr6G/0dAh4HHwogDSESIhIjFiQYJRcmGCccKB0pICogKyIsJC0mLicvLDAwMTMyNjM6ND81RTZJN0k4RjlGOkY7QzxBPTw+Oj80QC5BJkIdQxRECkT/RfNG5kfZSMxJvEqoS5NMf01qTlhPRVA1USdSG1MQVAhVA1YBVwJYBFkJWhBbGVwkXS1eKV8kYB9hGmIVYxNkEmUTZhZnG2giaSxqN2tGbFZtaW58b5JwpHGgcphzkXSMdYl2ineOeJh5qHq+e9t9AH4sf1+AmYHbgyKEb4XBhwaII4kyikKLU4xmjXqOkY+okMCR2pL1lBGVLZZKl2aYg5memrmb0pzknfWfB6AZoSqiPKNPpGKldKaFp5aoqKm5qsqr2qzqrfmvCLAXsSiyP7NZtHG1ibadt6+4v7nJus+70LzLvcK+sb+bwH/BX8I6wxLD5sS5xarGnMeLyHjJYspJyy7MDszszcXOnM9w0ELRE9Hj0rLTgdRR1SXWBNbp18zYr9mS2nTbVtw43Rrd/N7e38HgpeGJ4m/jVeQ85STmDeb259TotOmX6n/rbOxj7WPucO+L8LXx7/NA9KH2E/eY+Sv6zvx//jr//wAAAFYBLgHrAoQDMgPoBJIFSwYVBt0HswiMCWcKRAsqDA8M/A3nDtgP2BDfEeQS7RPzFPYV/Rb7F/0Y/hn9GvYb8xzvHeYe3B/SIMUhuSKmI4skbCVMJionCSfqKMkpqSqKK2ksSy0tLg0u7y/RMLQxlzJ8M2M0UTVCNjI3ITgSOP857jrcO8k8tj2iPow/d0BgQUpCMkMaRAJE6UXORrBHkUhzSVRKNksXS/tM303DTqpPkVB7UWZSU1NBVDFVIVYTVwdX+ljrWdxazFu9XK9doF6TX4dgfGFyYmljYWRaZVRmUWdOaEtpS2pIaztsLm0hbhVvC3ACcPxx+HL5c/11BXYSdyN4OnlUenN7lny8feZ/C4AfgS2CPYNOhGKFd4aNh6aIv4naiveMFI0yjlGPbpCNkauSyJPklP+WGpc1mFCZa5qFm5+cuJ3Qnuif/qEUoimjPaRQpWOmdaeHqJipqarMq++tEq4zr1OwcbGPsquzxLTctfK3BrgZuSq6OrtKvFi9Zr50v3/AgcGDwoXDhsSHxYjGiseMyI3JjcqNy43MjM2LzonPh9CE0YHSfdN21HHVb9Zw13TYe9mF2pPbotyz3cbe2d/t4QDiEuMi5DHlPuZJ52LooOnt6zXse+2+7v7wO/F28q7z5PUY9kv3f/iz+ef7HPxS/Yr+xP//AAAAVgFFAkEDLwPuBMEFhwZTBygH8Qi5CYYKUgscC94Mow1tDjkPAg/BEIQRShIPEtATkBRPFQ8VzRaKF0YYARi4GW4aIxrYG4scPhztHZseSB70H54gSCDuIZQiOiLcI30kICS+JV4l/CaYJzQnzChlKPwpkyorKr8rUyvmLIEtJS3YLowvQi/0MKcxWzINMr8zcDQhNNI1gjYyNuE3jzg9OO05mzpJOvU7ozxRPP49qz5ZPwc/tUBjQRJBwEJwQyBD0ESCRTRF50aaR09IBUi7SXFKK0rkS55MWk0WTdNOkk9SUBNQ1lGZUl5TJFPqVLFVelZFVw9X2limWXNaQlsMW9Zcn11oXjJe+1/FYJFhXGIpYvZjxGSTZWFmM2cEZ9Zoqml/alRrLGwFbN9tum6Yb3dwV3E6ch5zBHPsdNV1wXavd554j3mBend7a3xkfV1+WH9UgFKBUYJRg1KEVIVZhl2HZYhriXOKf4uIjJKNno6pj7aQw5HRkt6T7pUElimXXJiQmcWa+5wunWKelZ/KoPyiMqNlpJqlz6cEqDypd6qvq+utKq5qr6qw77I2s4C0zLYZt2y4xLofu3+84r5Mv7zBMcKsxCvFscdCyNrKeMwfzdDPjdFU0ybVANbr2OTa6t0A3yXhX+Oq5gXoeusA7aTwY/M/9jj5VfyY//8AAG5kaW4AAAAAAAAGNgAAlYcAAFVTAABSqQAAjKwAACd5AAAXCgAAUA0AAFQ5AAIhRwAB9cIAAUo9AAMBAAACAAAAAQAEAAoAEwAdACoAOABIAFkAbACBAJcArwDJAOMA/QEYATUBUwFzAZUBuAHdAgMCLAJWAoECrwLeAw8DQgN3A60D5gQgBFwEmwTbBRwFYAWlBe0GNgaBBs4HHQdtB78IEwhpCMEJGgl1CdIKMwqXCvwLYwvNDDkMqA0YDYwOAg57DvcPdQ/2EHoRARGKEhYSpBM4E9AUahUHFaUWRRbmF4gYKxjQGXQaGRq+G2QcCxyyHVoeAx6tH1sgFSDRIY8iTyMRI9MklyVbJiEm5iesKHMpOioBKskrkSxbLSUt8C7SL7wwpjGSMn4zaTRTNTo2HzcBN+A4vDmUOmo7PTwOPNw9qT50Pz9ACEDRQbNCtEO3RLpFvkbDR8lIz0nWSt5L50zxTftPCFAWUSZSOFNMVGNVfFaYV75Y6FoTW0FccF2iXtVgCmFBYntjuGT3Zjhne2jBagprVWykbfVvSHCece9zPHSLdd53NHiQefF7V3zGfj1/voFLguOEiYY9iACJ0YuwjZyPkpFIkwOUxZaRmGWaQ5wsniKgJaI0pE6mcaibqsutAK83sU6zWbVot3y5lbuyvdK/9sIexEjGdMigys7M/c8t0V3TjtXA2BPaY9yt3uzhHOM45UDnMekO6tfsju4v78HxSPLE9DL1mvb6+FH5pfrx/Dr9f/7A//8AAAABAAQACgASAB0AKQA3AEYAVwBqAH4AlACrAMQA3gD4ARMBMAFOAW4BkAGzAdkCAAIpAlQCggKxAuIDFgNMA4QDvwP7BD0EgwTMBRgFZgW2BgkGXga2BxAHbAfLCCwIjwj1CVwJxgouCpcLAwtxC+EMVQzKDUMNvg48Dr0PQQ/IEFEQ3hFtEf8SlBMuE80UbhUSFbgWYRcLF7gYZhkWGccaeRssG+Eclx1PHggewh+AIEIhBiHNIpYjYSQuJPwlzCaeJ3EoRSkbKfIqyiujLH8tWy47LykwGDEJMfwy7zPjNNc1yja7N6w4mjmHOnI7WzxDPSo+ED71P9pAvkGvQrFDs0S3RbtGv0fESMpJ0ErXS99M503xTvtQCFEWUidTOVRNVWRWfVeaWLlZ2lr9XCJdSl50X6Bgz2IBYzZkbmWpZuZoJmlqarFr+m1HbpZv6HE8cn1zv3UEdkx3l3jmejl7jnznfkV/qIEOgnmD54VZhtCISonHi0iMzI5Sj+CRf5MelMCWZpgOmbibZJ0TnsagfaI2o/Klsad1qTyrBqzVrqWwfLJctDa2DrfjubS7g71OvxjA4cKpxHLGPMgHydbLqc2Az1zRPtMl1RHWyNhV2eXbet0U3rLgVOH846jlWecP6MnqiOxL7hDv1/Gg82r1NvcC+M/6m/xn/jP//wAAAAEAAwAGAAwAEwAdACgANgBGAFgAbQCFAJ8AuwDaAP0BIgFKAXUBpAHWAgsCRAKBAsIDCANRA58D8gRKBKcFCQVyBd8GVAbOB04H1QhjCPkJlgo5CuULmQxADNwNew4gDskPdxAqEOMRnxJiEykT9xTHFZ4WexdbGEAZKxoYGwscAhz8Hfoe/CAAIQciEiMdJC4lPSZSJ2cogCmZKrUr0SzwLhAvMjBXMX4ypDPPNPs2KTdZOJI50jsUPFk9pD7vQD1BjULfRDNFi0bhSDxJlkryTFBNrU8MUGxRylMqVItV6ldKWKpaCVtpXMdeJl+FYOViQ2OmZQNmZGfDaSZqhmvobUxur3AVcXhy4HREda53GHh+eet7WHzGfjZ/p4EZgo6EBIV8hvKIWomxiv+MVI2njvqQU5GukwqUaZXGlyuYjJnvm1ecvZ4mn5Gg/KJko8ylO6anqBGpeqrmrFOtvK8msI+x9rNetMa2LbeQuPC6UbuuvQq+Zr++wRLCZcO2xQTGUMebyOPKKctpzKbN4c8a0FHRhdK00+LVCtYw11LYctmO2qnbw9zV3ebe8d/84QHiB+MG5AblAOX65u3n3ujN6bjqouuI7G7tTe4r7wfv3/C48YnyWvMp8/L0vPWC9kT3BvfE+H/5O/nx+qX7WvwK/Lb9Y/4N/rL/Wf//AABzZjMyAAAAAAABDEIAAAXe///zJgAAB5IAAP2R///7ov///aMAAAPcAADAbG1tb2QAAAAAAAAGEAAAoBsAAAAA0bD1AAAAAAAAAAAAAAAAAAAAAAD/wAARCAGNAqkDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9sAQwACAgICAgIDAgIDBQMDAwUGBQUFBQYIBgYGBgYICggICAgICAoKCgoKCgoKDAwMDAwMDg4ODg4PDw8PDw8PDw8P/9sAQwECAgIEBAQHBAQHEAsJCxAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQ/90ABAAr/9oADAMBAAIRAxEAPwD9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0P38ooooAKKKKACiiigAoor51+Kf7SPhv4c+MLL4Z6H4f1jx744v7Y3o0XQII5p7e0yUFzdyzywwW8LONqs8gLH7qmgD6Kor5x+F/wC0r4b+IXjW6+F3iDw7rPgHxxa2v21dH1+3iilurQEK1xZzW8s0FxGjHaxSTcD1UAGuQl/bK8Dp4D8R/EiHwxr9xomj66nhvTnjgtjJruoveGw2aehuASguF2lpjF6gHBFAH17RWfpN5PqOl2eoXVnLp811DHK9tOUMsDOoYxuY2ZNyE7W2sRkcEjmtCgAorifHXxE8JfDez0q/8YXhsoNa1Sy0a1YRSS777UZRDbxkRqxUO5A3HCr1JArtqAPgb4aftOftQfFzwJo3xJ8EfAbS5tC8QQC5s3uPGaQytEWIBeP+zG2njpk/Wu6/4Wt+2T/0QHRv/C4j/wDlXR+wH/yZt8J/+wNH/wCjHr68kkjijaWVgiICzMxwABySSegFAHyH/wALW/bJ/wCiA6N/4XEf/wAq6P8Aha37ZP8A0QHRv/C4j/8AlXX1RoniDQPE1j/afhvUrbVbPe0fnWkyTxb0+8u+MsMjuM8Vr0AfAPhn9qD9qLxZ4z8Y+A9H+Amltqvgaeyt9SD+NEWNZL+1S8h8tv7L+cGKRST2PFd//wALW/bJ/wCiA6N/4XEf/wAq6r/Af/k6P9pv/sLeF/8A1H7WvsegD5A/4Wt+2T/0QHRv/C4j/wDlXR/wtb9sn/ogOjf+FxH/APKuvrP+0dPGoDSDdRfbjEZxb7183yg20ybM7tu443YxnirlAHwH43/ad/ak+H114Xs/EXwE0tJfGGsQ6HYCLxojhr2eGa4QOf7LG1dkDkt64Heu9/4Wt+2T/wBEB0b/AMLiP/5V0ftX/wDIxfs+/wDZTNN/9NWqV9f0AfIH/C1v2yf+iA6N/wCFxH/8q6P+Frftk/8ARAdG/wDC4j/+VdfTviLxf4S8IQw3PizW7HRIrl/Lie+uYrZZH/uqZWUE89BzXQqyuodCCrDII5BBoA+Qf+Frftk/9EB0b/wuI/8A5V1wXww/ad/ak+LvgDRPiV4N+AmlyaL4gtxc2jT+NEikMZJALIdLJU8dK+/K+QP2A/8Akzb4T/8AYGj/APRj0AH/AAtb9sn/AKIDo3/hcR//ACro/wCFrftk/wDRAdG/8LiP/wCVdfWWo6lp2kWM2p6tdRWVnbKXlmndY4o1HVmdiAo9yaj0nWNJ17T4dW0K9g1GxuBuiuLaRZopF9VdCVI+hoA+Uf8Aha37ZP8A0QHRv/C4j/8AlXXBeGv2nf2pPFnjDxf4G0j4CaW2qeB7izttSD+NEVFkvrWO8iEbf2X848qRST2PFfflfIHwJ/5OY/aX/wCwz4a/9R6zoAP+Frftk/8ARAdG/wDC4j/+VdH/AAtb9sn/AKIDo3/hcR//ACrr6/rOm1fSbfU7bRZ72CPUbyOSWC2aRRNLHCVEjpGTuZULruIBA3DPUUAfKP8Awtb9sn/ogOjf+FxH/wDKuuA139qD9qLw78QPCvwz1L4CaWNb8Ywalcaeq+NEaNo9KWFrje/9l4UgTptHfn0r7+r44+Ln/J5v7PX/AGCfHP8A6J02gCx/wtb9sn/ogOjf+FxH/wDKuj/ha37ZP/RAdG/8LiP/AOVdfX9cnrvj3wL4XvE0/wATeI9N0i6kQSrFeXkNvI0ZJAYLIykqSpGcYyD6UAfNn/C1v2yf+iA6N/4XEf8A8q65fxv+0L+1h8PvBev+PfEfwD0lNJ8NafdaneNH41R3FvZxNNKVUaX8zBEOB3PFfccUsVxEk8DrJHIoZWUgqykZBBHBBHQ14J+1j/yaz8ZP+xM8Q/8ApunoA8q0P43fte+IdE0/X9O+AWjm01O3iuoS3jeNW8uZA65H9l8HBGRWr/wtb9sn/ogOjf8AhcR//Kuvf/hN/wAkr8G/9gXTv/SaOu3vLyz061lv9Qnjtra3UvJLKwREVeSzM2AAO5NAHyT/AMLW/bJ/6IDo3/hcR/8Ayro/4Wt+2T/0QHRv/C4j/wDlXX1Roev6F4n0yLWvDWpW2rafcZ8u5tJknhfacHbJGWU4IwcHrWvQB8B+Gv2nf2pPFnjDxf4G0j4CaW2qeB7izttSD+NEVFkvrWO8iEbf2X848qRST2PFd7/wtb9sn/ogOjf+FxH/APKuj4E/8nMftL/9hnw1/wCo9Z19a3t9ZaZZz6jqNxHaWlsjSSzSuI440QZZnZiAqgckk4FAHyV/wtb9sn/ogOjf+FxH/wDKuj/ha37ZP/RAdG/8LiP/AOVdfROlfEv4ca7fw6VonivSdQvbgkRwW99BLK5ALHaiOWOACTgdBXbUAfAet/tO/tSeH/H/AIX+Guo/ATSxrXi+31G5sFXxojRmPShCbgu/9l4Ujz02jvk+ld7/AMLW/bJ/6IDo3/hcR/8Ayro+Kv8AyeT8Af8AsDeOP/Rel19f0AfIH/C1v2yf+iA6N/4XEf8A8q6P+Frftk/9EB0b/wALiP8A+VdfTmp+MfCOiavY6BrOuWNhqmpnFpaXFzFFcXBJxiKN2DPzx8oPNdHQB8A/E79qD9qL4R+DLvx54x+Amlx6VZz2dvIYfGiSyeZf3UVnDhRpYyDLMgJ7DJ7V3/8Awtb9sn/ogOjf+FxH/wDKuq/7fX/JrniH/sLeF/8A1INPr7HoA+QP+Frftk/9EB0b/wALiP8A+VdH/C1v2yf+iA6N/wCFxH/8q6+qNc8QaD4Y06TWPEupW2k2ERAe4u5kghUscAF5CqjJ6ZNaFrdW17bRXllMlxBMoeOSNg6OrDIZWGQQR0IoA+R/+Frftk/9EB0b/wALiP8A+VdcF4A/ad/ak+JVrrV54Y+AmlvFoGsahod0ZfGiRkXulzG3uAoOlnKh1IVu45r78r5A/Y3/AORd+Kf/AGUzxr/6dZaAD/ha37ZP/RAdG/8AC4j/APlXR/wtb9sn/ogOjf8AhcR//KuvrK+1HT9Mijn1K6itI5ZYoEaZ1jVpZ3EcUYLEAu7sFVRyzEAZJqlrXiTw74bjgl8Rara6Wl1IIYWup44BJI3REMhXcx7Ac0AfLX/C1v2yf+iA6N/4XEf/AMq6d4R/aB+MJ+Mfhf4SfF74W2fg4+L7HVbywvLPxEurgnSRAZkeIWVvtyLhcNvP09Pr2vkD4q/8nk/AH/sDeOP/AEXpdAH1/RRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH//R/fyiiigAooooAKKKKACvg74Ez2mk/tqftH6L4gYR+IdYHhrUdP8AM+V7nR4tP8gNADyY4bgOkm3gOeeTX3jXiPxc/Z1+Efxvn03UvH+jNLq+jbhYanZXVxp+o2ofO5Y7q0kil2HJJQsUJ525oA+b/wBoiw0bx1+2B8APA1nGt7qWnW/im/1hYyd9vod1pxs284qQypczOsaHI+YZHIzXwrpfwM+Fc37J/gPVZNCU3V98WorCZ/tFx89s3imayMePMwP3ChMgZ4zndzX7B/Cf4AfCn4KHUbnwBo7QajrJRr/Uby5uNQ1C7KDCiW7u5JZmUdQm4ICSQoyadD8APhHb+D9N8Aw6Dt0HSNZXxDa232q6Pl6ot62oCfzDL5jf6Sxk2MxTnbt2YWgD84/jh8H3uPid8QPFWoeDv+Fv+CdHs9PsLH/hHfEZtfEPgUadYp5scNpJKiNK5IuVxIJWyN6upxWZ4n8U337Qnxn8F+DdO8Nal8XPANl8ONM8QWGmX+sR6NJfXF/OYG1S+wY1uJo1jEZTG2OR3ZQMg1+gPxA/ZQ+DfxJ8T6p4t1211Oyvtfiig1ddL1jUNMg1WGFPLjS+htJ4o5wqfJl13bcKTgAVreNf2Z/g/wCObLw7a3elT6NN4StfsOk3eiXt1pF3Z2e1UNtHPZSRSeQVUDy2JTjOM80Aflt4r+Hl5r/wd8PeGPitZw3lr4c+MukaNo9odcXWbnS9I1C7tBPpd1dW8rHzIcsgEp81I9nTgn9uNO0+z0nT7XStPj8m1s4khhQEnbHGoVVySScAAcnNeK3H7NHwTufhUvwVPhtYvCaTrdiCK4uIpxdpKJxdfa0kFybjzRvMxk3k9WNe1adY2+l6fbaZabzBaRJDH5kjyvsjUKu6SQs7nA5ZiSTySTQB8mfsB/8AJm3wn/7A0f8A6Mer37Zk5l+Eul+GrtnTRfFfirwzomsMjFf+JXqGq28N2jMOiTRkwv6q5HeqP7Af/Jm3wn/7A0f/AKMevpfxr4K8LfEXwrqXgnxrp0eraJq8Xk3NtLkK65DAhlIZWVgGR1IZWAZSGAIAPlv4eeE9F+Hn7YPi7wz8PdOtdE8Nan4K0fUb/T7GJLe2TUkv7y2hnEMYCK8tuhRiANwiXOcDH2ZXmHw2+D3gX4ULqUnhOC6kvdZeJ76/1G/utUv7nyF2QrLdXss0zJEpIjTftTJ2gFmJ9PoA+OPgP/ydH+03/wBhbwv/AOo/a19j18cfAf8A5Oj/AGm/+wt4X/8AUfta+x6APhbwV4JTwf8At4+Irga3qutPrfgRL1v7Tujci23au4EFsu1RFAoHyoB1JJJJJr7prkh4F8LDx23xLFl/xUj6aukG782T/jxWY3Ai8vd5f+sJbds3dt2OK62gD5A/av8A+Ri/Z9/7KZpv/pq1Svr+vkD9q/8A5GL9n3/spmm/+mrVK+v6APhz4/6J8J5Pix9q17wlJ8XPH+t+HRpukeE3toLi2tLIXErT30slwvk2UU8jpHLcSMCwiVIldgVPvP7OXw68R/CT4F+Cfhr4u1FdU1fw9pkNpcTxs7x7kHEcbP8AM0cQIjQsASqgkDpWd44/Zn+EPxE8ZT/EDxJZaomv3VrBZS3On69q+l+Zb2zO0UbJYXkEZCNI5GVzlie9eteFPC+keC/D1l4X0L7R9g09CkX2u7uL6faWLfPcXUks0hyTy7sccZwAKAOhr5A/YD/5M2+E/wD2Bo//AEY9fX9fIH7Af/Jm3wn/AOwNH/6MegD1D44+D/h74/0/wz4U+IN3E0cmsw3dhpNxPFFba1fWUM08VlcJLHL5sXymZo1XOYg3Kqyn59/Y7tH0D4i/HHwtqvhm28Da2ms6XqU/h/S5Em0i0t73T0jgntZkWISPcm3kec+RCQ4A2H7zfWXxH+GHgz4saDD4d8bWclzb2tzFe2stvcTWd1aXcGfLuLa5tnjmhlTJAdHBwSDwSDQ+GXwf8B/CO11KHwbaTi51qcXWo319d3GoX97OqhFe4u7uSWaTao2qGfao4UCgD06vkD4E/wDJzH7S/wD2GfDX/qPWdfX9fIHwJ/5OY/aX/wCwz4a/9R6zoA+rtY1S10PSb3Wr0ObfT4JLiURo0j7IlLttRQWZsDhQCSeBX5G/DH4s+HfF/wC2H8Ofip4p1K8i8R+M9H8RWX9lyWV6kej2jTaaNL08b4QjS4aaS5mXKedIwLiNYq/YOuV1DwT4Y1Xxfo3j2/svN13w/bXtnY3PmSL5MGomFrlPLVhG3mG3i5ZSV2/KRlsgHVV8cfFz/k839nr/ALBPjn/0TptfY9fHHxc/5PN/Z6/7BPjn/wBE6bQB9j1+bHxs+HPii8+KnxR+MS+CvAHxD0nw/pOmILTxIwur+ODTLee7nt4gYJUspJfPZlaTIf5CyhRur9J68A8e/sw/Bj4k+INQ8TeKNIuvtmtxwQ6qtlqV9YQarDagrDHqEFpPFFdrGp2qJkb5fl+7laAPSvhr4p0jxx8OfCvjXQLRrDS/EGlWOoWlsyhGggu4EljjKrwpRWCkDgYwK81/ax/5NZ+Mn/YmeIf/AE3T17vaWlrYWsNjYwpb21sixxRRqEREQYVVUcAADAA4Arwj9rH/AJNZ+Mn/AGJniH/03T0Ad/8ACb/klfg3/sC6d/6TR18uftq3Ov6jN8IPh7pGkWmu23izxdHFdWOozGDTrr7HY3V3bxXjBJS0C3Ecc7RhGMnk7B96vqP4Tf8AJK/Bv/YF07/0mjqT4jfDPwX8V/Dn/CLeObFr2ySeK6haKaW1uLe5gOYp7e4geOaGVCTteN1YAkZwSCAfOX7KRtNC8SfFj4d3fhTTfCXiPRNas7vVYdBmkk0S5k1GwheG6tIZEjNu8kSKJ4tv+sXfubfmvsmvOvht8KvBPwm0m70nwXaSxf2lcte3tzd3U99e3l06qrTXN1dPLNK+1VUF3OFAVcAAV6LQB8gfAn/k5j9pf/sM+Gv/AFHrOvq7V9I0nxBpV5oWvWUGpabqETwXNrcxrNBPDICrxyRuCroykhlYEEcEV8o/An/k5j9pf/sM+Gv/AFHrOvr+gD4J+D3we+D/AIm/aE8QfE3wP4G0Hw3ofwuuLjw7pL6XpltZPd6y0ajVLuR4I0Z1tw4s4lOVDi4brtI+9q5LwT4F8LfDrQR4Z8HWX2DTvtN3eFDLJMzXF9cSXVxI0kzPIzSTSuxyxxnAwoAHW0AfIHxV/wCTyfgD/wBgbxx/6L0uvr+vkD4q/wDJ5PwB/wCwN44/9F6XX1/QB+KH7SXhXWfHHiP9prxP4V8E6X4v0TTksLbU/EGpmNdY0CbS9Ohlu00SJs+d9nhK3KZmtc3DuMyDBP7KeGtSsNZ8OaVq+lXD3dlfWkE8E0n35YpYwyO2QDllIJ4614h43/ZV+CnxB8Tal4q8RaXeC414RDV7ez1S+srHVhAoWMahaW08cFztVQv71DuUBWyvFfQsMMNtDHb28axRRKEREAVVVRgAAcAAdBQB8e/t9f8AJrniH/sLeF//AFINPr7Hr44/b6/5Nc8Q/wDYW8L/APqQafX2PQB8UftReFZNX+J3wn8T614Qb4jeFdAbWWvfDsItJ7h7q4igS1v0sryWKO5W1xIrYJaPzg6g9l/YXl1ZPh5430q70Y+G9L0rxvr9tpGkmSOT+zrAypKLT9yzxJ5E0ksZjiZo0YFUJUA19EfEn4Q+CfiumlN4riu47zQppLiwvdOvrrTb21eaMwy+Vc2ckUqrJGxR13bWB5HAx0vgvwV4X+Hfhmx8HeDLBdN0jTlZYYFZnwXYu7M8hZ3d3Znd3Ys7EsxJJNAHU18gfsb/APIu/FP/ALKZ41/9OstfX9fIH7G//Iu/FP8A7KZ41/8ATrLQByn7ZnghL/VPhJ46fW9ViOmeP/B1ummRXRTTJTJq8YM01uF/eSgNhWLYGBgZ5qxe+CPA/wAYv2sPiT4f+LOi2uvWHhjwjoVvpNrqESTwxQavNftqFxCsgIWSRoIY2kXDARgZxX1r4v8AAvhbx7a6bZ+LLL7dDpGpWWr2q+ZJF5d9p0yz20uYmUt5cihtrZVsYZSOK4X4l/AD4YfFrVbbXfGFjdjUre1k09rnTtSvdLmnsJm3SWdw9jNC09uzcmKQsoJJAG5sgHF/sZajr+q/ss/DS98S3b3962jwoLmRizzwRlkt5WY8sXhVGJJJOcknrXN/FX/k8n4A/wDYG8cf+i9Lr6v0nSdM0HSrPQ9EtYrHTtOhjt7a3hQJFDDEoSONFGAqqoAAHAAr5Q+Kv/J5PwB/7A3jj/0XpdAH1/RRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH//0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooA/JL9jr4N/tJ6/8AsxfDrWfB/wC0Je+FdGu9LR7XS08NaPeLaR72/dieeIyyDOTlznmvpb/hQf7XH/R0mof+EjoP/wAarY/YD/5M2+E//YGj/wDRj19f0AfFH/Cg/wBrj/o6TUP/AAkdB/8AjVH/AAoP9rj/AKOk1D/wkdB/+NV9r0UAfkZ8Ifg5+0jf/H/486XpH7Qd7peq6ZqOgJqWoDw3o8zanJLo1vJC7QvF5cHkxFYgI+HC72+Ymvpz/hQf7XH/AEdJqH/hI6D/APGq0PgP/wAnR/tN/wDYW8L/APqP2tfY9AHxR/woP9rj/o6TUP8AwkdB/wDjVH/Cg/2uP+jpNQ/8JHQf/jVfa9FAH5J/tEfBv9pPSdb+DUfiL9oS+12XUPHdja2Dt4a0e2/s+8bT790vAIosTFEV08qT5D5m48qK+lf+FB/tcf8AR0mof+EjoP8A8arY/av/AORi/Z9/7KZpv/pq1Svr+gD4o/4UH+1x/wBHSah/4SOg/wDxqj/hQf7XH/R0mof+EjoP/wAar7XooA+KP+FB/tcf9HSah/4SOg//ABqvmr9jz4N/tJeIP2ZPh3rPg39oO+8K6Jd6Yj2mlp4b0a9W0jLtiMXE8XmSY67m5r9bK+QP2A/+TNvhP/2Bo/8A0Y9AGP8A8KD/AGuP+jpNQ/8ACR0H/wCNUf8ACg/2uP8Ao6TUP/CR0H/41X2vRQB8Uf8ACg/2uP8Ao6TUP/CR0H/41XzV8I/g3+0nf/Hf47aZpH7Ql9peqaZqmhJqV+PDWjzHU5JdFtpIpGheLZB5UTLEFj4bbvb5ia/WyvkD4E/8nMftL/8AYZ8Nf+o9Z0AY/wDwoP8Aa4/6Ok1D/wAJHQf/AI1R/wAKD/a4/wCjpNQ/8JHQf/jVfa9FAHxR/wAKD/a4/wCjpNQ/8JHQf/jVfMfxH+Dn7SNp+1B8F9F1L9oO9v8AWtR07xY9hqh8N6PG2nRwRWJuEFukXlTfaAyAmTmPZ8n3jX6518cfFz/k839nr/sE+Of/AETptAGf/wAKD/a4/wCjpNQ/8JHQf/jVH/Cg/wBrj/o6TUP/AAkdB/8AjVfa9FAHxR/woP8Aa4/6Ok1D/wAJHQf/AI1Xjf7RPwT/AGn9J/Z++J2q+I/2jr7XdJs/C+tTXmnN4X0W2F5bx2UrS25mii8yMSoCm9PmXORyBX6d14B+1j/yaz8ZP+xM8Q/+m6egD51+HXwL/aru/h94YutO/aZv7C0m0uyeG3HhTQ5BDG0CFYw7Rbm2jA3Hk4yea7L/AIUH+1x/0dJqH/hI6D/8ar6X+E3/ACSvwb/2BdO/9Jo69AoA+KP+FB/tcf8AR0mof+EjoP8A8ao/4UH+1x/0dJqH/hI6D/8AGq+16KAPyT+Enwb/AGkr/wCO3x10zR/2g77S9U0zU9CTUr8eG9GmOpyS6NbSRSGF4tkHkxMsO2Phtu9vmJr6V/4UH+1x/wBHSah/4SOg/wDxqtj4E/8AJzH7S/8A2GfDX/qPWdfX9AHxR/woP9rj/o6TUP8AwkdB/wDjVH/Cg/2uP+jpNQ/8JHQf/jVfa9FAH5J/EL4N/tJ2n7Tnwd0bUf2hL6+1rUNL8VvYaofDWjxtp8cCaf8AaIxbrF5c32gOgLScx+X8v3jX0r/woP8Aa4/6Ok1D/wAJHQf/AI1Wx8Vf+TyfgD/2BvHH/ovS6+v6APij/hQf7XH/AEdJqH/hI6D/APGqP+FB/tcf9HSah/4SOg//ABqvteigD8jP2w/g5+0joHwA1rVPGH7Qd74p0qPUdASTT38N6PZrJJLrNnHC/nQRCQeTKySgDhymxvlY19Of8KD/AGuP+jpNQ/8ACR0H/wCNVoft9f8AJrniH/sLeF//AFINPr7HoA+KP+FB/tcf9HSah/4SOg//ABqj/hQf7XH/AEdJqH/hI6D/APGq+16KAPij/hQf7XH/AEdJqH/hI6D/APGq+av2Y/g3+0nrOifECTwx+0JfeHorXx34ptbpF8NaPdfaryDUJEuLwmaLMZuHBcxL8iZ2rxX62V8gfsb/APIu/FP/ALKZ41/9OstAGP8A8KD/AGuP+jpNQ/8ACR0H/wCNUf8ACg/2uP8Ao6TUP/CR0H/41X2vRQB8Uf8ACg/2uP8Ao6TUP/CR0H/41XlFr8P/AIveCP2yvgqfil8VLn4kfa9H8YG0E+kafpQtBHFp4lA+xIvmeaXQnd93yxt+81fpdXyB8Vf+TyfgD/2BvHH/AKL0ugD6/oor46/bm+KPjv4Q/A+Lxd8OtUOkas2u6NZmcQwz/uLq7SOZNsyOnzISM4yOxBoA+xaKK+WfH/7aP7OXw08U6j4O8T+JpW1DRCo1RrHTr7ULfTdwyPtlxaQSxQn1V2DL1YAc0AfU1FeQ+Ovj58Hfhv8AD6y+KfjDxVZ2nhbUxB9ivY2a5W9Nyu6FbVLcSSTs6/MoiViVBbGATXN/Db9qf4DfFzxJB4N8A+KU1HX5rae7Onva3VtdRRW5jEhninijaEgyphZApYHKgjJAB9BUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB//9P9/KKKKACiiigAooooAKKKKACvgr4oftV2HwN/aL8ZWXxS8Rrp/wAPdA8Dadq8Nl5MJmm1S51C5g2wEKJpZZUjVVj37BgsQoDNX3rX58eLf2evDHxW/bm1vxJ8TfBR17w1B8PLWwtLu8tpHsBdXF7dx3EUcpHlGcQSdAd6K24YyDQB6x8JfFHxch8P+I/j7+0XrcHhPw1dWjX1l4aRLdoNE0yFPM8+9vVjM8126DdIqyeUmSqoW+7f8AftY+APHninRPCk2h+IvC0viuOSXQbnXdLextdYSKPzm+ySFm+byv3gSURuyDIU18X618LPjtL+z98YP2GbvT9S1n+x9LW48D+IpIZPsmp6OkyTQ6XPebfJS8g8v7Psdl3IQQAi7joeAfDmkfEv4j/DGDTrL4o65ceF9Ri1jUR4sluNN03w7Pa28gUH7TYot3MzOYVit22lGZjIqjkA+2If2nvhg/wd8V/G66e7stD8FXGpWeqQTwqt7Bd6ZMYJbcxBypkZwBGN/wA29ckZ4960u+/tPTbTUvIltftcMc3kzqFlj8xQ2yRQSAy5wwBOD3r8oviX8PfEU37XNx+zjp1m0ngP4saxo/xF1MrjyIotCVl1O3kXqftl3b6eSemXPqMfrXQB8gfsB/8AJm3wn/7A0f8A6Melvf2udB0zwh4k1u80GafXrDxXqvhDQ9Cs5xcXuuX+nS+Unkgonlq/35SwZIEBZnbAyn7Af/Jm3wn/AOwNH/6MevlXQv2Z/H2l6l8RP2kPAltqcHxU8N+PfEeo6JYak8sVjqeiyXD+dYwwyAIseoROzJcKCTKI2D7V4APsj4o/tPaF8FdA8Jx/ErThbeM/FVxptpHotjLLeRxy391HbOftv2eOPy4S5Jd1TeV2qMsK+oa+Of2hLrW/i5+zZous+GfDerxXuq614Svm0u5sJ4tStUh1uymuFntWTzEMCI7SEjaFUvnZ81fY1AHxx8B/+To/2m/+wt4X/wDUfta9V8TfHHRPB/xbb4ceJIodO0q38KXvim61m4uRHFbw2V3DbPG8bJjbiXeZPMGNuNpzkeVfAf8A5Oj/AGm/+wt4X/8AUfta89/aD/Zp0z9or9pnStI8dW2sR+DV8CalDLdWDzW1q1+2oW5t4pp0Gx3jz9pjhZuXiVyrKpBAPTLT9qfUp/hyfifN4Av4tN8Rava6T4NsjcKmp+IDeErDcPbzJEljDJhpEMsrN5KmRgnCn0P4NfGy7+Jms+K/BXirwtc+C/GPgqS0GpaZcXEN4nkahG0lpcQXMBKSxyqjjorKysrKCK+ZL741/tA+BPhFJ4Q8T+CdT1v4j+GNctNAOuQaBqGq6dc2UsbvH4hhhso2abFuhEsMbqUuWEbtGrivY/2XrHwgjeLdb0+LxXfeLNZmtLjXta8WaJe6LcajIEeOBLeO5t7eIQW6qypDAu2IMN2WfcwBS/av/wCRi/Z9/wCymab/AOmrVK9k+OXxS/4Uv8MtS+Iv9mf2x/Z8+nwfZfO+z7/t17BZ58zZJjZ52/G05244zkeN/tX/APIxfs+/9lM03/01apWp+2z4U1/xv+zT4p8LeF7W9vNSv7jRljTTYnmu1CaraPJJEqKxzEitITtIUKWPANAHWxfHI+IvjQ/wi+HWh/8ACRQ6CpbxPrH2nyLLR5HXMNopEUn2m8f7zQKUEafM7gkKa/w4/aT8B/Fb4teK/hX4J869bwhY2l1d3zRyQwtNdTTxGCNZURn8vycmRcoS20HKmvHfhj8O9c/ZR+LEHw+8Habqmu/CX4hu1xHMFn1G40HX0jAne7mw8n2XUFTeZpCVjuAwYqsgNel6DoGuw/tieMvE8um3KaPdeCdAtIb1oXFtJcQ6hqbyQpMRsaRFkRmQHIDKSACMgH07XyB+wH/yZt8J/wDsDR/+jHr6/r5A/YD/AOTNvhP/ANgaP/0Y9AFC3/bBstQ+F3hnxPo3haTVPHPje/1PTtC8K212HnupNNvp7OSeS5MQEFqiw+bPO8e2JW2/O23d3vxC/aW8I/DPxl4D+GPiGEz+MvG1/Y2P2G0MssNqLsOHna6aFEaNGQqoISR+CEAzj4P+E/7PvxC+DXw60f8Aaf8AAmk61efEbRtS14a14dvfO83U/DU+q3DPYWdrKB5Miqq3trsXMsrNneJVA+0vj9aav450/wCC2t+GtI1C5hj8caFqlxGbOdJ7S08m4Ly3ULIJIBHvUSeYq7GOGwaAPq+vkD4E/wDJzH7S/wD2GfDX/qPWdfX9fIHwJ/5OY/aX/wCwz4a/9R6zoA9D8T/H7w34J+KWueBPGCw6Rovh/wAKReKbvWri52xxxPeS2phMWzt5W4MHJYsFCZwT59D+094nfwNo3i6X4a38eoeOdY/s3whorXkUeo6nAYZbkXd4kyRx2CfZ4ZJmVnlZUC7sOwWvJfjv+y9Y/tEftRXsXjFdZsfDkHgG2itL+yeaC0XV11K6aB2kUCOWa13rPHCzEAlWZSMGus0f44fFvRvANloXxp8B63Jd6TqFz4d8V6vo1pfFvINs5tdb0tLOFpbiC4IQSm3IktXY5UbBQB9D/Bv4vp8WLLxBBfaBeeFtf8Jam2katpl68MrwXQgiuFMc0DvHLFJFMjI4IyDyorxz4uf8nm/s9f8AYJ8c/wDonTazf2MdA1fQLf4kGxtdZh8C6l4gF74fuPEsE0Ot3gltYRez3RulS7lRrhSsEl0PNMagfcVK0vi5/wAnm/s9f9gnxz/6J02gD2z4vfFL/hVVl4WvP7M/tT/hJvEmkeHtvneR5H9q3Ag8/Ox9/l53bPl3dNy9a4Wy/aP03XPHHirTfDOlC/8AA3w/tbp/EXilrgx2lte2yGR7K0iWJzdyxICbgh0SHhSWc7K5X9s/4f6z8TfAPgzwlo8Wplbnxr4ca7n0gSC7s7MXYE90kkasYfJQlvNIxHjcSMV5/wCCdL8Tfsjaj4p+EWkeEdW8X/Cy403U9f8ACi2FrcahJZTxI895oNw6JK2J3JeyeXJcu0WXcAUAej/Dv9qPVfFXjXwj4X8afDrU/BVl8RrS4vPDF9dXVrci9W2g+1PFcRW7s9rMbf8Aeqj7gQGG7cpUdz+1j/yaz8ZP+xM8Q/8Apunr5s+Amt/8LE+Jvhvx98Y9N8Wz+P47W5j0u0uPCer6P4a8NrcQFriK3mubZEaZo08lrq4lLS8JGsYcIfpP9rH/AJNZ+Mn/AGJniH/03T0Ad/8ACb/klfg3/sC6d/6TR182aZ+2HD4h+Gfw/wBe8LeE21f4gfEtGk0rwtDejKQwzNHPdXV55OILSFV3PM0JyxCIrMa+k/hN/wAkr8G/9gXTv/SaOvy2+BfwF+IH7O/wl8BftJeCtF13U/GdrBLa+MPDd2s8l9f6HNcHEFlaSAGKew2rNbxIqmQGRSWZxkA+/wD47ftF+H/gNYeFo9esH1PXPFepWOnwWFpJny1ubmG2mupJCny28DzxqXKDc7xpgFxj6Kr8u/2ivg9+0DrVr4q+I/hxtL8SL4p1nwm1hBJpuonVrDSbHV7K4gtVhDDy4opA91eZjDkeYXK7ECfprpQ1QaXZjXGhbURDH9pNuGWAz7R5hjDksE3Z2hiTjGTmgD5P+BP/ACcx+0v/ANhnw1/6j1nXW65+0v4P8HeKvifpHjtF0TRvhnZaLeS6g0xla8bWVuCkMduEDeaGhCRqrO0rOAADweS+BP8Aycx+0v8A9hnw1/6j1nXhnxD/AGVL342/tHfFrxVe3Or+HL/StP8AC114R1RDLHp0etWi3Mi3ezAiuntmVY2Ulgkc0i4DOrAA981H9oj4l6X4O8GapdfCa6bxb491G4t9N8NrqttHeRWcFtNdie8muEhhgl8qLLwBn2MwTzGbIHv3w88Q+L/FHhqPVvHHhSXwXqrySK2nTXlvfOqKcK/nWrPGd45wDkd6+GfFfiHTvip4e+HfiP8AaW+EfidJ/D9xq+n63/Z0GpSW+najFEkZm+y2KG4vtPvACYJ4RLGnAfnJHt37HmkeLdH+HGuQ67batp+gT+IdRm8LWWumY6lZ+H28sWsM4uSZ0xIJWjSYmRIiit0xQBQ+Kv8AyeT8Af8AsDeOP/Rel17J8Vfil/wrK68DW39mf2l/wmniSz8PZ87yfs32uGebz8bH8zb5GNny53Z3DGD438Vf+TyfgD/2BvHH/ovS6q/tm/DPUfi1onww8IWsGpyWMvjnTZNSm0nzUuLaw+yXiTStNEC0EfzhGlyu3eMMCQaAOq0v9pW08S6z431DwloR1L4ffD+yu31DxMbry4LjUbJGkms7CLymFysKqRNP5iIr/IocgkbPwd+LXxV+JN1b3Hi34T3ngnQr2wW9ttRudW0+8Ehk2GOIwW0jSozI5bLKANpBwSBXzdpXgvxb8GfDPxF/ZXbwdqvjT4caloeqXfhJ7EyIy2d0ji80Ce+2ssE6GRjZSyt+8Rtu7emKr/BDw/pMHx+8N6j8BPDfirwn4QttCvo/GEfiCDVLS1uLxvIGnwrHqn+uvYXEplng3LsyDIwdaAPWP2+v+TXPEP8A2FvC/wD6kGn19TeLte/4RXwnrXijyPtX9j2VzeeTu2eZ9niaTZuw23dtxnBx1wa+Wf2+v+TXPEP/AGFvC/8A6kGn19GfFGzu9Q+GXi6wsIHubq50i/iiiiUvJJI9u6qqquSzMSAAOSaAPA4f2pTr2nfDTSPAXhj/AISHx18RNJ07XZNGW98qDRtLvIkllu7+9ED+XFHv2Rfud88g2og5K43jj9sA+Dr7xLrkPgDUtV+HfgjVBpGveJYrm1RLS4Vo0neKydxPPDbPKqzOoGCG2qwViPnf4N/Bvxj+yj4U+GPxm8F6Vr2vR+JdE0TTfiHok0dxfaqrtCgtr63ttpmV9MeQ2720acWwwE3xljt+OvG7/FLxz4l8KfGTwt41074caFrLxWvh/RfB2s3EHiA2UqsL7Ub+C0cTW00yl47eAqrqFaV5N20AH6e18gfsb/8AIu/FP/spnjX/ANOstfX9fIH7G/8AyLvxT/7KZ41/9OstAHRa5+1F4O8G6z8U7XxxbHS9P+GlxpVqk0chuLjVbjVrNLqGC2tgisZ2dxFHGrOXPzZUZxDefH3x1pPhnwdb6t8N5h8RfHJupLDwtb6lC8kFraIJJZ728ljhihESPEsoVZNssqRqZCc18xeMP2VNc+Kv7QHxq+I9pdap4d8UaLd+Hb7wTqExmTSl1Kz02AtcCIgRXILx/Zpyd+yMuoAYnOb8Q/7Q+Knif4VfGr42eBfFWleG7LStb8P+KNF0+11IzWWpvNayI7xWC/abrTpZLcsk0O+NtsLN3FAH6GfCrx9dfEnwZb+JdS8P33hXURNc2l5peoBftFrdWkzwSpvQmOVCybo5UJWRCrDrgeDfFX/k8n4A/wDYG8cf+i9Lrd/ZE0rxjo/woubbxRDqlppr61qknh611x5X1S10B7gmwhujcFpw6x5KpKxkSMojnKkDC+Kv/J5PwB/7A3jj/wBF6XQB9f1+e3/BTWaG2/ZlS4uJFiii8S+H3d3IVVVb1CSSeAAOpr9Ca5nxd4K8G+P9Fk8N+PNBsPEmkSukj2epWsV5bM8ZyjGKZXQlTyCRwelAHE2X7QHwH1K8g07TviR4auru6kWKGGLWLN5JJHO1URVlJZmJAAAyTwK+IP2FPHHw78D/ALPnjnTvinq1lpXiXQ/EniOXxnHqU0aSm5e5dnlmjkO5kkg2KC2Q5BAJ6V9j6f8Asv8A7NGk39tqulfCTwjZXtlKk0E8Og6fHLFLGwZHR1gDKysAVYEEEZFXvGH7OvwF+IPiePxr45+Hmg69rsYUfbb3ToJ5mCDCB2dCXCj7u7OO1AH47/s6xN4Hh/Y38S/Fz/iS+CifGj6UdSYLbWd3qMrS6UJ5JPkDyQEtbM2Dz8uK+vbTxt8NvGf/AAU50hvAd7Z6rfaZ8P7+21S7snSWPzvtsLxwPImVaSNGywySodQcdK+m/wBo7wT8U/Fei6HbfDjSfDfirR7OeT+2vC/iWFfsWrWpjxEsc5guBDLDIAyZj2HPzH5QD5Z8AfgD4v0r4vy/Grxp4S8P/Daz03Qn8P6F4V8Ous8FrDc3C3V1dXM8cFtEZpHRUCxx7QoOSTyQD7pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1P38ooooAKKKKACiiigAooooAKKKKACiiigDx/wb8FfDXg74h+JfikdR1PXPEfiVfIa41S5+0CxsRNJcLY2ShVENsskhITknC7mbaK9goooA+QP2A/8Akzb4T/8AYGj/APRj19f1+RX7HX7c37MPw5/Zi+HXgfxh4qurLWtG0tILqFNE1e4VJA7EgSwWckT8HqjEe9fS3/Dxv9j3/odL3/wndd/+QKAPt+iviD/h43+x7/0Ol7/4Tuu//IFH/Dxv9j3/AKHS9/8ACd13/wCQKANj4D/8nR/tN/8AYW8L/wDqP2tfY9fkJ8If25P2YvD37QHx58W6v4quodL8V6joE2myromryNNHaaNb20xaNLNpItsqMoEiqWA3KCpBP05/w8b/AGPf+h0vf/Cd13/5AoA+36K+IP8Ah43+x7/0Ol7/AOE7rv8A8gUf8PG/2Pf+h0vf/Cd13/5AoA6D9q//AJGL9n3/ALKZpv8A6atUr6/r8iv2if25v2YfGGt/Bq68PeKrq5i8N+PLHVb8tomrw+VZxafqELSKJbNDIQ8yDZHuc5yFIDEfS3/Dxv8AY9/6HS9/8J3Xf/kCgD7for4g/wCHjf7Hv/Q6Xv8A4Tuu/wDyBR/w8b/Y9/6HS9/8J3Xf/kCgD7fr5A/YD/5M2+E//YGj/wDRj1z/APw8b/Y9/wCh0vf/AAndd/8AkCvmn9jr9ub9mH4c/sxfDrwP4w8VXVlrOjaWkF1CmiavcKkgdiQJYLOSJ+vVWI96AP11or4g/wCHjf7Hv/Q6Xv8A4Tuu/wDyBR/w8b/Y9/6HS9/8J3Xf/kCgD7fr5A+BP/JzH7S//YZ8Nf8AqPWdc/8A8PG/2Pf+h0vf/Cd13/5Ar5p+Ef7c37MPh747/HbxVq3iq6h0zxVqmhT6dINE1eRpo7XRba2lLRpZs8W2VGUCRVLAblBUgkA/XWiviD/h43+x7/0Ol7/4Tuu//IFH/Dxv9j3/AKHS9/8ACd13/wCQKAPt+vjj4uf8nm/s9f8AYJ8c/wDonTax/wDh43+x7/0Ol7/4Tuu//IFfMfxI/bk/Zi1n9qD4L+OdO8VXUui+GtO8WQ38x0TV0aKTUIrFbcLE9mJZN5ifJjVguPnK5GQD9e6K+IP+Hjf7Hv8A0Ol7/wCE7rv/AMgUf8PG/wBj3/odL3/wndd/+QKAPt+vAP2sf+TWfjJ/2JniH/03T14//wAPG/2Pf+h0vf8Awndd/wDkCvG/2iv2+P2VfGP7PvxO8I+HfFt3c6rrnhfWrG0ibQtZhWS4ubKaKJTJLZJGgZ2ALOyqOrEDJoA/QP4Tf8kr8G/9gXTv/SaOvQK/O34c/wDBQr9knR/h74Y0jUPGN5HdWOl2UEyjw/rbhZIoEVgGSxKtgg8gkHscV2f/AA8b/Y9/6HS9/wDCd13/AOQKAPt+iviD/h43+x7/ANDpe/8AhO67/wDIFH/Dxv8AY9/6HS9/8J3Xf/kCgDoPgT/ycx+0v/2GfDX/AKj1nX1/X5FfCP8Abm/Zh8PfHf47eKtW8VXUOmeKtU0KfTpBomryNNHa6LbW0paNLNni2yoygSKpYDcoKkE/S3/Dxv8AY9/6HS9/8J3Xf/kCgD7for4g/wCHjf7Hv/Q6Xv8A4Tuu/wDyBR/w8b/Y9/6HS9/8J3Xf/kCgDoPir/yeT8Af+wN44/8ARel19f1+RXxD/bm/Zh1f9p34OeONP8VXUmjeHNL8WQX0x0TV0aKS/TTxbhYmsxLJv8l8mNWC4+crlc/S3/Dxv9j3/odL3/wndd/+QKAPt+iviD/h43+x7/0Ol7/4Tuu//IFH/Dxv9j3/AKHS9/8ACd13/wCQKANj9vr/AJNc8Q/9hbwv/wCpBp9fY9fkJ+2H+3J+zF8Rf2f9a8JeEPFV1eapc6joE0cT6Jq9upjtNZsrmY+ZPZxxjbFG7AFssRtUFiAfpz/h43+x7/0Ol7/4Tuu//IFAH2/RXxB/w8b/AGPf+h0vf/Cd13/5Ao/4eN/se/8AQ6Xv/hO67/8AIFAH2/XyB+xv/wAi78U/+ymeNf8A06y1z/8Aw8b/AGPf+h0vf/Cd13/5Ar5p/Zj/AG5v2YfBGifEG18TeKrq1l1fx54p1W2CaJq8++zv9Qkmt5CYbNwpZGBKNh16MqnigD9daK+IP+Hjf7Hv/Q6Xv/hO67/8gUf8PG/2Pf8AodL3/wAJ3Xf/AJAoA+36+QPir/yeT8Af+wN44/8ARel1z/8Aw8b/AGPf+h0vf/Cd13/5Aryuy/aS+Dfx9/bL+Cy/CnWp9XOi6P4wW783Tb+x8s3UVgYsfbLeHduEL/dzjADYLLkA/TOvnH9qX48X/wCzp8LR8QdL8Or4pvJtSsNMhsXu/sKvJfSiJSZvKm24JH8H4ivo6vz0/wCCmsN5cfs3Wdvp9wLS6l8U+H1imKCQRSNeKFcoSA204O0kZ6UAS+NP2tP2hvg3or+O/jj8A/7G8EWMkK6lqekeJbXVprKKaRYhK1p9ngeRQzDO1uO9ffsF7aXNnHqMEyPayxiVJQRsMbDcGB6YI5zX5R/tYfAz9qo/BHxHrvj341af478IeHLc6vrHhyXw/FoMWrWemkXUls19a3Es6bljO0LtDNgE4PHBfFL4lT/tF/HL4X+DZvhtqnjn4f3Hw4sfGsHhCzv7XT45brUphGkt39puLaO4htIwESME4kYsAUJyAfsD4q8SWHhLwprHjDUA0llo1lcX8vl8s0VvG0rbfUlVOK8h/Zo+LHjX44fCjTvil4y8Kw+EI/EJF3pdpFfC/aTTJoo3gnlkEcQSRyzZj28AAk5JA/OHQPhTr9poXx9+HniL4a3Xgz4RXvhJ9b0zw7qurWWof2brVkjtvtYrS7uJIoZSqy4OE3x4GBwcLRPB3h22+B37InwA0SL/AIR7wl8apIdU8XG1llgOqSWukwTyW00iMGAvWCo6qRu2gcDOQD9s7a6tbyLzrOZJ48ld0bBlyDgjIzyD1qRpI0ZUdgrOcKCcEkDOB68DNfmRrnw38Efsv/tg/A7S/gPYL4X074nLr2m6/olm7izvYNOs1uYLvyGYoktu55kADMp25wWz4X+zF4E0f4f/ALLHj/8Aa0SKbWvHvhBfG03h6S4mme30qG3ku8xRW28QlXl8yWVihZgxGcKKAP2q82LzfI3jzAN23I3bemcdcVJX8/8Apnwq8T6/+zxpPxH8FfBTxKnxVv8ATLXXbf4kyeJdLS4m1GZEuDdySSaiGFtISV8p0wsZwV3gmv3Z8E3+uar4M0HU/E1ulprF5p9rNewxsrpHcyRK0qKyFlZVckAqxBHIJHNAHT0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKAPkD9gP/kzb4T/9gaP/ANGPX1/XyB+wH/yZt8J/+wNH/wCjHr6/oAKKKKAPjj4D/wDJ0f7Tf/YW8L/+o/a19j18cfAf/k6P9pv/ALC3hf8A9R+1r7HoAKKKKAPkD9q//kYv2ff+ymab/wCmrVK+v6+QP2r/APkYv2ff+ymab/6atUr6/oAKKKKACvkD9gP/AJM2+E//AGBo/wD0Y9fX9fIH7Af/ACZt8J/+wNH/AOjHoA+v6KKKACvkD4E/8nMftL/9hnw1/wCo9Z19f18gfAn/AJOY/aX/AOwz4a/9R6zoA+v6KKKACvjj4uf8nm/s9f8AYJ8c/wDonTa+x6+OPi5/yeb+z1/2CfHP/onTaAPseiiigArwD9rH/k1n4yf9iZ4h/wDTdPXv9eAftY/8ms/GT/sTPEP/AKbp6AO/+E3/ACSvwb/2BdO/9Jo69Arz/wCE3/JK/Bv/AGBdO/8ASaOvQKACiiigD5A+BP8Aycx+0v8A9hnw1/6j1nX1/XyB8Cf+TmP2l/8AsM+Gv/Ues6+v6ACiiigD5A+Kv/J5PwB/7A3jj/0XpdfX9fIHxV/5PJ+AP/YG8cf+i9Lr6/oAKKKKAPjj9vr/AJNc8Q/9hbwv/wCpBp9fY9fHH7fX/JrniH/sLeF//Ug0+vsegAooooAK+QP2N/8AkXfin/2Uzxr/AOnWWvr+vkD9jf8A5F34p/8AZTPGv/p1loA+v6KKKACvkD4q/wDJ5PwB/wCwN44/9F6XX1/XyB8Vf+TyfgD/ANgbxx/6L0ugD6/rxP4//Ajwt+0X8Pm+HPi7UtS0my+2Wt8lzpMsUN3HPZv5kRR5oplGG6/Jn0Ir2yuX8beNfCvw58J6p458b6lFpGhaLC1xd3UxOyKNe+ACSSSAqqCzEgAEkCgD4/u/2D/CviKIaZ8SPiv8RfHmgu6PcaPrPiBW0+6EbBgk8dtb27SJkDgv9Oa9V+Kn7MfhD4iah4Y8T+G9W1H4feK/Bls9lpOr6A0UE0NjIoVrOSKWOSGW24BEbp8pGVK5bPir/t5BNCb4ht8FPHqfDtI/tD6++n26qtoOTd/ZPtH2j7ME/eGTb9z5ttfbPg/xf4a8f+FtK8a+DtQj1XRNat47qzuoSSksMoypGcEHsVIBU5BAIIoA8I8C/steDfB+geN7PVNb1fxP4i+I9o9nrviDU545dSuITC8CRxlY1hhjhSRvKjSPaOMhsUniT9lD4b+Jfgx4N+DE97qlpB8PksP7A1m2uEh1iwudNjEUFzHOkYj83aMOPL2Nn7gwMfTlFAHzD8Mv2YtL8E+P1+LPjXxjrnxH8ZW1k+nWV/rkkGzT7WRt0qWlvaxQxRtLgCSQhnYDGQCQe5+E/wADPBXwh+G0/wAKtGa41fQru41GeZNTMU7S/wBqTSTTxv5ccaGMmRlClPu8Ek5J9looA+D7f9grwgmkw/Dy8+IPiy++FdtKJY/Bs19EdO2LJ5qWrziEXb2qNgrC0x6DLHFfdkMMNvClvbosUUShURQFVVUYAAHAAHQVJRQAUUVwWrfE3wTonxB0H4W6nqBh8TeJra7u9PtPJlbzoLEKZ281UMabN68OwJz8oPNAHe0VwPgrx4fGmoeJ9PPh7V9C/wCEa1OTTRLqlr9mi1Dy0V/tNk25vOtm3bVk4yQRjiu+oAKKKKACiiigAooooAKKKKACiiigD//W/fyiiigAooooAKKKKACobi4t7S3kurqRYYIVZ5JHYKiIoyWYngADkk9KmpCAQQRkGgDH8PeIvD/i3RbTxJ4U1S11rSb9PMt7yymS5tpkyRujljLI4yCMgkVD4d8V+F/GFnNqPhLWLPW7S3nltZZrG4juY0uIG2yxM0TMBIjcMpOVPBAr8yPBfxLf9kr4SftEfCkAi4+E19PfeFYMZElh4pJm0iGMdX2XsrwtgcHjHarTW/iH9lj4cfCz4Jj4q6P8MLC10R7nU7n7Gut+INT1yeUS3C2tiyyZt/MeV3n2SNnag2/eAB+mes+I/D3h37D/AMJBqlrpn9p3UVjafap0h+0Xc2fKgi3kb5XwdqLlmwcDitmvyKb4xeKfjV8Kvg7r3jGWO71TRPjfYaI13HZyad9rj0+e5jinezm/eW8joV3xNgq2QQDwPpDw78cPiFf/AAO/aN8cXl9EdV+HWteNLPR5fIjCwQaLAZLQOuNsmwjJLglu+aAPuWivyu8bftceJbrxH4C+Gc3j+3+Gpu/BOmeJ9a1/+yBqtxcXuoqFis7a22vFEp2ySyOyHjaibeTX1H+yJ8bNf+NPgbX5PFE8Opaj4U1u60f+1bW1lsrfVreJI5be+jt5fmi82OQB0yQrq2OMCgDO/YD/AOTNvhP/ANgaP/0Y9fX9fIH7Af8AyZt8J/8AsDR/+jHr6l0LxJ4d8U6d/bHhnVbXV7ASTQ/aLOeO4h823dopU3xll3RurI4zlWBBwQRQBtUVzWneNPB2seHLbxhpOu2F7oN7s8jUILqKWzm8yQRJ5c6sY23SEIuGOWOBzxXS0AfHHwH/AOTo/wBpv/sLeF//AFH7Wvsevjj4D/8AJ0f7Tf8A2FvC/wD6j9rX1dH4j8PS+IJvCcWqWr65b2yXktgJ0N2lrK7RpM0Od4jZ0ZVcjaSpAOQaANmiubPjLwgt7rGmtrliLvw9HDLqcJuYvMsY7hS8T3KbswrIqsyFwAwBIyAat6D4j8PeKtNj1nwvqlrrGnykhLiznS4hYrwQJIyynHfmgD5Z/av/AORi/Z9/7KZpv/pq1Svr+vkD9q//AJGL9n3/ALKZpv8A6atUr6m1zxH4e8M28F34k1S10mC6uIbSGS7nSBJLm4cRwwo0hUNJI5Cog+ZicAE0AbNFYur+JPDvh6TT4df1S102TV7pLKyW5nSE3V1IrOkEIcjzJWVGIRcsQpIGAaj07xT4Y1fU73RNJ1ezvdR007bq2guI5Jrc9MSxqxZD/vAUAb1fIH7Af/Jm3wn/AOwNH/6Mevr+vj79gZ1j/Y0+FDuQqroqEk8AAO/JoA+waK5zT/GHhLVvDC+N9K1uxvPDr27Xa6nDcxSWRt0BZphcKxjMagEl92AAcmpD4r8LDw7B4vOs2Q0G6ihni1D7RH9kkhuNvkyJPu8tkk3LsYNhsjBORQBv18gfAn/k5j9pf/sM+Gv/AFHrOvr+vkD4E/8AJzH7S/8A2GfDX/qPWdAH1/RWNbeI/D17rl74Ys9UtZ9Y0yKGa7so50a5t4rjd5LyxAl0WTY2wsAG2nGcGsm5+IPgKym1a3vPEumQS6DJDDqKSXkKtZSXKCSFLgFwYmkQhkD4LKQRkGgDr6+OPi5/yeb+z1/2CfHP/onTa+rNB8TeG/FNq994Y1W01e2icxvLZzx3CK4AJUtGzANgg464Ir5T+Ln/ACeb+z1/2CfHP/onTaAPseisbVvEfh7QJ9Ottd1S106bWLkWdklzOkLXV0ys4hhDkGSQojMEXLYUnGAaS/8AEnh3S9W0zQNT1S1tNT1szLYWs06Rz3bW6eZKII2IaUxp8z7Adq8nA5oA2q8A/ax/5NZ+Mn/YmeIf/TdPXr+neLPC2sate6DpOs2V7qemY+12sFxHJPb56ebGrFkz/tAV5B+1j/yaz8ZP+xM8Q/8ApunoA7/4Tf8AJK/Bv/YF07/0mjr0CvOPhhdW1l8IvCV7eypb29vodhJJJIwRERLVCzMxwAABkk8AV0ieMPCUnhT/AITtNbsW8NfZDqH9qC5iNj9jCeYbj7Ru8rydnzeZu27ec45oA6OivPZfi58KIGCTeNNFjZlVwG1G2BKuoZWGZOjKQQe4IIru7W6tb61hvbKZLi3uEWSKWNg6OjjKsrDIIIOQRwRQB8j/AAJ/5OY/aX/7DPhr/wBR6zr6/r5A+BP/ACcx+0v/ANhnw1/6j1nX1Np3iPw9q+pano2k6pa3uoaLJHFf28E6STWkksYljSdFJaJnjYOocAlSCOCDQBs0VxsvxF+H0Gn6pq8/ifS47HQ7t7DULhr2ARWd4m0tb3Dl9sUq71yjkMNwyORXT2GoWGq2UGpaXcxXlncoJIpoXWSORGGQyOpIYEdCDigD5L+Kv/J5PwB/7A3jj/0XpdfX9fIHxV/5PJ+AP/YG8cf+i9Lr6m1HxH4e0fUNM0jV9UtbG+1qV4bC3nnSKW7ljQyukCMQ0jLGrOwQEhQSeATQBs0Vi3fiTw7p+taf4av9UtbbV9XSeSys5Z0S5uktgpmaGJiHkEQdS5UELuGcZFR6F4q8MeKFuH8M6xZ6utpIYpjZ3EdwIpB1R/LZtrex5oA+Vv2+v+TXPEP/AGFvC/8A6kGn19j18cft9f8AJrniH/sLeF//AFINPr7HoA42X4g+EYfiBB8LZr/Z4nutNk1eG0aKUCSyhmWCSRZSnlEpI6hkD7wGDFdpBpNL+IPhDWvG2u/DrS7/AO0eIPDMFnc6jbrFLtto78ObfdKUERaQRsQgcsAMkAEE/O/7VEaeCb/4c/tEoREvw51yOHVZScKNB13bp98zf7MLvBcnsBCTVj9kPT5ta8F+IPjjqcbLqPxd1m68QIZBiRNK4tdIiJPOBYwxOPeRqAPrOvkD9jf/AJF34p/9lM8a/wDp1lr6/r5A/Y3/AORd+Kf/AGUzxr/6dZaAPo3x18QfCPw00WHxF43v/wCzNNmvLSwFwYpZUW4vplt4A5iR/LV5XVd74RSRuYDmk8VfEHwh4K1Lw5o/iW/+y33i2/GmaXCsUsz3F15Uk5UCJH2KscTs0j7UUD5mGRnE+NPw1sPjD8J/Fnwx1FhFH4j06e0SXnME7LmCYY/iilCyL7qK+Lf2cvG2o/tM/Frwv8QvEMRWT4QeFhp2oRMMeV4x1Zzb6mnH8VtDaFeeguPegD9IK+QPir/yeT8Af+wN44/9F6XX1/XyB8Vf+TyfgD/2BvHH/ovS6APr+vz1/wCCj0KX/wAM/hpoWqkDw1rHxG8M2muq5/dvpjyyGRZB0ZPMWMkHjgGv0KrzT4w/CXwb8cvhxrfwu8fWzXOja7D5UhjIWaF1IaOaFiGCyxOA6EgjIGQRkEA9BuraynsprS9ije0kjZJI5FBjMZGGVgeCpHBB4xX5heKfFfhHxjrPwJ/Zl/ZY8RN4U+GPjY69qF7qfhuZrSf7Bo5Z3tbCdhuj867ZxK8ZDKAdp2lge/m/Zf8A2sdW8OSfC7xF+0ZJc+CZovsk1xDoMEXiCexPytbtfmZgshj+U3GxnJySOa7/AMdfsfaBL4a+GcHwT1f/AIV94k+DpkXw3qAtlvolguYvJu4LuB2Tzkul5kber7yXBySCAeS6VD4m/Zs/ai8NfBjQfF+t+JfBPxJ8Pazdx2euX8mp3OlahpCLL5tvczEzJDLG23y2YrvywOa+NdNsfjTb/wDBPDTf2vbz4y+MZfHuh2639jGdUdtO+zx6l9m8i6t2Dfa/Mjy7vMzNuIXPlrtP6Y/Dr9nDxlF8Tbz44fHLxjb+MPGp0iTRNNWw04adpulWUzeZN5MLSzSSSyP96V3B25QDFYR/Y6z+xR/wx5/wl3/Lh9h/tv7B/wBPn2vf9k+0f8Ax53vntQB4T4g8K/EH9nv4rfAXxmnxR8U+K7z4ja8ui+JLPVtQM+mXX261km8y3sgqw2ohlUmJYlG1cLn7xar8Gvhn46/aM8cfHr/hO/it4w07w94Z8e6tpei2WjaxNYNaNGsTs3mpmRo41aIQQkiGMh2CEucfanxY+A//AAs/V/hXqn9uf2Z/wrPXrfW9n2bzvtv2eB4fJz5qeVu3534fGMbT1r4M/Z++G/x017x1+0Z4l+CvxLt/Bz3fxJ1zT7u01HSU1W2/cpBJHdW/72Fop185gwbekgCAqNuSAdB4Y+MnjnUv2Q/E2m/Ev4rDwXrfgvxje+DLvxabcyX1/Bpl2qk2kUSuXvZ4MxoyK7ZBfBbJrlfhh8RL7wx+1r8I/CPw31L4k/8ACGePYtfh1SLx4L1rW8kstPa8hn0/+0v36uHTMrKqoQwA6sK+ktd/Yf07/hRHhH4X+C/F1zpfijwT4hg8X2niG6gW7e61+OSSWW5u7dmAdJWlf5A/yjby20hmXn7K3xp8SfFH4efHLxv8WoNS8YeAbyc29tDoiwaOmn38Bt72CKAXBmE8qMf9IeZgNqYiAXkA8O+D/wAOvHn7Z/w88SftAa38UfFPhbW9Y1TVYfCtro2qy2OnaNbafO9vaiS1iAWd2eMmdpBukXgbeDVbxd8IfE95+2j+z8vxK8YavN4puvDOpzapPpOp3NrZteaVDbKxtYhs8mG6YbriJVCykkMMV7Ne/sc/FTw3a+L/AAF8FPi2PBnw48cXt3e3emPo0d5faedR/wCPyPTrwzR+XHLk7N0ZMPVSWya77X/2Tp7DxN8GfEvwh8Ujwo/wisp9IWK7shqS6hpd0kMcschMsJSYiInzRnLMSRxigD468T/Hv4v+G/DPxt0bwz4juhr+v/GC28E6FeXcrXCaNBqUcGTAsxZI0jUSbF4VWbd1HPqHxV8F+IP2Pdd+FvxE8B/EHxT4htPEHizS/DPiDTPEWrzatBqNtq2+NrmNJ8mO6iZQ6mHaCMgjaCD65rX7Enh/xN4S+LHhbX/Es7P8R/FX/CW2N5bWwguNFv41i+zmMtJIJjG0XLEJuVmXCn5ql0/9mj4veOfG3gzxL+0j8SLLxjpfw9vl1XS9M0vRl0uK41SFSlvfXrtPOWeEMzJHGEUMc5IypAPC/hV8NvHP7RHxL+Pdp42+Kvi/TPDXhjxpe6fpNho2rzWBt5PJhdm85cyGKMbPJgBEKNvbYzNkfR/7CPjzxj8Qf2bNC1Dx9qkuua9pN7qukXGoTnMt0NOvpreKSQ9S5iVAzHLMQWYkkmvTfgz8Ff8AhUeufEnWv7Z/tb/hYXiW48Q+X9n8j7H9ohii8jPmSebt8rO/CZzjaMZLP2cvgn/wz/8ADc/D7+2f7ezqepaj9p+z/Zf+QhdPc+X5fmS/c37d275sZwOlAHvFFFFABRRRQAUUUUAFFFFAH//X/fyiiigAooooAKKKKACiiigD5D+Mn7JGifF746eBPjPc69JpsXhfyV1TS1txLFrUdjci909JZPMURi2ud0nKSbwdvy9Tf+IPwB8eX/xwHx4+E/jSy8M65e6FH4dv49T0j+1ojZxXD3KS2225tnilDvypZo3wCy5HP1bRQB8HeFf2Mdb8PaVYeH7/AOIDavZaV8Q7f4gQz3Gmr9unnBkkure5kjnSJjNLIWWVIkCDI8tsjEXi79j34gaxa/FLwT4U+KI8PeAfive32p6hYf2MlzfwXepRLHdJDeNcIv2eZly6GHftLKrqWL197UUAfGd9+zJ408L634R8ffBnxnaaJ4v8P+F7Twlfvqemve6dqun2e1one3juYZIZo5Azo6ytwxRsjmvevhF4A8Q/DzwvPp3i7xbfeNdc1K9uNQvdQvCUTzrgjMVpb73W1tYwoWKBGKryclmYn1KigD5A/YD/AOTNvhP/ANgaP/0Y9fOfxG8Q6z8Ebz47/Azws/kar8Trix1Xwavf7Z4wlGlX+wjgfZbxWu2H8KyZPv8ARn7Af/Jm3wn/AOwNH/6MevePE/wj+HPjPxz4U+JPibRY77xJ4Ia6bR7tnkU2pvEEc3yKwjkyoG3zFbYRuTa3NAHxh+1f8FtC8IfArwBaaBq+q2OmfD/V/Bum2em2915Wn3KJrFjbLJdwKv751U7lJbAfDYyM1+i1cl428DeFviLoY8NeMbL+0NNF1Z3vleZJF/pFhcR3Vu+6Jkb5JokbGcNjDAqSD1tAHxx8B/8Ak6P9pv8A7C3hf/1H7WpvjuIfhr8cPhT8ei622nzzz+C9elJ2qLLWcSWEkjHgLDqEMSZPTz2qH4D/APJ0f7Tf/YW8L/8AqP2tfSPxG+HPgv4teCtU+HfxD0xdY8Payix3dq0kkQkVHWRMPEySKVdVYMrAggEGgD89fDfhz4b+KvgVqfx8+Ol3NbaT8TPGUHixrEQG5k1WwhkFr4f0lrYI73KywRW8iwIhLu2Mbc175+y98M9a8L+LfiX8Sn8KR/Dvw749udNm0vwyoijlthZQPFNe3MNsTBBcXhZS8UZJURr5hMhbHs/jr4E/C/4jeEtB8D+KNLmOjeF57e50yGxv73TXtZbSF7eFo5rKeCX5I3ZQC5HOcZAIvfDf4P8Agn4Uf2j/AMId/af/ABNPJ8/+0tZ1PV/9Rv2eX/aNzceV99t3l7d3G7O1cAHh/wC1f/yMX7Pv/ZTNN/8ATVqlesftD/DF/jH8FfFvw8tZPI1HU7Jn06bODBqNswuLKUHt5dxHG34V5P8AtX/8jF+z7/2UzTf/AE1apX1/QB+cHgD4jWX7TnxR8AfEK/mGnaL8MPBra/qrHCrZ+I9cR7MxSeYCoexgt7snIO0yKTXGr8O/BXwj+MH7O154P8NWNv4EjuzZ6b42sLmG81fxBeatpM/lpqXlxQfubpi87zq04eRUIWIMSv6DeAvg98Nfhh/wko8C6FDpY8YalcavqoDSSi5vbrHmuRKzhVbHEabY1ydqjJzwHgz9lX4K+AvEml+J9A0u9abQDKdItbzVb+9sNJ85Sr/YLK5nkt7bKsVHlxjapKrtU4oA+iq+QP2A/wDkzb4T/wDYGj/9GPX1/XyB+wH/AMmbfCf/ALA0f/ox6APlPxEL7wz4Q8ffsLaRK1reeJ/GVvpmiiM4MXhXxWZNUvHQdSltDDqUGeg2KM8jPPftxfELwzrNhr/wyvJ7zw94Z+F/9j/YLGKyvFj1XVDPbMHMscRi+x2FsxEalx5lwxOP3Kbv1F1D4R/DnVPihpfxnv8ARY5vGmi2EumWmol5A8VpMzM8YQOIzy7YYoWUMwBAYg7vjbwT4Y+Ivhm88HeMrL+0NIvzEZ4PMki3mGRZk+eJkcYdFPDDOMHjIoA1dC1vTfEmjWPiDRpGmsdRhS4gdo3iZo5BuUlJFV1JB6MoI7ivlX4E/wDJzH7S/wD2GfDX/qPWdfX9fIHwJ/5OY/aX/wCwz4a/9R6zoAp/Gi7sPg/+0R8PfjtqEy2Wg+IbO98G6/O/+rjVlbUdLmfHTZNDNDuP/PcDvXznpHwp8WfEf4H+DPEX9n6Fd+Ifiz45fx1qemeJpdtrPYT29xJZWph2SPcfZrZbPMAXoj5KjLD9F/ih8LPAXxo8E3/w6+JmkrrXh7UzE09s0ssO5oJFljKyQPHIhV0ByrA9jwSKrePfhF8P/iVoOneHfFemF7bRZ4rrTpLSeaxubC4gUpHLa3Fq8U0DorFQY3HBx04oA8W/Zd1u0tbrx/8ACa48D6D4I1/wLqltHqMfhiFYdJvv7QtI7m3uo1EcTrI0JVJEkDMu0fOykYyvi5/yeb+z1/2CfHP/AKJ02voP4a/CrwN8JNGudE8DWMlrFf3L3t5PcXM97d3d1IArz3NzcvJNNIQqjc7nCgKMAAD58+Ln/J5v7PX/AGCfHP8A6J02gDs/2tfBOr+MfghrF94Uj8zxT4OltvE+h4GW/tHRZRdxIvvMqNCfaQ18reIPiUfitrPxP/ac8ByNcaV8KfhtPH4ckXDgazrWnDWLqVD0EkVsLKMjkgs4PPFfp7XmXw2+DXwx+EPhG48B/DvQINI0C7nuLmazDSTRyS3Z/fFvOaQkMPl252hQFUBQBQB+fPwA0OP4d+P/AIET+JPh3oGiHxlol5a6Hquh3ssmqAnT/wC0Jo9aLQxreefHGZTKruEuM4yGEjfan7WP/JrPxk/7EzxD/wCm6epPh5+zP8Hfhd4hg8T+EdKuUvbCCS008XmpXt/BpltMQZILCC6mlitI2IGVhVePl+7gVH+1j/yaz8ZP+xM8Q/8ApunoA774UKr/AAq8HI4DK2i6eCDyCDbJX5nTWs8PgW8/4J/xOy3E3jtdEiRSfMXwTc58QNKG6bVsxJY5/vAL1r9MvhN/ySvwb/2BdO/9Jo6gf4R/Dl/iqnxtfRYz42j0s6Muo75NwsTL53l+Xu8rO8n95s8zaSu7acUAfJv7SXwZ+C/jfxf4a+EOmfD/AMOHxX8SJp5tU1c6RZvf2Wg6cqG+uUuDEZEnk3w2kEmco8wdTmOvufRtH0vw9pFjoGiWyWWnaZBFa20EQ2xxQQqEjRR2VVAAHoKxP+EF8LHx2PiWbLPiQaadIF0ZZDtsTN9oMSxbvKGZAGZgm84ALEKAOtoA+QPgT/ycx+0v/wBhnw1/6j1nXH/FnxfpP7M/7Q9/8YdZPk+GPiB4TvU1AA7Q2s+FIpL215P8dxYvcRqByTCox0rsPgT/AMnMftL/APYZ8Nf+o9Z17x8TvhH8OfjLotj4d+Juix67p2nX9vqdvDK8kYS7tc+VJmJ0JwGYFSSrKSrAgkUAfmPqnwv8Q+HtE/Zy8E3Phyx8bfEbWr3X/F+s6Fre2LSLq7v4PO1G5vJWWYpNZTXkcdsfImJ5+UY3D6s/YTthpPwn8SeF7qyTRtV0Lxdr9tqOkWwAsNJuZbn7ULOw2swNqkU8bRkbc7idifdHv/xP+DPgH4ux6U/jC2uVv9BlefTdQ0+9udN1CyklUJIYLq0kimQSKAHUNtbA3A4GNn4dfDXwZ8KPDa+FPA1gbGwM0tzKZJpbme4ubht8s9xcTs8s0sjcs8jsx4GcACgD57+Kv/J5PwB/7A3jj/0XpdbP7YXhvU7/AODsnj3w3AbjxF8Mb+08X6ai/ekfSH825hHc+faGeHA67xWN8Vf+TyfgD/2BvHH/AKL0uvruWKKeJ4J0EkcilWVhlWUjBBB4IIoA/MbxfZ6h+0rf/HX4pfDvWIbW00jwcPBvhfUZJhb25uL+2XU9SnEzECLd51rbmXgJ5bc8Go/hDBa+H/2p/hxpvw/+Etx8JNLu/B+tW2r2s6WVu1+LGSxMMhjsZphMLWWQKlzLgyeewXIDV90eCvgZ8J/h38MJfgx4Q8Ow2Xgu4iu4JdOZ5Z0livi5uFkeZ3kcPvYfMxwuFGFAAr/DP4EfDj4S3dzqXhK1vJL+5tobI3epajeapcR2dvnybWKW9mmaKBM8RxlVJALAkA0AeM/t9f8AJrniH/sLeF//AFINPr7Hr44/b6/5Nc8Q/wDYW8L/APqQafX2PQBma1omjeJNIvNA8RWFvqml6hE8FzaXUST288Ugw8ckcgKujDgqwII61YsLCx0qxttL0u2js7OzjSGCCFFjiiijUKiIigKqqoAAAwAMCvirwXp/jzRv25PENn4t8XzeJLK98ELeWNsbaO0g0+F9WZBCiRk+YwC/NK/zt04AAHzno0epyfB7wT+2Hp+q6jP8QvEHjWwF2TfXBgn0vVNe/so6QtmZDbiGK3lVUXZuWRPMDb8kgH62V8gfsb/8i78U/wDspnjX/wBOstfX9fIH7G//ACLvxT/7KZ41/wDTrLQB9f1g6F4V8L+F21F/DOj2ekNrF3LqF6bO3jtzdXk2BLcTeWq+ZM+0bpGyzYGTxXx7+3vp/jw/A6+1/wAK+L5vD+m6Xcacb+ygto3fUEl1G1jVDcsRJCq7iW8sZcfKTtyCfthad48j1T4U+INI8Xzab4cj8d+ELa80aG2jxeyS6vEN8l1nzAgBX90BtJXJz0AB9wV8gfFX/k8n4A/9gbxx/wCi9Lr6/r5A+Kv/ACeT8Af+wN44/wDRel0AfX9FFFABRRRQAUUUUAFVLWwsbEztY20dubmRppTGgTzJWxl2wBuY4GSeTVuigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigD5A/YD/5M2+E//YGj/wDRj19f18gfsB/8mbfCf/sDR/8Aox6+v6ACiiigD44+A/8AydH+03/2FvC//qP2tfY9fHHwH/5Oj/ab/wCwt4X/APUfta+x6ACiiigD5A/av/5GL9n3/spmm/8Apq1Svr+vkD9q/wD5GL9n3/spmm/+mrVK+v6ACiiigAr5A/YD/wCTNvhP/wBgaP8A9GPX1/XyB+wH/wAmbfCf/sDR/wDox6APr+iiigAr5A+BP/JzH7S//YZ8Nf8AqPWdfX9fIHwJ/wCTmP2l/wDsM+Gv/Ues6APr+iiigAr44+Ln/J5v7PX/AGCfHP8A6J02vsevjj4uf8nm/s9f9gnxz/6J02gD7HooooAK8A/ax/5NZ+Mn/YmeIf8A03T17/XgH7WP/JrPxk/7EzxD/wCm6egDv/hN/wAkr8G/9gXTv/SaOvQK8/8AhN/ySvwb/wBgXTv/AEmjr0CgAooooA+QPgT/AMnMftL/APYZ8Nf+o9Z19f18gfAn/k5j9pf/ALDPhr/1HrOvr+gAooooA+QPir/yeT8Af+wN44/9F6XX1/XyB8Vf+TyfgD/2BvHH/ovS6+v6ACiiigD44/b6/wCTXPEP/YW8L/8AqQafX2PXxx+31/ya54h/7C3hf/1INPr7HoA88X4aaEvxYf4xCe5/tp9EXQTDuT7L9lS5a6D7dm/zN7EZ37dvG3PNeP6R+yn4S0bxJZ3kHiTWpPCel61J4isfCzy239kWuqySPP5yFbcXZjSd2njga4MSSncEwFA+o6KACvkD9jf/AJF34p/9lM8a/wDp1lr6/r5A/Y3/AORd+Kf/AGUzxr/6dZaAPfPit8NNC+MHgPUfh54lnubbTtTa2eWS0ZEnBtbiO5Ta0iSKMvEAcqeM4wcEHxH+GmhfE+x0PT9fnubePQNb0vXoDbMiM11pNyl1Cj70cGNnQBwAGK5AZTzXodFABXyB8Vf+TyfgD/2BvHH/AKL0uvr+vkD4q/8AJ5PwB/7A3jj/ANF6XQB9f0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigD5A/YD/5M2+E//YGj/wDRj19f18VaH+wx8PPC2k23h/wp49+IWh6RYr5dtY2Pi/Ure1t48khIokkCoozwAK1v+GN/Dv8A0VL4mf8Aha6r/wDHaAPr+ivkD/hjfw7/ANFS+Jn/AIWuq/8Ax2j/AIY38O/9FS+Jn/ha6r/8doAr/Af/AJOj/ab/AOwt4X/9R+1r7Hr4j079hL4faRq+ra9pvxC+IlrqOuvDJfXEXi7UI5rl4IlhiM0iOHlKRqFUyFiqgKCFAA3f+GN/Dv8A0VL4mf8Aha6r/wDHaAPr+ivkD/hjfw7/ANFS+Jn/AIWuq/8Ax2j/AIY38O/9FS+Jn/ha6r/8doAP2r/+Ri/Z9/7KZpv/AKatUr6/r4k1n9hP4f8AiGXTJ9b+IfxEvn0e7W+szceL9QmNvdIjxrNEZHYxyBZHAdNrAMQDgkHc/wCGN/Dv/RUviZ/4Wuq//HaAPr+ivkD/AIY38O/9FS+Jn/ha6r/8do/4Y38O/wDRUviZ/wCFrqv/AMdoA+v6+QP2A/8Akzb4T/8AYGj/APRj0f8ADG/h3/oqXxM/8LXVf/jtYfhv9hP4f+ENCsvDPhj4h/ETStL06MRW9raeL9QtoIkHO1IoXSNBnsqge1AH23RX56fGT9n3wx8JPhf4k+Ir/ET4papJoto0lvZ2/jLV5Jbq6ciO3gRUkJzLMyJnHGcngVofC/8AYx1uD4e+H1+KXxc+I134ue0ik1RrXxjqcVut3IN8kcSiY/JETsU5JYKGPJNAH33XyB8Cf+TmP2l/+wz4a/8AUes6P+GN/Dv/AEVL4mf+Frqv/wAdrD079hP4f6Tq2ra5pvxD+IltqGuSRS31xF4v1COa5eCJYY2mkRw8pSNVRTIWKqAoIUAAA+26K+QP+GN/Dv8A0VL4mf8Aha6r/wDHa+d/E37Ous6n+0J4a+Engj4mfEy20XTNPk13xRqEvi7VnX7PKz29hY27tLsEs8ySSSHBKxRHGCwNAH6j18cfFz/k839nr/sE+Of/AETptWP+GN/Dv/RUviZ/4Wuq/wDx2sK9/YS+H2o67pnie++IXxEuNV0ZLiOzupPF2oPPbpdhBMIpWcyRiQRqHCMA+BuBwMAH25RXyB/wxv4d/wCipfEz/wALXVf/AI7R/wAMb+Hf+ipfEz/wtdV/+O0AfX9eAftY/wDJrPxk/wCxM8Q/+m6evP8A/hjfw7/0VL4mf+Frqv8A8drM1r9h/wAE+IdHvvD+t/Ej4j32nanBLa3NvP4x1KaGaGZCkkckcjsjoykhlZSpBwQRxQB9JfCb/klfg3/sC6d/6TR16BXxvZ/sV+E9Ps4LCx+JvxKt7a2jWKKOPxnqaIiINqqqrIAoAGAAAAOleKfG39l3x7p1vonhL4KeNfiTea/4lneJ9XvvGeqtpeiWsQVpbq5RZ0eWQhtsEKkeY+SzBVOQD9M6K+MNK/Yu0my021tNR+L/AMTtQuoY1WW5fxlqUbTOB8zlEkCrk84AwK0P+GN/Dv8A0VL4mf8Aha6r/wDHaAD4E/8AJzH7S/8A2GfDX/qPWdfX9fEmnfsJ/D/SdV1bXNN+IfxEttQ1ySKW+uIvF+oRzXLwRLDG00iOHlKRqEUyFiqgKCFAA3P+GN/Dv/RUviZ/4Wuq/wDx2gD6/or5A/4Y38O/9FS+Jn/ha6r/APHaP+GN/Dv/AEVL4mf+Frqv/wAdoAPir/yeT8Af+wN44/8ARel19f18SXn7Cfw/1DXdN8TXvxD+Ik+q6RHcRWd1J4v1B57dLvYJlilZzJGJBGm8IwDbRuBwMa//AAx74X877P8A8LW+Jfm7d2z/AITbVN23OM483OM96APsSivzF+Hv7Gnxh8QeK9R8S/E34reOvCvhyKSSLTdA0/xpqd7eSRq21bi/v3l2BnA3LDbxrtBG6RiCK97/AOGN/Dv/AEVL4mf+Frqv/wAdoAr/ALfX/JrniH/sLeF//Ug0+vseviPxH+wl8PvF+kSaD4m+IXxE1XTpnhke3u/F2oXMLPbyrNETHM7oSkiKykjKsAykMARsS/se+F4FDzfFb4lxqWVQW8baoBuYhVHMvUkgAdzQB9iUV+ZXxB/Y4+L2teOdM8MfDf4o+OPDfhJYUuNT8QXvjTVb29di7A2djYiZEV9qgtPOzIA+FjYqa9wg/Yz8PwwRxSfFf4nzsihTI/jXUwzkDBYhZFXJ6nAA9AKAPsWvkD9jf/kXfin/ANlM8a/+nWWj/hjfw7/0VL4mf+Frqv8A8drD0L9hP4f+GYryDQPiH8RNPS/u7i+uBbeL9QgEt1dOZJpnETqHkkYku7ZZjyxJ5oA+26K/Pb4m/so+JbLwdJc/Brx3498Q+IrqWOC3XUPiBqttYwLIdr3M7pIzvHF1aOMb3+6pHUangD9iHU9H8OQQfEL44/EjxFrr/Pcz23irUrK1Vj/BBCJncRr0Bkkdj1J5wAD71r5A+Kv/ACeT8Af+wN44/wDRel0f8Mb+Hf8AoqXxM/8AC11X/wCO103gH9lfwP4C8e6d8SW8SeKvFOt6RbXVrZP4h1681aO1jvdgn8lLlmCGQRoGI64GegwAfTNFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKK53xR4t8M+CtKGueLdTg0mwM8FsJrhwiGa6lWGGME9WeR1VR3JoA828N/F/8A4S342+K/hRoWl/aNN8FWFnJqerebhY9UviZIrBItvzMtsBNI4f5N6KVycj2uuB+H/wANPCfwytNZtfCsDxnxBqt7rV/LNI0ss97fyb5Xd2ySANqIOioqqOld9QAUUUUAed/Fr4meHvg58N/EPxN8Usf7O8P2r3DIn+snk+7FBGO8k0hWNB3ZgK2fAmqeJtc8FaFrXjPSk0LXr+xt577T0lMy2lxLGGkh8wqu7y2JUnHUd+ta1jruiancz2Wm6hb3dxanE0cUqSPGfR1Ukr+NatABRRRQAUUUUAFFFFAHzp8ePGfxZtZNI+GXwQ0aSTxT4rE2deurdn0jQbOLaJrudj8stwN4FvbA5kb5mwinPtvhbR73w/4a0rQtR1S41y70+1ht5b+72C4u5IkCtNL5aqm9yNzbVAyeBW9RQAUU1XVxuQhh6jmnUAFFFFABTJJI4o2llYIiAszMcAAckknoBXkXxe+Ovw7+CWmWt34zvZJdR1R/J0zSLGJrvVdTn7Q2dpH+8lYnAJ4RcguyjmqXxL+Efh79oDw1oWneOZtY07QdyXl9ocVyLNL8PGCLTUvJ3O8cbHLRRzBGYfMXUCgDSTxxb/Fr4fa3qPwC8V6Zc3wknsLXVTGb+xgvIWCyErG8Ym8vPG19pbHJGRXPfBv9n7w78JrzUfFl/ql74w8d6/Giat4j1V/MvLpVO4QxIuI7a2Rv9XBCqooxncRmvZ9D0LRfDOkWnh/w5YQaXpmnxrDb2trEsMEMa8KkcaAKqjsAMVq0AFFYviPxJ4f8IaHe+JvFepW+kaRp0Zmubu7lWGCGNerPI5CqPqa8q8DfEfRP2ifh7repeCG1zw9pF/8AaLCw1l7YWM9xG8QA1DTRcK7GMF/3UksQBZSQhXBIB3SfEfwJJ49b4XQ67aS+LUsm1B9MSQPcx2isiebIi52KWdQu7G7OVyAceIR/s6XvjL4mH4lfHTxI/jCPRdQa68NaFDGbTRtJWJ8208luHY3d6owTPMxVGJ8tFwCPSvhH8Efh18EdFn0jwJpxjnv5PP1DUbqRrnUtSuTktPeXUmZJpGJJyxwuSFCjivWqACiivENE/aC+H3iv4qXPwj8FtdeJNT0tJG1W90+HztM0qRBlYLu73CNZ5DkLCm9wQd6qBmgDuvHXxH8CfDLS4Na8f67aaFZ3VxFaQPdSBDNcTMFjiiX70jsTwqgnGTjAJrzX4yfCXxt8X9Q07w7/AMJvc+F/APlP/a9lpKGDVNTct8sB1Ddut7YrxIIkEj8rvAPFvTP2evAFv8Vr740+IDd+KPFUzkafPq0ouYtGgIAMGmQhVjtlOMs4UysSd0hBxXulAHM+DfBvhf4e+F9N8FeCtNh0fQ9HhEFpaQDbHFGvOBnJJJJJJJLEkkkkmumoooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//T/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr54+Jnwo8RfE74vfDzVNYmtx4B8DyT63JabmM95ryARaeXTbtENqryzA78mXZ8uFzXbfGr4m2fwb+FfiP4k3lrJqB0W23W9pEpaS6u5mWG1t0CgndNO8cY44LZqH4G+HvHvhf4UeHdK+KWsSa74vMDXOq3UhDD7ZdSNPLDHjjyoGkMUQHSNFoA9XooooAK/Pb9ra8134p/Gv4Ufsj2Oq3Wi+G/G0epav4omsZWgubnS9Nj+WyWRMFY7mQlZSCDjA6ZB/Qmvhr9q/wP8AEbSPiB8NP2oPhNoUvizVvhrJf2uqaFbbRdajo+qRiOc227709uV3xxjlyTjJABAMX4h/8E+vhEnh201D9nKxg+FHxC0CaG40fXtP87dG0bgvFdL5n+kRSplHWTdnPORlT6f8VP2hfFfg3xx4b+Bvw48JxePPifrWlvq1zam9XTdOsLCFhC95cTukrhHnOyKNY2ZiDkrxnwr4i/tO/FH47+Fn+Fv7MHgLxj4c8X69JFbz69r2kSaRY+H7fzFNxNLLPkPOsYISKPLEncpJXaZvHVp4m/Zy/at0z4765o2s+MPA+veCoPC+o6lptlJqd9YahYXPnpPcQwBpRBcJncyKw8z72OMgHeWH7Yup6b4T+LEPxG8Cv4b+Ifwj0aTXL3Qv7QS4tr+y8l5YZrS/SLmOQptYmHMbEAgmvNtW/b58feFvDHgv4qeLfgfqdp8OvHbWttp19b6pbXOpvd3sJktV/s7Yh8u4KkRO0qkrhmVCyofM/F3hP4hfHOT9pP8AaD07whrOl6TrXw8m8IeF9OvbCW31XVSkcs80wsSPPAaYhIAybpAeAMYr1f43eBPGeqfs2/s5+H9J8Pahd6hoXiXwHNf2kFpLJNZwWaKLh541UtEkOP3jOAE/ixQB6x8M/wBpj4j6r8Z7P4JfG34Yn4eavr+lT6xo0sWrwavFcxWrqs8ErQxxiOeMMGIUupGecYLeO+DP25PjP8UPhpdfFz4a/Aa41Xw7ocl7HqjS67DBO5sZHEo06I2xa62xBXJIjzIWhTcylq9V+JvhXxRf/tw/BTxbYaPeXOh6VoXiaG8v47eR7S2lnjhESTTBSkbSEHYGYFsHGa+Kf2Ov2l9R+GH7Jdv4Ob4Z+J9e1mS610eH20rSZb6x1dp9Qudoe6iDRwtHOXjlWbaVjQOAwYCgD731n9qObWvB/wANvEHwM8GXnj69+KUMtzpsTTDT7Szgt4RLO+o3ZSZLcxkiPYFYu4ZUyRzY+Ev7Seq+KfGvjP4X/F3wkPAHirwNp9tqt4F1CPUdPn0+5D4uYblY4SFUod6vGpX1ODj4K1L4bfE34EeAf2f/AIRfElfFb/CzTtFvo/E6+Cvtctx/blxL9oigu5NPH2v7KpkZF8ohWYHqMCrHwc+FCj49fE/w54b+HHiT4d+D/iz4Ek0nRL3Vre8uJHmQTRzz3880k8ltMc5SO5kWQoI/lBYLQB7y37cHxXu/Bv8AwvnQvgndX/wYExxqg1SIa1LYCbyTqEeleUSYt3Ij83eV+fIXJEPgv4q/G7V/+CgniXwp/Yhl8GP4YsZUiOvM1rBYvczeTqsdoYQhnuMKjwja6LyZGAxXF/C348fGf4T/AAA8Lfs8+HPhBr9z8ZfDVvb6DDDdaXOPDn+jyCEX8upxssLWphG8ukm5n+XjO6vYYYvFHgv/AIKAS69r3h7VL3SvG3gjT9Lt9W0+wnn02K/s7uaWaO4mUMtuNvzL5jdCozk0AcT8Kv2mPhx8Mv2bPDGp/C/4eT2+o+MfFGq6J4f8KQam1zJeamb+cTSPe3QzFCzK0sjsrLEGCgEYr2/wJ+0h4+g+Lei/BP4/+AY/AuveLrW7uvD93Y6muq6fqJsVEl1beZ5UDxTxRkPhkKsuSGB2g/BPgX4W/Fr4f/CX4HfGN/BOr39z8KfGniq71bQVspBqjaVrVzcRNd29nKEeV402yRqo3MGDLwCa+mTrOr/tU/tQfCbxv4O8M63o3gT4Tx6vqN9qmt6ZPpX2y/1G3Frb2lolyscz+XhnlYJsx8pOduQDP0L9uj4w+OvhprXxZ+HXwKl1Pw94Tk1FdXmudehtdw02SQSiwU2zPclYUWRyUjAYmJPMZSa+ydD+JutfEDwj8O/Hfwv0NNU0TxqtnfXU17ci1bT9LubfzzIUVZTLOCUjES4G4klwqk18q/sveCPGPh79h3xH4T13QL/TdduB4v2WFzayw3bm5u7xoNsLqJD5qspTA+YEEZBFe+/seaFrfhj9lv4XeHvEmn3Gk6pp+gWUNzaXcTwXEEqRgMkkUgV0YHqGAIoA9Yt/hl4AtfH938U4tCtT4uvraOyk1N033Itos7Ykds+WnJLBNoY8tkgV3VFFABXz18Yv2h9C+GGr2XgHw9pF543+Iusw+fp3hvSwDcPDuKC5upm/dWlqHBDTzEDg7Q5BFc3N45+PnxI+JLeHfh54ePgjwP4b1LytU1/X7ZjdasLaT97b6TYkqRDJt2/bJiFKtuhRsBj9RC2tluWvFiQXDosbSBRvKKSVUt1IBYkDoMn1oA8x1P4eaJ8WPCXhmL43eF9Pv9Q02S21OTTzI17Y2+pxxspKl1jE6xl2CmSPB4bbkAj1RVVVCqMAcADoBS0UAFcF8S/id4G+EHhG68cfEPVE0nSLVkQyMrPJLLIcRwwxIGkllc8IiKWY9BXn/wAZfiT8TfDd7pvgj4OeB5/FHinXI3eO+vN1toGmRIQpmv7sAkkE5W3hDSyAHG0fNXpfg3RfEtp4R0jTviNqVt4j8QWqq93ew2i2sElyGLB4oNz+WEyAvzE8ZJyTQBwHws8Y+MvjB4d1rUvHfgS48F+H9SJh0y11G4xqt1ZSIRJLeW0YH2NmzhI/NaQDJbYcA+h+BvAXgv4Z+GLPwZ8P9FtdA0SwXbDaWkYjjXPVjjlmY8szEsx5JJ5rrqKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiivMrT40fCS/sdR1K08Y6VJbaRqQ0e9cXkQ+zai1x9lW1mBbKStN8iqwBYkYyCDQBj+G/i/B4t+M3i34U6HpbXFn4JsrKTUtW80CJNRvt0kdgse35nW3CzSOH+XeilcnNey1558OPhh4W+FthrFj4YSYtr+rX2tX89xJ5s9xe38hkkd3wMhRtjQY+WNFXtk+h0AFFFcpqfjvwZonifSvBesa5Z2Ova7HLLYWU86Rz3awFRJ5KMQZCm9chcnBzjGaAPO/2gvi/J8GPh62v6Tp41vxLq13baRoGllthv9Wvn8u3h3Dog5kkPaNHPavaLY3JtojeBFuNi+YIySgfHzbSQCRnpkA4ryPTE+EPxp1/TfH+lmPX774dapqen2lyDMsVpqIX7NeBFO2OV1XMYkw4XLBGB3V7HQAUUUUAFFJkZx3rwLxJ8eLK1+MOj/BDwNpEnivxFJsutdaGYRW2gaY4JW4u5SrjzpTgQWww8gyxKIAxALOu/HbR7f4vad8EfCGmT+J/ErRrd6v9mZUtdDsX+5NfTNkLJL/yxgUNJJ97Cp81aXwC+DOj/s//AAs0r4VaDfz6nZaVNezJcXIQSsb67lu2BCALhWmKjA6AZ5r0jS/DXh3Q73U9S0XS7Wwu9anFzfTQQpFJdTqixiSZlAMjhFVQzZOAB0FbdABRRRQAU13SJGkkYIiAliTgADqSa4nxT8SvAXgrWNB8O+KtdtdO1XxRdCz0u0kk/wBIvJz/AAxRDLsB/E2Nq8biMivIfip8A9Y+Nni1bX4heLbg/DG3hjz4X05WsxqVwCS51O7RzLNb9NtvH5aHq+7HIB7frOr6/BcaSnhvSE1e3v5SLi4a6SCK1g2bhL912k3HCqqKeTklRzXT1S03TdP0fTrXSNJto7OxsYkggghQJFFFEoVERVwFVVAAA4AGKu0AFFYviPxJ4f8ACGh3vibxXqVvpGkadGZrm7u5VhghjXqzyOQqj6mvK/Gkfib40fDXSLv4JeOU8L2PiM29y2tQ2f2m5fSpo2ZvsSzFVinkymyWRH2LkhN20gA9Q13VNQtND1e78M2aa1q+nwStBY+ekHn3Kx74oHlYMIvMJUbmGFDBiCK8M+EPw++M6+JJ/ih8c/GBudavbZre38N6O7xeH9KhkZXxhsSXlyNoBuJcYyyxoqnnv/hJ8HPAnwU8NSeGvA1pKi3c7Xd9eXUz3V9qF5IAJLm7uJCXllfAyxOBwFAUAD1KgAoorz3Q/iR4P8d3Xifw/wDDzxBY6prPhlxa3vlE3ENneSIzRxzGMqGKkfOiuGGMHaaAO8e4gjljgkkVJJs7FJAZ9oydo6nA5OK+XPFfgr4/fFf4gXGmatr5+HXwz0a5jaJNDuSdd14x7XzNdgAWNqW+UxxZmcBgzqpFaHwq/Zzi8K+Kv+FtfFPxBcfEH4lyxPENWul8m106GUYe20uyUmO1iI4YjdLJyXc5Ir6ZoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKK8u+LPxn+HHwO0Cy8TfE3VJNLsNSvY9OtjFaXV9LNdyxySpEkNnFNKSUiduExhTk14j/w3d+zN/wBBvWf/AAlfEP8A8r6APr+v4c7HW/iJ4y/aAm1/4TLd3Pi3WvEMmoaYtkpedrx7priFlXBBKvh8twMZPAJr+q3xZ+3X+z7J4W1mPQNX1mbU2srgWqf8Iv4gTdOY28sbm08AZbAyTgd6+Hf2HU/Yx/ZM8Nrrera3qevfEbU4Qt/qn/CJ+ITHbI3LWtlu04FYgfvOQHlIy2F2ooB+rvwBsPjVp3wp0O3/AGg9UsdW8ceVuvpdPgEESluVjbadjyKOHeNUQnhVwNzeyV8gf8N3fszf9BvWf/CV8Q//ACvqnYft/fsr6rZxajpfiTVLy0nG6OaDwxr8kbr6q66eVI9waAPsuv5m/wDgtN4smn/aL8F+HLOZlOh+HYroMjENHPdXc+cEdDthjOfpX7S/8N3fszf9BvWf/CV8Q/8Ayvr82PFdt+yZ8av2wPEH7Qfxv1rVdS8LadHp9toWif8ACLeIXS7+zW0Zkmvf+JfjylnMgWH/AJaYy/yfI4B6z/wSTX9qpvhmp+IItrX4TJHI2hR3lts1OeWaQyvLA6FM2zOzu0kwdnYjyztya/Y2vjuH9uj9mG3hS3t9Y1iKKJQqIvhTxAqqqjAAA07AAHQVBB+3/wDsr3Vzc2Vt4k1Wa4siqzxp4Y19nhZ1DqJFGn5UspDAHGQQRxQB9l1Xurq2sbWa+vZVgt7dGkkkchUREGWZieAABkk9K+SP+G7v2Zv+g3rP/hK+If8A5X18u/tg/te+B/iX8ENW+FvwU1jUYdZ8ZMumXd/d+HPEEEFhpswJupXxpzSP5kY8kLGjN+8zgAZoA/K+7/4KY/Evw3+2N4o+OvhaeTUfBerXKWDaJM7JBc6NZkx25AOfKn27pVcAlZJHB3IzKf6Mf2cPFvwR+JXgOX4s/A23totP8aXcuo6i8cYjun1J8CdbwZLCdDhSCSAMFCUKk/it+z3+zv8A8E7fhj9m134t+I9e+JGux4cxT+E/EVtpUbjni2WwLS46HznZGHPliv1L0z9ub9j7wtBp3hLR9WvdHhEbrZWEHhPXbdfKhwXEMK6co2puGQq4GRnGaAPt6ivkD/hu79mb/oN6z/4SviH/AOV9RTft5fs0xQySx6vrczIpIRPCuvhnIHCjdYKuT0GSB6kUAU/25P2s9G/ZO+D1x4ihaK58Ya4JLTQbJ+d9zgbriRephtwwZ/7zFEyC4I8l/wCCdn7bkv7UngtfBviuyuW8c+ErFG1fUNsCWd0DJ5cEqhZBIJZVBaRViEasrfMoZFP4z/Gy18c/tofGK/8Aih8VfEreAdIJ+zabpt1oXiG+nsNPRj5capZ6bLC0hyXlbzhudjj5cAfWf7KXgD9kD9kzxrD8X7v40+LNQ1TTrWdLkReD9a07TZbaRMypdJJYXDNEuA+fMTDIr8YoA/Z74d/s+fD/AOHfi3WPiJGLvxD4z12SQ3Ou6zMLzUFgdiy2sD7VS3towdqxQoi4A3biM17jXx5D+3p+zDcRJPBr2sSRSKGVl8LeICrKRkEEafggjoak/wCG7v2Zv+g3rP8A4SviH/5X0AfTXjLxh4b+H/hTVvG/jC/j0zRNEtpLu7uZThY4ol3MfUnsFAJY4ABJAr8UP2a/+Cr2ofEP9o7XfBvjfRrmXwx401G0s/CdtaJB9osZHlS2RLhpJIlZZlbzpW3ko4KxqwYAcF/wUB/aE179qe+0/wCC3wpu73QPh1a+Vd6jqupaLrsUep3f3kj8m30+a4ENv1w8Q3y/MBhEY/Mfwy/Y6/ZjsLm11X4mfGzxAk8DLJ5OgeCvEMTxuhyGju7ixY5B6HyAR1oA/o98f/s/eAPin460bxp8RftfiC18PxL9i0O6mDaJHdq7ML17MKFmuMNsDTM6KoGxFbLH29VVVCqMAcADoBXxLoX7eH7LdrZx6AnjDW9WvNHiht7mWbwzrr3RcRqQ9wItNRVkkXDnCKDnKqARW5/w3d+zN/0G9Z/8JXxD/wDK+gD6/r8Sv2wv+Cok/wAHv2kPDvw8+Gax6t4d8HXv/FWlArm9dwY5bKBzwrWysWLA8zgI2FjYN7Z+1B+374fi+FN/o37OH9san4z1s/YobyTw/rNrDpUUqnzLxjPZKXZBxGqK53lWKlVIP4n+Av2QPh7rk41H4t/F+fRmmYySpp3g7xRqc7Fjlg8k2n2yhic5YFxnnmgD+nK2m8Mftb/AnSda06/13wz4b8YxRXY+yXMVjqE1kJD+5klgafy47hR84jkWTY20sjbgPWPAvgHwX8MfC9l4L+H+jW2gaJp67YbW0jEca+rHHLOx5Z2JZjyxJ5r4V/Yb8Sfs4fC/QrL9nD4WfEDxB4ovbg3ep2lvr+k3+n7UTYblbQ3NjaoIwzCQx73YM7MPvGv0ZoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//9b9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD5A/av/5GL9n3/spmm/8Apq1Svr+vkD9q/wD5GL9n3/spmm/+mrVK+v6ACivh/wDai+F8GtTaz8S9c0/xH8QU0vSorHRvDXhq6exuNMvWNxLNqe9byDzJJMwopCM8Sx/Ikm9se4/s0a9ceJ/2e/hzrt54gXxXd3Wg6ebjVV8z/TLhYFWaQ+aqybjIG3F1Vyc7lByAAe318gfsB/8AJm3wn/7A0f8A6Mevr+vkD9gP/kzb4T/9gaP/ANGPQB9f0V4R+0J8ZrP4M+CYb6GezTxD4huo9J0SO/nW3tGv51ZhJcSsVCW8CK80zZB2IVXLsoPhP7Buq6e3g/4heGx40TxvqemeM9YM9+bmKee5SRk23LLGxCRzMrmML8mAQvAoA+7a+QPgT/ycx+0v/wBhnw1/6j1nX1/XyB8Cf+TmP2l/+wz4a/8AUes6APr+iszWtTj0XRr/AFmVDIlhby3DKvJYRIXIHucV+RP7PmvG51X4L/G/x/4e8U6JrPxBu9snix9VSey1i+1a2mk/s660v7RIYNPL5FiwiGwwxHEYclgD9ia+OPi5/wAnm/s9f9gnxz/6J02vsevjj4uf8nm/s9f9gnxz/wCidNoA+x6KK/G39rWW/wBd+Knxlni8P+IfHV14R8O6c2jahoeo3Njb+C79oJZ3lnjjli8yU5iu2aBLmUxARsirwQD9kq8A/ax/5NZ+Mn/YmeIf/TdPXqfgPURq/gbw7qy6omuC9060nGoRLtjvPMhVvPVcDCy53gYGAa8s/ax/5NZ+Mn/YmeIf/TdPQB3/AMJv+SV+Df8AsC6d/wCk0degV5/8Jv8Aklfg3/sC6d/6TR187/ti215eaR4Dtddj1aT4bPr4PjAaKt290dPW0nNusi2P+km1N55Pn+XyFxn5c0AfZFFfDn7GHiiK/vvit4J8OLqo8E+Fdft08OjWRci6hsr2wguXhAvf9JEIlZ5IRN8wilTHy7RX3HQB8gfAn/k5j9pf/sM+Gv8A1HrOvr+vkD4E/wDJzH7S/wD2GfDX/qPWdc9+3vp/jw/A6+1/wr4vm8P6bpdxpxv7KC2jd9QSXUbWNUNyxEkKruJbyxlx8pO3IIB9wUV8YfFHQdN+Mf7Tmj/BnxrPdv4T0bwlceIZNPtru4skvb64vks4ZJntpI3dbZEcou7AeQN1C47L9kPWvE2q/BiPTvFV9Nqt34a1rXtBiv7hzJNd2uj6nc2VvK8h5d/LiVWc8syljkk0Ac78Vf8Ak8n4A/8AYG8cf+i9Lr6/r5A+Kv8AyeT8Af8AsDeOP/Rel19f0AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/1/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPkD9q//kYv2ff+ymab/wCmrVK+v6+HP289Q8S+Evh74D+LPhrSItff4d+NtH1aewkuhZG5S4S40qONJjHKFY3F9FklSAu49qk/4Xf+21/0bJZf+F3Y/wDyFQB6r48/Z7XxR421D4geD/HOvfD/AFjXrG307V30U2RW/t7QyGAut7a3PlzRCV1SaLY4VsHOBj1j4eeAfDPwt8EaL8PPBtubXRdAtktbaNnMj7EH3nduWdjlmY8liTXyl/wu/wDba/6Nksv/AAu7H/5Co/4Xf+21/wBGyWX/AIXdj/8AIVAH2/XyB+wH/wAmbfCf/sDR/wDox65//hd/7bX/AEbJZf8Ahd2P/wAhV80/sdfFr9rHRP2Yvh1pPgn4AWvibQrXS0S01J/GFnYNdRB2xIbZ7V2iyf4SxNAH6u6z4e0DxHAlt4g0y11OGJt6JdQpOqtjG4BwQDg4zXB/DD4OeCfhF/wkR8HW3knxNqtzq1yWSFSklyQTDH5UceIY8fu0bcVyeTmvnT/hd/7bX/Rsll/4Xdj/APIVH/C7/wBtr/o2Sy/8Lux/+QqAPt+vkD4E/wDJzH7S/wD2GfDX/qPWdc//AMLv/ba/6Nksv/C7sf8A5Cr5o+H3xb/ay8I/tJ/FbTU+AFreeI/HFvo3iWTTz4ws40s7G3tRo8ZFx9lZJTJLaO2MIy9CpGGIB+uckaSo0Uqh0cEMpGQQeoI9K+VPB/7JHhLwhrXhx/8AhKNd1bwt4JvHv/D3hu8ltm0zS7lkeNGjKW6XMogWR1t1mnkWIHgEgEcd/wALv/ba/wCjZLL/AMLux/8AkKj/AIXf+21/0bJZf+F3Y/8AyFQB9v18cfFz/k839nr/ALBPjn/0TptY/wDwu/8Aba/6Nksv/C7sf/kKvmT4v/Ff9rLTPjl8F/ih4l+AFrpslhdax4b0+yXxfZzi/vtfto5EVpltR5AjjsJGyyMrZwWU43AH69V8t+PP2XNN8W+KvFHiXw9448QeDIvHkMUHiSy0mS0+z6ksMItlfN1bTyW8pgURNJA8bFQP4vmrhP8Ahd/7bX/Rsll/4Xdj/wDIVH/C7/22v+jZLL/wu7H/AOQqAPsXw34e0fwj4d0vwn4dthZ6VotrBZWkCklYre2jEcSAnJwqKByc8V41+1j/AMms/GT/ALEzxD/6bp68f/4Xf+21/wBGyWX/AIXdj/8AIVee/Frxt+238T/hV4z+Go/Zws9OPizRdR0j7UPG1hMYPt9tJb+b5ZtY9+zfu271zjG4dQAfcPwm/wCSV+Df+wLp3/pNHVP4ofDVfiTpmmQW3iDUfC2qaHfR6jYajpbxCeGeNHjKuk8csMsTpIyyRSIysDnggEfC3wM/aU/ax8X/AAd8G6/4J/ZztdV0K40u2S0u38aWls08UKCISGF7Lcm4oTtPI9TXq3/C7/22v+jZLL/wu7H/AOQqAPpX4X/C/R/hbo19YWN/eazqOs3suo6nqmovG97f3kqqhlmMUcUY2xxpGixxoiRoqqoAr0qviD/hd/7bX/Rsll/4Xdj/APIVH/C7/wBtr/o2Sy/8Lux/+QqAOg+BP/JzH7S//YZ8Nf8AqPWde+fFb4aaF8YPAeo/DzxLPc22nam1s8sloyJODa3Edym1pEkUZeIA5U8Zxg4I/M34R/Fr9rGy+O/x21DRvgBa6lq2oapoT6nYnxhZwLp0sei20cMaztastx5sIWUsqqELbDkgmvpb/hd/7bX/AEbJZf8Ahd2P/wAhUAe5fEz4J2fj/wAS6P460XxLqvgnxXotvcWMWqaObUzS2F2yPNazRXkFzBJGXjV0Jj3RuoZSPmB7f4c/D/w98LfBWl+AvCyy/wBnaUjKr3EhlnmkldpZpppD9+WaV3kkbAyzEgAcD5W/4Xf+21/0bJZf+F3Y/wDyFR/wu/8Aba/6Nksv/C7sf/kKgDoPir/yeT8Af+wN44/9F6XX1/X5b+IviJ+0LN+038CfHPxf+D8HgbRkvdX8Lwyw+JLbV2luvEFtHMjFIYImURLpz5zkNu6qQA36kUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiuJ+JPjzSPhb8PfEnxJ8QQz3GmeFtOutTuY7VVed4bSJpXWJXZFLlVO0MyjPUjrQB21FeAfEH9pL4e/DjwD4a8c6vFfX1x4zFqNE0SxhS41jUprtFkSG3txIFZ1VwZCZBGnd+Rn3PTrqa90+2vLm0lsJZ40ke3nMZlhZgCY3MTyRllPB2Oy5HDEYNAFyiiigAooooA+QP27/APk2fW/+wz4V/wDUh0+vr+vkD9u//k2fW/8AsM+Ff/Uh0+vob4m+P9G+FPw88SfEvxDDcXGl+F9PuNRuY7VUed4baMyOsau6KXIHAZ1GepFAHc0V4r4i+O3hHQfGXhH4d2dnfa74n8YRi6i0/To4pJrLTwPnv70ySxpBbISE3FizudkSyNkDTsvjZ8N9U+LcnwR0jV4dQ8V22l3OrXVvbOkotLe2uIbZluCrExytJMNqEZIVicYGQD1evkD9gP8A5M2+E/8A2Bo//Rj19f18gfsB/wDJm3wn/wCwNH/6MegD6/or53vv2nvhhpPgPxb8Q9Ze7sNO8Ia5feHZIpIle6vdTspvIEFlDE7tM08mFhXhm6sqgEih4r/ak8G+Cm0yw1/w34kGs3mlLrd9pdnpbaheaPp7syCbUBZvNHGNyOoCPIxKPgHaaAPpevkDTf8Ak/rxD/2TPRv/AE9alX1D4W8T6D418NaV4x8LXiaho2uWsN7Z3KAhZre4QSRuAwBG5SDggEdCAa+XtN/5P68Q/wDZM9G/9PWpUAfX9Fedar8TdA0f4n6F8KLqG5OreIdM1DVYJlVPsyQabJbxzLIxcOHJuUKAIQQGyRgA43wr+NHhj4yS69deB7O9uNB0S7axi1uSONNO1OaLIn+wOJDJNHC4KNKY1jZgRGzgEgA9er5A/av/AORi/Z9/7KZpv/pq1SvZfhH8bPAPxws/Emp/Du7fULHwxrVzoVxclQIprq1jilkaBgT5kWJlCvwGIJGVwT41+1f/AMjF+z7/ANlM03/01apQB9f0V538VviZoPwf8DX3xA8SwXNzp1hNZwyR2io8xa9uorSMqsjxrgPMpbLDCgkZOAcTU/jV4WtPi1p3wV0q0vdd8SXNsb2+FhHG8GkWn/LObUJZJIxEJm+WJFDyvyQm0bqAPX6K+a/h9+1B4V+Jnie08PeGPCXiw2d7NcwxazPodxFozfZvMDOL0/utjNGVRs4ZiAOTX0pQB8gfsB/8mbfCf/sDR/8Aox6+v6+QP2A/+TNvhP8A9gaP/wBGPXX3v7U3wx034Yah8VNQS/hsbPWb/wAP29iIUk1LUdUsbyWx+zWVvHI/nSTzRN5I3AlfmfYA20A+kKK+Z/Hn7U3gz4d3FvpeteHPEd7rK6XFrOpadpmmnUrnR7GUsqyX5tXkij+ZJBhJJCdjlcqM1754Y8S6F4z8OaX4u8L3iajo+tW0N5Z3Medk1vOgeN1zg4ZSDggEdxmgD5c+BP8Aycx+0v8A9hnw1/6j1nX1/XyB8Cf+TmP2l/8AsM+Gv/Ues69yufix4WsvibffCy/8611DTdATxHPdy+Wlili9xJbHdKZNwdWiZmygULg7s5AAPTaK+bdJ/al+HWrfDm6+K62Or2/hltRTTdIuHs98uvyzSCGB9LtonkuJo5pDiIvHGWALgeWC9d98KPi/4Z+L+mape6FaahpN7oV62nalpurWj2V/ZXSxpMElhfPDxSJIjqWRlYFWPOADxT9q/wD5GL9n3/spmm/+mrVK+v6+QP2r/wDkYv2ff+ymab/6atUr6/oAKK+Zv2xfjJ4p/Z+/Zu8ZfF7wXb2l1rXh9LJreK/R5LZjcXsFu29Y5InOElYjDjnHUcH6OsJ3urG2uZAA80aOcdMsoJxQBboryvx38c/gv8L9TtdG+JHjvQ/C+oXyh4bfUtRt7SV0JIDhJXU7MgjcRtzxmu31LxR4a0bw/J4t1fVrSx0OGEXEl/PPHFaJCwBEjTMwQIQQQxbHPWgDdorznwv8YPhL42OnDwb410XXG1czrZrY6jbXDXLWyq86xCORi5iVlaQLkoCC2ARXo1ABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/9H9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACvnD9sT/k1D4w/9ilrX/pHLX0fXN+MfCPh7x/4T1jwP4ttPt+ia/aTWN7b+Y8Xm21whjlTfEyOu5SRlWDDsQaAPyI+Fdl47/Zv+Ivwr+Pv7ROo2fivQPiLoOn+HU1RIDHD4MuZED2NvAXJCWlzERFPMQGMoLOwU4fuvi3B4o+Mn7XvjvwDr/w+n+JfhzwHouinTdH/ALdXRbaGXU1kmm1BkZ0M8xZfJRx/qgnGGYGv0e8TfCj4e+MvhrP8IPFGjR6j4QubKPTnsJXkKm2hVVjUSBhKGTapWQOHVgGDBhmvOfF37LHwd8Zf2HNfWmpWGoeHtOTSLXUNO1nUbHUTpyYxaz3kFws9xFkZxM7nJLZySSAfA+hy/ET4efDb4YfGvxfqi3SfCfx3f6FeMmrxaw0fhTWZ/wCzzFfXVu7rNcafJJCrb/mTyiSAc1c1Xw74s+N/w4+J/wAVtB8SWWmXPxS8c2WmaHZ6nqMmm2mt6D4dmNpFpkU8Z8yJtTaG5ciIbpA2D8pJH1r8dPhHqlp+zvc/s6fATwJYzaT4jsrnRMS3SW1no8F2CGvpFkJlnZGdpcJukaQBiSSTXp7/ALO/wtvfgtonwG1nS/tvhfQLWyt7VRJJbzxyWAXybmOeBkkjnDrv8xGDbiTnk5APmL9kZfCfgf4reL/hdB4F1z4S+IrjSbPV5vC1xqUWraC0CTyW51DTZ43fa7uRHMv7sEKh8vcGI/Q6vF/hd8Avhz8I9T1TxD4Ziv77XdajihvNU1fUbvVtQlggJMcP2i8lldYkLEhFIXPJBPNe0UAfIH7d/wDybPrf/YZ8K/8AqQ6fXUftm/8AJpnxf/7FbVv/AEmeuX/bv/5Nn1v/ALDPhX/1IdPr6/oA/M/4V6Nq/wCyV8UtM1T4j6zJ4r0D43R6fb3Hii8hjjubDxHFDtgspWQDy9PuU+W0TJWGRdnR9x9jHhzw9of7eekXeiaXa6fPqnw912e7kt4Eie4mOs6YTJKyAF3OT8zZPNfZtFABXyB+wH/yZt8J/wDsDR/+jHr6/r5A/YD/AOTNvhP/ANgaP/0Y9AHw/oPwx8fafr/jv9qPw7dz+L2+GXxM8VXUPhB4Y2t5NPa4ePUZrUEFjqWxvMgkJGBH5Sqd5z9H/E79oH4E+MtK1qLRviRF8H73xRoGnapZeMTBp6nXdMdblRbW8l0jvM1pI7iSFdk8Lv8Au9pZq/RCq9xaWl2YzdQpN5TB03qG2sOhGeh9xQB4H+ydNqc37NPw0OsaAnhi5j0Kyi/s5FkRYI4owkeFmLSruRVfEjFxuwxLZNcJpv8Ayf14h/7Jno3/AKetSr6/r5A03/k/rxD/ANkz0b/09alQB5F+1f8ACbUPjf8AtHfDz4aWviq+8I2eseDvFsV/c6cqfaZrVp9MU26u+diu5QyEDLRq0fAckUdH8UfFrxp8Db39mzwzodlpfxF8C3Vl4f8AFGn2dymkK/h8xti/0mTYyxpfwIqRsEzAXkwA0a5/SqigD4I/YjPiTTtX+M3hu88GW3hPSLDxg6xQ2t9Hcx20sek6ZELNESNPkjhVGEgwDu27flye4/av/wCRi/Z9/wCymab/AOmrVK+v6+QP2r/+Ri/Z9/7KZpv/AKatUoAZ+3tDeXH7K3i6DTrgWl3JdaEsMxQSCKQ6xZBXKEgMFODjPPSvMvhJZXv7I/xa1T4V+Ob648SaZ8Vp5NX0bxRdRx/2hfa7HAPtmmXsiBFaWQJ51iDtGwtCpJQCv0PooA/I74M+KfDnhDW/gp4S/Z5+K2u+Nb3ULz7B4g8Lau8DvYaNHbztc3F5ZJEj6bPazLGqkspkZgp83fuP641EsECSvOkarJLjewADNt4GT1OO1S0AfIH7Af8AyZt8J/8AsDR/+jHr4T8AeAPG3gezu/2v7C8uPGVn4A8beNEm8MNBG0dpoU+rXUd/daeMbjqEbBpzIWBkhBgGABu+7P2A/wDkzb4T/wDYGj/9GPX1/QB+Y/xV/al+EuoePtS8GfDvxz4W8Av4q0PTLzWfGepzxfaJrG6jkNlBp1szJ586wuz+ZKwjgEgykjMVH3T8FdF8A+HPhJ4Q8P8AwsvU1LwjpumW1vpd1HKJ1ntYkCpL5q8OXA3FgACScAdK9PooA+QPgT/ycx+0v/2GfDX/AKj1nXzx+0r8Ctb/AGhv2p9b+H+m+LbjwvbS/DW1llSGKOSK+mTVrs20N3vDbrQS4eaJR+9ACkgZB+h/gT/ycx+0v/2GfDX/AKj1nX1/QB+SXxO+Kt38SfBPwo1XxFeP8L7j4YeMxpXjtbNIs+HLg6Zd2cdzGZUkjitJvOH2a5KMiLMjg7kOPqD9kjxNqOv6p8TLLTPFM/j/AMDaVq9rBoHiS7MM098GtI3vIftkCRreR2s5MaTYJ5Kb22Zr7LdEkRo5FDKwIIIyCD1BFNiiigiWGBFjjQAKqgBQB0AA6CgD5E/av/5GL9n3/spmm/8Apq1Svr+vkD9q/wD5GL9n3/spmm/+mrVK+v6APg3/AIKcf8mNfE//AK5aX/6dLSvuHR/+QRY/9cIv/QRXJ/E74Y+B/jJ4G1T4bfEjTf7X8OayIlu7XzprfzBDKk6fvIHjkXEkat8rDOMHgkV8u2v/AATk/Y7s7iG6tvBF0ksDK6H+39bIDKcjg3xB5HQ0AeZfsZ+DfBPxKu/j34u+J2jWXiHxdfeP9b0vVP7TtYriS3sbIRx2dmPNUn7OkP3OADk9dtfF3writfF2gfAX4VeKGN58HL74p+LYNPivCWtbux0xHk0W2k3cSRNcmVFjJZGI24OMD9XPiJ+xz8Bfib4t1Dxvr+kXtlq2tRpDqsmlapfaWmpxRqVVbxLOaJZsKcbmG7GAWwAK5j9or4VW1p8GfDvw48A/CPTfH3gzSb22S78ORzLp91b2ESt/pGlymWFUuomOQfMV2DNhtxOQDxDx54J+FXg3/gov8CB4F0uw0bXL7Q/Ez6nb2EUdurW8dpts5ZIogo3E+eocrkhAMkKAP03r8ufgF+z/AAXv7RPhz4u+FvhZqnwt8KeDNN1NfN8SXX2rXda1PVkjgJl3XV5KsFtDEdplm+852IAWI/UagAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPkD9u//k2fW/8AsM+Ff/Uh0+vr+vjL/goFptjrP7KnibR9TiE9nfap4ZgmjJIDxS6/p6upIweQSODms3/h27+xL/0S2y/8C77/AOSKAPt+iviD/h27+xL/ANEtsv8AwLvv/kij/h27+xL/ANEtsv8AwLvv/kigD7fr5A/YD/5M2+E//YGj/wDRj1z/APw7d/Yl/wCiW2X/AIF33/yRXzT+x1+wn+yd8R/2Yvh1458bfDy11TXdZ0tJ7u6e5vEaWUuwLFUnVRwB0AFAH660V8Qf8O3f2Jf+iW2X/gXff/JFH/Dt39iX/oltl/4F33/yRQB9v18gab/yf14h/wCyZ6N/6etSrn/+Hbv7Ev8A0S2y/wDAu+/+SK+abH9hP9k6X9sTWvhxJ8PLU+G7XwHpmrR2f2m82LfT6pfQSTbvP35aOJFwWx8vAzkkA/XWiviD/h27+xL/ANEtsv8AwLvv/kij/h27+xL/ANEtsv8AwLvv/kigD7fr5A/av/5GL9n3/spmm/8Apq1Suf8A+Hbv7Ev/AES2y/8AAu+/+SK+af2if2E/2TvB2t/Bq18NfDy1sYvEvjyx0nUVW5vG+0WMun6hM8LbpzgGSGNsrg/L1xnIB+utFfEH/Dt39iX/AKJbZf8AgXff/JFH/Dt39iX/AKJbZf8AgXff/JFAH2/RXxB/w7d/Yl/6JbZf+Bd9/wDJFH/Dt39iX/oltl/4F33/AMkUAdB+wH/yZt8J/wDsDR/+jHr6/r8iv2Ov2E/2TviP+zF8OvHPjb4eWuqa7rOlpPd3T3N4jSyl2BYqk6qOAOgAr6W/4du/sS/9Etsv/Au+/wDkigD7for4g/4du/sS/wDRLbL/AMC77/5Io/4du/sS/wDRLbL/AMC77/5IoA6D4E/8nMftL/8AYZ8Nf+o9Z19f1+RXwj/YT/ZO8Q/Hf47eFNZ+Hlrc6T4U1TQoNMgNzeBbaK60W2uZlUrOGO+aRnO4k5OBxgV9Lf8ADt39iX/oltl/4F33/wAkUAfb9FfEH/Dt39iX/oltl/4F33/yRR/w7d/Yl/6JbZf+Bd9/8kUAdB+1f/yMX7Pv/ZTNN/8ATVqlfX9flh8Vv2Rf2c/gX8RfgN4t+FHgq28P6td/EPT7KWeOe5lLW7afqExTE0rr/rIY2yBnKjnrX6n0AFfLegftd/CnxH+0rrP7LVgt6PFOjWzzNdvHGNOnlijimltoZRIZGnijmDOpjAG1huyAD7R8UfiDovwo+HHib4l+IWxp3hnT7m/mGcFxBGXEa/7TkBVHdiBX89sXxe8E+Bfg/wDC/wCNNuNXuPjB4b8Z3PjTxG7aJqMENzBrzlNVtxdSQLCAbUQpu8zaRGdpORQB+53x4/aE0P4FL4YsJ/D+q+LfEHjK9ew0nSdGiiluriWKMzSsfOkiRY40GWbdxkcYyR6H4W+Jvgnxr4m8VeD/AA1qBu9W8FXMNpq0Pkyx/Zp7iITRrvkRUk3RkHMZYDoSDxX57ftW/D/Q/iZ+07+zRrVl4q120svFU2sRxS6Tqs9okUMOlvcx3Fn5ZHkyyhgskiYMkeFPArz34Raba/AT4i/tffFy01rXtcn+HQ+0Q2moarc3MF8w0kXSm7VmPmyK6hI5Wy0cZIHFAH7EUV+C0HxA+IF38HrH4v8AhPxR8YdX+Nd3ZW+roP7E1eXwtdXEwWdrFLFbb7EbIqTHG6AZ4kDYOK+l/EsXxU+P/wC15pvw8bxt4j+HXhLVPhhpev6vpml3klndpczX0yGCPerC3lLOqzSKglKReXuAJoA/VKiq9rbi0tYbVXaQQoqBnO522jGWPcnuasUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB//9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD5A/bv/5Nn1v/ALDPhX/1IdPr6/r5A/bv/wCTZ9b/AOwz4V/9SHT6+v6ACiiigAr5A/YD/wCTNvhP/wBgaP8A9GPX1/XyB+wH/wAmbfCf/sDR/wDox6APr+iiigAr5A03/k/rxD/2TPRv/T1qVfX9fIGm/wDJ/XiH/smejf8Ap61KgD6/ooooAK+QP2r/APkYv2ff+ymab/6atUr6/r5A/av/AORi/Z9/7KZpv/pq1SgD6/ooooAKKKKAPkD9gP8A5M2+E/8A2Bo//Rj19f18gfsB/wDJm3wn/wCwNH/6Mevqa+8R+HtM1fTPD+papa2mqa1532C0lnSO4u/s6eZN5ETEPJ5afM+wHaOTgUAbNFYs3iTw7b69beFbjVLWLW72CS6gsWnRbqW3hZVklSEneyIzqGYAgFgCeRW1QB8gfAn/AJOY/aX/AOwz4a/9R6zr6/r5A+BP/JzH7S//AGGfDX/qPWdfVusazpHh3SbzXvEF9BpmmadC9xc3V1KsMEEMSlnklkchURVBLMxAA5JoA0qK57VvF3hPQPDj+Mdd1qy07QI40mfUbm5ihs1ilICOZ3YRhWLDad2DkY610NAHyB+1f/yMX7Pv/ZTNN/8ATVqlfX9fIH7V/wDyMX7Pv/ZTNN/9NWqV9f0AfP37SfwMl/aK+H1r8MrnXjoeiXGq6fd6wi232htQ0+zmE72QPmxeV5rqh8359u37jZ49U8beC9E8e+B9c+H2uQhtJ1/T7jTbhFAGILmJomCjoCFbj0NdPcXFvZ28t3dyrBBArPJI7BURFGWZmPAAHJJ6V8U33/BQ79lmzu7kQ+IL/UNIsZWgudZstG1C50iCRG2ndeRwGJlz/GhZCOQ2KAJ/BH7JOteGrP4BQ6947/tu5+Bf9pRpN/ZvkHUre8tXs7eMj7TJ5H2eIou7Mm/Z0XPG/pf7MN3YfF74q+LLvxJFqHgL4v2iRaz4bmsP3nnrZrZM8d8Jgwjki3Fk8vq3BGK+n9A1/Q/FWiWPiXw1fwappWpwpcWt1bSLLDNDINyOjqSGUg5BFa9AH56aX+yL8dbDwTZfAdvjXJH8KNOWO2iS10pbbxG2mwtmOxOpJN5aqqgIZkgVyo24ANfRul/AqDSP2ip/j1a6viGTwlbeFU0ryCdi21412Lj7SZSWyG2bDHnjdvOcV79RQAUUUUAFFFFABRWBqXivwxo2s6T4c1fV7Sx1XX2mTTrSeeOO4vGt08yYW8bENKY0+ZwgO1eTxWB4Z+J3gnxh4u8WeBPD2oG61vwRLawavB5Msf2aS9h+0QAO6Kkm6P5sxswHQ4PFAHfUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB//9T9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKAPkz9nn4leONS+Ivxh+D3xS1P8AtPW/A2uJdafctDDbmTw9q8Qn0/IhSNHaHbJE7hckqNxzXivwg/a91O50S+8c+NV1fxavxH8Raz/wgfh/QtMjuLz/AIR7R5FtjcEosWFd8u8lxLgblCHFZ37bfg74weH/ABtpfxO+Aug3mtaz470G/wDh9qwsoZJTaJfkS6fqMojU+XHaS+dvmf5UDgEjOC74teH/ABT8JNd+F3wm0qbxVoPwc0Lwy9jJqXgvS3vtWn1W2aKKC2uJba3ubm3iljBffGq+ZKcM3dQD0D4oftRf2/8ABeDx58Hry80TUrHxtonhnVbbULFYr2zlm1G2hvbSeC4R1VzDMPmXOAwKMDyPpbw98Y/CPiafx7b6atyG+HN7JYapvjCgzR2sd23k4Y718uReTt5yMd6/KPwx4D8ep8L/AIj+DYvBfiy31C6+LXhrxJaxavbXd9fT6PcXGnFbuW7xKsrqttK9yBIxgwRJswK98uPEPjL4ReNv2jPBY8BeI9e1b4g3x1Xw1PpulzXOnXou9Jgtdsl4o8i38ieMiXznQgYKhsjIB9Nan+1h8NrPwX4E8WaVp+sa/efEmzF/oWiaZZfadWurcRLNJIYQ4jjSJHXzHeRUUkDcSaVP2tfhKfhnqHxLk/tOEaVqkehXOjSWMia2mszOkcWn/Yj8xuJGkTYAdhVg27bkj87bL4UeMPBNr+z18TfHEPjPw94e074bw+GdWk8M29z/AGvo2oI0Vyv2u1igmuRDKA0b7YiVdF37Rjd30Xw20Kb4SePvGev/AAv8a+LPD/i/xPpE1zJq2ozjxRJYadGsSa/bWcFrHdQy27Y8u3z50kSbm2j5CAffnwl+Pvhr4tavrfhaPQ9b8JeJfDyQTXekeILL7FeC2ui6w3Ee15YpYXaN1DxyNhlIbHGfc6/Pz9lDV/iBc/FLxRpWjeIPFni74R2uk2zWWp+NdPks9STWGnfzLe3mube1ubmBYQC7Sxna+AGJJJ/QOgD5A/bv/wCTZ9b/AOwz4V/9SHT6+v6+QP27/wDk2fW/+wz4V/8AUh0+vbfjd8M7H4yfCPxb8L9QYRJ4j06e1jlP/LC4K7reYY7xTBJB7qKAPUqK/NLTPHd9+0+P2dfAurRkXULS+LPGEBxmG58KP9i+zyr0xJrDAhT1ELdhXEXfx60P4o/tV/B74jw+OtPtPBVrrmuaRpOmLfwJ58K6PfJJql7Hv3L9puQkVmrgYjVXA3T4AB+slfIH7Af/ACZt8J/+wNH/AOjHr6/r5A/YD/5M2+E//YGj/wDRj0AfX9FfmNqfjXVv2cfD37Qnwj8PArq32yHWPBUIO0u/jiU20EUK/wB2DVzPkL0Vh0rG8cfs46r4c1zwj4CsPhhqvxG8E+APA9jY232HXm0GN9S+0zfbHzHcwNNcSJHG4UjZmQ5ZTjIB+qVfIGm/8n9eIf8Asmejf+nrUq9n+BPijwN40+Dvg/xL8NY7iDwxd6bALCG7aRrmGGJfL8mZpXkcyRFSjlncllJ3N1PjGm/8n9eIf+yZ6N/6etSoA+v6K+QPjjb/APCvfj18JPjnbjy7S+uZvA+tsO9prZEmnu56BYtQijQH/pua84+Gfwo8B/tHT/FT4x/E62mvNF8WeIfsmktFfXVht0fwsJbCCVZrSWGURzXBu5yC+1g6sRwMAH6DV8gftX/8jF+z7/2UzTf/AE1apXKfsYfCvwhpUfiP42+DLa90vw/42dYdAsLnUb2/C6NaMyw3jm8mmYS3zZnABwsJiUAN5hbq/wBq/wD5GL9n3/spmm/+mrVKAPr+ivn79qP4can8Ufgb4m8PeHPl8SWUUeraJIo+ePVtLkW8sip6gtNEqEj+FiK+cT43/wCGo/il8J9T8HKkumeEvCz+PpYZDuhXWdWhex0e3m/uvCftjkHkFB+IB+h9FfjL8IdftPAvi74GXWix+Ll+KXiTV/7K+Iv9sJqi21xNdWNxLcrMbz/Q2eO6iEtr9m58mNyPkzn9mqAPkD9gP/kzb4T/APYGj/8ARj1c/bD0u70/4daV8ZtGhaXVvhFq9r4oQRj95JYW+YtUhBHOJLCWfI7lV9Kp/sB/8mbfCf8A7A0f/ox6+s9R06x1fT7rSdThW5s72J4JonGVkikUq6sO4YEg0AfI3wQe1+KXx++KHx5gkW70nSxa+CtAmU5VrbTx9r1KVCOCsl7N5ee/2cenH2LXCfDT4Z+B/g94J034c/DjS10bw7pAkFrarJLNs82RpXJkmZ5GLO7MSzEknrXd0AfIHwJ/5OY/aX/7DPhr/wBR6zr6s1vRtM8RaNf+H9agW60/U7eW1uYX+7JDOhSRD7MpINfKfwJ/5OY/aX/7DPhr/wBR6zr6/oA/JvwhPqXjzw58Kv2Mdema8v8AwR4pu7XxLv8Am87QvBDx3Ng0q9dl55+l8nrub0OP1krzjSfhH8OdC+JeufGHStFjt/GPiW1gstQ1APIXnt7YARIULmNcBVBKqCwVQxO1cej0AfIH7V//ACMX7Pv/AGUzTf8A01apX1/XyB+1f/yMX7Pv/ZTNN/8ATVqlfX9AHwZ/wUm1fWtP/ZT1vStIupLGPxJqOk6Pe3MZ2mKxvryOOfJ/uuv7tvUMR3r7L0DwV4U8MeD7PwBoelW9r4dsLQWMVisY8gWwTZ5ZQ8EFfvZzuyc5ya5P43fCLwv8ePhX4j+E3jEMNM8Q23ktJH/rIJUYSQTp/txSqkig8Erg5BIr5J0zQv8AgpDofhtPhrBqngTU/s8P2SDxhcvfLfeQo2LcS2AjaNrsLhsbzEWHzEgk0AZPjK/tf2d/Cnw0/Zc/ZI1OKyvviD4iv9Ps76eRdXTQ7a3DXmpyRxuxV5IA+UikyoLHd2z0Gm+KfjZ+z5+0L8Ovhb8RfHkvxM8IfFZNTtra6v7C1sr/AErU9OgFyBvs0jSWC4UlQrJuRgMMAMNl6p+w/qHgf4WfC/T/AIIa5CfH/wAJdWm1u1v9ZEgt9Yub8EalHeGEvJGt1nAZd5RVC88tXaeF/g98cfib8dvCHxy/aFg0TQLb4c2l/FoOiaJdXF+XvdTjENzd3dxNFAuBEoWKNUbBO4sCMEA+QPD/AMUv20PF/wCyr4s/aaT4rW+lP4JuNbmtNNXQrGVNUtNKuZQ4vJSqlCVBiQQqmBGrsXdiV9L1H4kftT/Dy3+Cvx38Z/EO01fRPin4i0LS9S8JwaRbwWOn2niFC0f2a6y108ttkZZ5P3h6jaNp9h8H/sueP/D/AOxR4w/ZvvdQ0x/EviC38RxW9xHLObFW1i4uJoPMkMAlAVZVEmIjgg7d3BPS/FP9nXxt44+EfwV8A6Te6fFqHw41/wAK6rqMk8kywywaGm24W3ZYWZnY/wCrDqgP8RWgDyLQdc/ai+OP7QHxu+HHh74mjwJ4Q8A6lYwWVxa6RZXl80l3ZpKIFadCnlIwLuWDSMXCqyqDW58O/jl8evEPwE+K+jXt/oQ+K/ws1q68OSaxqJWw0i4ETQsmpzL9yL/R5Wcx8IXQDAVsDyf4bj9ovTP2pf2lte+B0Gga3aya5pdve6XrtxcWW2ZdOjaG5t7iCOYHAZhLG6DcApVgRiu28Q/sT/ETXv2ZfE3gnUPEOmX/AMS/GHilfG2rSTRyf2Hd6is0cn2AptMv2IRxIg3KTkbiuDgAHnfhf9qHWvD3x8+Gfgnwt8fLb43aV4z1WXS9atRpNpBHZO0DPFPa3ljEkajevETySErkgnlh6X4Z1v8AaT/au134keK/hp8UD8LvC/g3X73w5oNpbaVaX5v7jS9qzXt7Jcq7NFLI21I4yoCjkFhll8a/BP8Aa6+JOufDLx7qVr4M8ON8Mtag1C08M2NzeNbXKPG0M8kt79nAjeNSPJijgK4Z90hO0Vt2XwS/am+BuufELSP2cJ/C+o+FPiDrF1r1s+vz3cF1oWoagFF1tjgilS4g3KHiXchB4YEZJAPB/it4d/aM8V/Hb9k68+IXiw+CPGmor4gt7i20+0sL2306+tNPkNzdQNIkglF7EFBjkZliB+QBwTXpHxB/a4+Ivwt1D9qHUJPL18/D/UPDOm+FdNeGNEW71u0jAV2jCSSr58nmMHcttUqpXIx33jH9mr426ZZ/ATxF4I8TWvjXxl8Ibi/a/uvFN1dINUGr2zQXUnnRpcShkLHykbIVMLk7QDT8dfsW638S7j9oyz8Q61badZfFy60G+0O6tGlkubC50S2RUkuEZI1H7+McRyNujJ+ZW6AHNfE3Vv2nf2UfDnh/42eN/iq3xF0Yanptl4o0a50mys7eODUJlt2n0+W2RJY2gd1CLIzBwcvzV7Ttd/ad+NP7SHxu+Fnhj4mL4F8HeArvR1tbi30mzvNQD3+nJN9niadNgi375JHkDyElVRkXNaXib4O/tV/tDxeFPAH7QUPhXQfBvh/VLHVNYuNEu7u7utck05hJFDHDNDCttBLJzJudnGBtr374R/B3xN4C+Nvxp+JOsXVnNpnxGvtHutPjgeRp4k0+wFrKLhWjVVJcZXYzgrySDxQBzv7GvxR8ffE34aa9a/FG9h1XxT4H8Tax4Xvr+CBbZL2TS5ggn8lPkQurDIUBcjgCvrWvmn9mf4N+J/gzp/xGtfFF1Z3T+L/G+u+JbQ2byOEs9UkR4Ul8yOPEyhTvVdyjs7V9LUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA+QP27/+TZ9b/wCwz4V/9SHT6+v6+QP27/8Ak2fW/wDsM+Ff/Uh0+vr+gDwz4cfs9+Afhb8RvHXxP8NG7fVvH80c14lxKskFrseWV0tECK0STTzSTSgs26Ri2QMAT69+z38Kdf8AFvhHxlJodtZXng28uL22jtba2jhnkubWW0IuF8ol1RZS6BWUiRVbJAwfbKKACvkD9gP/AJM2+E//AGBo/wD0Y9fX9fIH7Af/ACZt8J/+wNH/AOjHoA9M8ffs9+APiP8AFTwP8X/EBu11rwGZjaxQSqlrdeZhohdoUZpBbyqJoNrJtk5O4cVT+IPwEHjLxZdeNfDfjrxF4F1XVLGLTNQbRZ7Xy7u1hZ3jzHeW9ykUyb2CzwhJADjcRivf6KAOQ8AeBPDPwx8FaL8PvBtp9i0TQLWO0tItxcrHGMAszcszHLMx5ZiSeTXzfpv/ACf14h/7Jno3/p61Kvr+vkDTf+T+vEP/AGTPRv8A09alQB778Vfhr4f+MHw+1n4ceJ5bi30/WYlRp7OQRXVvJFIssM8EjK4SWKVFkjYqQGUHB6VjW/wY8Laf8D/+FBaLcXml+H10JtAjuLd4xex2z25t2lWRo2TzypLFzGQXJbbXrdFAGN4c0DTPCvh7S/C+ix+Tp+j2sFnbJx8kNugjjXjA4VQK+Wf2r/8AkYv2ff8Aspmm/wDpq1Svr+vkD9q//kYv2ff+ymab/wCmrVKAPr+vCvgz+zx8PvgW/i5/Bf2qUeMtTm1K5W8kSVYFkLMtpbBUTZawl3MUbbiu9sscjHutFAHzX4B/Zp0jwV4g0LWNT8X694stPB63C+HtP1ea3lt9K+0o0TOjxQRzTypC7wxyXEkjJExUcksfpSiigD5A/YD/AOTNvhP/ANgaP/0Y9VfGfin40aX+158MvDF9qWn23w/12DX2gs7LzvtdzLaWcT7r4v8AuyEd8xLGOOSxJxi1+wH/AMmbfCf/ALA0f/ox69l8XfC7/hKfit4A+J39p/Zf+EGTV0+yeTv+1f2rBHDnzd6+X5fl5+427OPlxkgHx/8AETxD8V/G8fx3+Kng3xzqPhxPgxPPZaDpVp5IsLy70nTINSu31JJImadbiSfyAu9RGiblwx3V96eCvEQ8X+DdB8WrCbYa3YWt8Ij1j+0xLLtOcdN2K+YfHP7Mni7XNZ8f2PgrxxF4c8HfFko/iXT3037VeCQ2yWV1Jp12LiJLdru2jSOQywzbGBkTBOB9dWNla6bZW+nWMYit7WNIokHRUQBVA+gGKAPkr4E/8nMftL/9hnw1/wCo9Z1698eL34pab8L9b1H4Qz6Xa69a288vnasszwxQxwyMzxrDy0oYLsDEL1z6HyH4E/8AJzH7S/8A2GfDX/qPWdfUnibRv+Ei8N6r4f8AO+z/ANp2k9r5u3fs86Mpu25GcZzjIz6igD86Pi38RP2gLD/gnf4X+J3w9160ttXbwLpmo61qt807akWmsbZ3ls2j+X7Q7NIWeQ8EggZ6fplXzP4g/Z1/t39k2L9l7/hIPI8rwxZeHP7X+ybs/ZLeOD7R9m80fe8vds83jONxxk/TFAHyB+1f/wAjF+z7/wBlM03/ANNWqV9f18gftX/8jF+z7/2UzTf/AE1apX1/QAUUUUAFFFFABRRRQBy+h+CfCfhrWNc8QaBpUFhqXiWaO51K4iTbJdzRIIkeU/xFUAUH0rqKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//1v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPkD9u//k2fW/8AsM+Ff/Uh0+vr+vkD9u//AJNn1v8A7DPhX/1IdPr6/oAKKKKACvkD9gP/AJM2+E//AGBo/wD0Y9fX9fIH7Af/ACZt8J/+wNH/AOjHoA+v6KKKACvkDTf+T+vEP/ZM9G/9PWpV9f18gab/AMn9eIf+yZ6N/wCnrUqAPr+iiigAr5A/av8A+Ri/Z9/7KZpv/pq1Svr+vkD9q/8A5GL9n3/spmm/+mrVKAPr+iiigAooooA+QP2A/wDkzb4T/wDYGj/9GPX1/XyB+wH/AMmbfCf/ALA0f/ox6+v6ACiiigD5A+BP/JzH7S//AGGfDX/qPWdfX9fIHwJ/5OY/aX/7DPhr/wBR6zr6/oAKKKKAPkD9q/8A5GL9n3/spmm/+mrVK+v6+QP2r/8AkYv2ff8Aspmm/wDpq1Svr+gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9f9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDyL47fCW2+OPwu1X4Z3WrT6ENSlsbiO+tkjllgm0+8hvYWVJQyN+8gUEMCCM147/won9pn/o5fWf/AAmvD3/yHX1/RQB8gf8ACif2mf8Ao5fWf/Ca8Pf/ACHR/wAKJ/aZ/wCjl9Z/8Jrw9/8AIdfX9FAHyB/won9pn/o5fWf/AAmvD3/yHXF/Dz9kv44/C3wTo/w+8F/tF6xp2h6FALe0t18PaHKI4wScB57aSQ8k/edj71950UAfIH/Cif2mf+jl9Z/8Jrw9/wDIdH/Cif2mf+jl9Z/8Jrw9/wDIdfX9FAHyB/won9pn/o5fWf8AwmvD3/yHXGRfsl/HCH4hXPxRj/aK1geJLvS4NGkuv+Ee0PLWNvPLcRxeX9m8rAkmdtwQOc4LEAAfeVFAHyB/won9pn/o5fWf/Ca8Pf8AyHR/won9pn/o5fWf/Ca8Pf8AyHX1/RQB8gf8KJ/aZ/6OX1n/AMJrw9/8h1xfi/8AZL+OPjm68OXfiX9ovWLyTwrqkWs6eT4e0NPJvYYZYElHlWyBiEncbXDIc8rkAj7zooA+QP8AhRP7TP8A0cvrP/hNeHv/AJDo/wCFE/tM/wDRy+s/+E14e/8AkOvr+igD5A/4UT+0z/0cvrP/AITXh7/5Do/4UT+0z/0cvrP/AITXh7/5Dr6/ooA+Dfh7+yX8cPhb4K0j4feCf2itY07Q9CgFvaW48PaHKI4wSdoee2kkPJPLOx967P8A4UT+0z/0cvrP/hNeHv8A5Dr6/ooA+QP+FE/tM/8ARy+s/wDhNeHv/kOj/hRP7TP/AEcvrP8A4TXh7/5Dr6/ooA+DPD/7Jfxx8M+KPFPjHR/2i9Yt9W8Yz2txqcw8PaGxnks7ZLSElXtmRdsUar+7VAcZYFsse0/4UT+0z/0cvrP/AITXh7/5Dr6/ooA+QP8AhRP7TP8A0cvrP/hNeHv/AJDo/wCFE/tM/wDRy+s/+E14e/8AkOvr+igD42g/Zj+JmteMPB/iP4pfGvVvGmn+DNXj1u006XR9JsI2vYYJoI2aWzt45MBJ3BXODnpkAj7JoooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9k=" alt="img"></p><p>图中位移为 0、2 和 3 的消息的 Key 都是 K1。Compact 之后，分区只需要保存位移为 3 的消息，因为它是最新发送的。</p><p><strong>Kafka 提供了专门的后台线程定期地巡检待 Compact 的主题，看看是否存在满足条件的可删除数据</strong>。这个后台线程叫 Log Cleaner。很多实际生产环境中都出现过位移主题无限膨胀占用过多磁盘空间的问题，如果的环境中也有这个问题，建议去检查一下 Log Cleaner 线程的状态，通常都是这个线程挂掉了导致的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql 普通索引和唯一索引的区别(change buffer)</title>
    <link href="/2023/09/20/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB(change%20buffer)/"/>
    <url>/2023/09/20/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB(change%20buffer)/</url>
    
    <content type="html"><![CDATA[<p>在不同的业务场景下，应该选择普通索引，还是唯一索引？</p><p>假设维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的 SQL 语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> CUser <span class="hljs-keyword">where</span> id_card = <span class="hljs-string">&#x27;xxxxxxxyyyyyyzzzzz&#x27;</span>;<br></code></pre></td></tr></table></figure><p>所以，你一定会考虑在 id_card 字段上建索引。</p><p>由于身份证号字段比较大，不建议把身份证号当做主键，那么现在有两个选择，要么给 id_card 字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。</p><p>从性能的角度考虑，选择唯一索引还是普通索引呢？选择的依据是什么呢？</p><p><img src="http://learn.lianglianglee.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/assets/1ed9536031d6698570ea175a7b7f9a46-1584367389192.png" alt="img"></p><p>图 1 InnoDB 的索引组织结构</p><p>接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。</p><h5 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h5><p>假设，执行查询的语句是 select id from T where k&#x3D;5。这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k&#x3D;5 条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。</p><p>你知道的，InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</p><p>因为引擎是按页读写的，所以说，当找到 k&#x3D;5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p>当然，如果 k&#x3D;5 这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。</p><p>对于整型字段，一个数据页可以放近千个 key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的 CPU 来说可以忽略不计。</p><h5 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h5><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，需要先介绍一下 change buffer。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p><p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。</p><p>那么，<strong>什么条件下可以使用 change buffer 呢？</strong></p><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k&#x3D;4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p><p>因此，<strong>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</strong></p><p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p><p><strong>如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。</strong></p><p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</li></ul><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p><p>但，这不是我们关注的重点。</p><p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><p>之前我就碰到过一件事儿，有个 DBA 的同学跟我反馈说，他负责的某个业务的库内存命中率突然从 99% 降低到了 75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。</p><h5 id="change-buffer-的使用场景"><a href="#change-buffer-的使用场景" class="headerlink" title="change buffer 的使用场景"></a>change buffer 的使用场景</h5><p>通过上面的分析，你已经清楚了使用 change buffer 对更新过程的加速作用，也清楚了 change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？</p><p>因为 merge 的时候是真正进行数据更新的时刻，<strong>而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</strong></p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p><h5 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h5><p>普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。<strong>所以，尽量选择普通索引。</strong></p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p><p>在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。</p><p>特别地，在使用机械硬盘时，change buffer 这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量使用普通索引，然后把 change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p><h5 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h5><p>假设执行这个插入语句：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">mysql&gt; insert into <span class="hljs-built_in">t</span>(id,k) <span class="hljs-built_in">values</span>(id1,k1),(id2,k2);<br></code></pre></td></tr></table></figure><p>这里，我们假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中。如图 2 所示是带 change buffer 的更新状态图。</p><p><img src="http://learn.lianglianglee.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/assets/980a2b786f0ea7adabef2e64fb4c4ca3-1584367389287.png" alt="img"></p><p>图 2 带 change buffer 的更新过程</p><p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1 在内存中，直接更新内存；</li><li>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</li><li>将上述两个动作记入 redo log 中（图中 3 和 4）。</li></ol><p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p><p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p><p>那在这之后的读请求，要怎么处理呢？</p><p>比如，我们现在要执行 select * from t where k in (k1, k2)。这两个读请求的流程图在下面。</p><p>如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。</p><p><img src="http://learn.lianglianglee.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/assets/6dc743577af1dbcbb8550bddbfc5f98e-1584367389446.png" alt="img"></p><p>图 3 带 change buffer 的读过程</p><p>从图中可以看到：</p><ol><li>读 Page 1 的时候，直接从内存返回。虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</li><li>要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。</li></ol><p>可以看到，直到需要读 Page 2 的时候，这个数据页才会被读入内存。</p><p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，<strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</strong></p><p>通过图 2 可以看到，change buffer 一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？change buffer 丢失可不是小事儿，再从磁盘读入数据可就没有了 merge 过程，就等于是数据丢失了。会不会出现这种情况呢？</p><p>这个问题的答案是不会丢失，虽然是只更新内存，但是在事务提交的时候， change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。那merge 的过程是否会把数据直接写回磁盘？</p><p>merge 的执行流程是这样的：</p><ol><li>从磁盘读入数据页到内存（老版本的数据页）；</li><li>从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；</li><li>写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。</li></ol><p>到这里 merge 过程就结束了。这时候，数据页和内存中 change buffer 对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql InnoDB架构</title>
    <link href="/2023/08/24/mysql%20InnoDB%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/08/24/mysql%20InnoDB%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>在介绍之前先来看看InnoDB的架构图：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20210223_e8f2f28c-75ab-11eb-93b0-5254001c05fe.png" alt="img"></p><p>InnoDB内存结构主要由两部分组成：<strong>Buffer Pool和 Redo LogBuffer。</strong></p><h5 id="1-Buffer-Pool缓冲池作用"><a href="#1-Buffer-Pool缓冲池作用" class="headerlink" title="1.Buffer Pool缓冲池作用"></a>1.Buffer Pool缓冲池作用</h5><p>BufferPool 作为内存中的一块区域，在Innodb访问表的时候会将数据页和索引页缓存到缓冲池中。Innodb不管是主键索引还是辅助索引都是以页为单位存储在磁盘空间中的。</p><p>当Innodb访问某个页的数据时候，会先把这个页整体加载到缓冲池中，然后在进行读写操作。在操作执行完毕后，也不会立即删除将这个页缓冲从缓冲池中删除，而是将它缓存起来，这样当下次再有操作访问这个页时，会直接从缓冲池获取，这样省去了磁盘IO开销，加快了数据访问速度。</p><p>tip：在MySQL专用服务器上，通常将75％以上的物理内存分配给缓冲池，可以通过参数 <strong>innodb_buffer_pool_size</strong>控制缓冲池的大小。因为Buffer Pool中页的大小和数据文件上页大小是一样的，都是16K,而操作系统一次加载数据为4k,所以一般读取时候会将周围数据都取出来，避免重复io,一般认为一个数据被查找，那么它周围数据查找的几率也是很大的</p><p><strong>LRU淘汰策略</strong> 毕竟缓存区大小是有限制的，不能数据一直存放在缓冲区中，所以就涉及到如何高效的清理，那么LRU淘汰算法就出来了，这里简单介绍LRU<strong>（最近经常使用在链表头部，不经常使用在尾部，内存不够的时候删除尾部数据）</strong>，普通的LRU有很多问题，所以mysql中的LRU会做一些更改，一般都会优化下LRU，redis中更不用说了，也是应用了LRU。</p><p>LRU链表（lru）：LRU链表中保存着所有加载到Buffer Pool的数据页和索引页。按照最近最少使用的原则，最近使用的排在链表的头部，最近最少使用排在链表尾部。当Buffer Pool空间没有空闲页可用时，就从LRU链表尾部淘汰一些缓存页，经过淘汰之后，LRU头部就 保存的是热点数据。</p><p>LRU链表不是传统的LRU链表，InnoDB对LRU做了优化，将LRU链表分成了yong区（5&#x2F;8）和old区（3&#x2F;8）。这个比例可以通过参数innodb_old_blocks_pct调节，默认值37，代表old区占比37%。</p><p>young区：存储使用频率非常高的缓存页，这一部分链表也叫做热数据。old区：存储使用频率不是很高的缓存页，所以这一部分链表也叫做冷数据。</p><p>这时因为数据库预读和扫描全表，可以会将使用率不高或者不一定会使用到的页面加载到缓存中。如果将这些页直接插入到LRU链表的头部，热数据就会被排挤到LRU的尾部，就有可能把使用频率非常高的页 淘汰掉，会出现”劣币驱逐良币”的现象。所以当InnoDB将页面读入缓冲池时，它首先将其插入old列表的头部，当下次访问这个页面满足一定条件时在将这个页面插入到yong区的头部。满足一定条件是指：最近一次访问页面时间减去首次访问的时间&lt;某个时间间隔。这个时间间隔可以通过innodb_old_blocks_time 参数控制，默认值1s。即第一次和最后一次访问该页面的时间间隔小于 1s时，才会将这个页面插入到yong区的头部。通过这种机制使得预读机制和全表扫描造成的缓存命中率降低的问题得到了遏制，因为之后用不到的预读页面以及全表扫描的页面都只会被放到old区域，不会影响young区域中的缓存页。</p><p>当Buffer Pool空间不够用时，Buffer Pool会使用LRU算法淘汰最近最少使用的页。在MySQL初始化时会将Buffer Pool划分为若干个缓存页。Buffer Pool中维护着多个链表：空闲页链表（free ）：未使用的缓存页。脏页链表（flush）：发生更改的缓存页。</p><p>在架构图上可以看到，Buffer Pool还分布来两部分区域用于Change Buffer和自适应哈希索引。Buffer Pool对于提升读写性能起到了决定性的作用。当我们需要执行一个insert操作时，如果一个表中存在多个索引，这时就需要更新所有的索引树，如果需要更新的索引页在 Buffer Pool 中存在，这时我们直接更新就可以了。但是如果索引页没有在 Buffer Pool 中就需要从磁盘先加载到内存，再对内存的索引页进行操作。在加上有可能发生页分裂，需要更新的索引页就会更多，会需要进行多次的磁盘IO操作，那有没有优化的方式呢？InnoDB采用了Change Buffer的机制。</p><p><strong>自适应哈希索引</strong> 对于缓冲池中的一些热点索引页，InnoDB为了提高这些页的访问速度，会自动在缓冲池中建立一个自适应Hash索引。自适应哈希索引功能可以使用参数innodb_adaptive_hash_index是否开启，默认开 启。</p><h5 id="2-Change-Buffer作用"><a href="#2-Change-Buffer作用" class="headerlink" title="2.Change Buffer作用"></a>2.Change Buffer作用</h5><p>Change Buffer是一种特殊的数据结构，<strong>是针对二级索引（辅助索引）页的更新优化措施。当二级索引 页不在Buffer Pool中，InnoDB会将对二级索引的数据更改操作先暂时缓存在Change Buffer中，稍后当索引页面因为其他读取操作加载到Buffer Pool的时候，会将这些更改操作合并更新到索引页中</strong>。Change Buffer缓存的更改可能由 Insert 、Delete 和 Update操作导致，这样通过合并操作可以减少二级索引的随机IO。Change Buffer的使用可以有效的提升insert，updte，delete的执行速度。步骤：1.二级索引页的DML操作，并且这个索引页页没有在Buffer Pool内，那么把这个操作存入ChangeBuffer。2.那么下一次需要加载这个页面的时候，索引页被加载到Buffer Pool中。Change Buffer内的更改合并到Buffer Pool。3.随后当服务器在空闲的时候，这个更改会刷到磁盘上。</p><p>什么时候将change buffer更新到buffer pool的索引页？索引页加载到缓存池中时在内存中合并更新。<strong>什么时候将buffer pool的脏页更新到磁盘文件中？redo log写满时</strong>；数据库空闲时，由后台线程；数据库正常关闭时。同样change buffer也会在这三种情况同时被更新到磁盘中。</p><h5 id="三、LogBuffer（Redo-Log）"><a href="#三、LogBuffer（Redo-Log）" class="headerlink" title="三、LogBuffer（Redo Log）"></a>三、LogBuffer（Redo Log）</h5><p>InnoDB存储引擎对数据做修改的时候，会先把数据页从磁盘中读到内存中(buffer pool)中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容 不一致，称这个页为dirty page 脏页。</p><p>如果每次insert，update，delete操作完成后，都立即将脏页刷新到磁盘文件上，而一次更新操作可能需要多次磁盘IO，整个操作的IO成本会很高，更新效率就会很低。所以MySQL会将更新先缓存在内存中，当服务器空闲时才会选择将脏页刷新到磁盘中。但是这就会有个问题，如果在脏页落盘之前如果服务器异常关机或者MySQL崩溃宕机，就会造成脏页这些数据的丢失。为了避免这个问题，InnoDB把对页面的修改操作会同时写入一个日志文件持久化到磁盘上，这样当MySQL崩溃重启后，MySQL就会使用这个日志文件执行恢复操作，将更改重新应用到数据文件，实现了更新操作的持久化。这个日志文件就是Redo Log。</p><p>默认情况下，redo log对应的物理文件位于数据库的数据目录下的ib_logfile1和ib_logfile2。</p><p>可以通过下面的参数控制日志文件的存储文件，数量和大小。这 种 日 志 和 磁 盘 配 合 的 整 个 过 程 ， 其 实 就 是 MySQL 里经常说到的WAL 技 术（Write-Ahead Logging），它的关键点就是在写磁盘前，先写日志。如果每一次的更新操作都写入redo log，磁盘IO成本也是比较高的，所以MySQL在内存中专门开辟了一块区域Log Buffer专门保存将要写入redo log的数据，它的大小可以通过参数 innodb_log_buffer_size控制,默认16M。</p><p>show VARIABLES like ‘innodb_change_buffer_max_size’; #默认值25%，允许在不重新启动服务器的情况下修改设置。set GLOBAL innodb_change_buffer_max_size&#x3D;25</p><p>#指定日志文件所在的路径，默认.&#x2F;，表示在数据库的数据目录下。innodb_log_group_home_dir&#x3D;.&#x2F; #指定重做日志文件组中文件的数量，默认2，表示有两个重做日志文件。#两个文件循环写入，一个写满之后才能开始使用另外一个，一般保持2就可以。innodb_log_files_in_group&#x3D;2 #每个重做日志文件的大小，默认48M。innodb_log_file_size&#x3D;16777216</p><p>这 种 日 志 和 磁 盘 配 合 的 整 个 过 程 ， 其 实 就 是 MySQL 里经常说到的WAL 技 术 （Write-Ahead Logging），它的关键点就是在写磁盘前，先写日志。如果每一次的更新操作都写入redo log，磁盘IO成本也是比较高的，所以MySQL在内存中专门开辟了一块区域Log Buffer专门保存将要写入redo log的数据，它的大小可以通过参数 innodb_log_buffer_size控制,默认16M。</p><h5 id="四、什么时候落盘"><a href="#四、什么时候落盘" class="headerlink" title="四、什么时候落盘"></a>四、什么时候落盘</h5><p>Log Buffer写入磁盘的时机，由参数 innodb_flush_log_at_trx_commit 控制，默认是1，表示事 务提交后立即落盘。用户程序写入数据到磁盘文件时，需要调用操作系统的接口，操作系统本身是有缓冲区的，之后依赖操作系统机制不时的将缓存中刷新到磁盘文件中。用户程序可以执行fsync操作将操作系统缓冲区的数据刷入到磁盘文件中。</p><p>0：MySQL每秒一次将数据从log buffer写入日志文件并同时fsync刷新到磁盘中。每次事务提交时，不会立即把 log buffer 里的数据写入到redo log日志文件的。如果MySQL崩溃或者服务器宕机，此时内存里的数据会全部丢失，最多会丢失1秒的事务。1：每次事务提交时，MySQL将数据从log buffer写入日志文件并同时fsync刷新到磁盘中。该模式为系统默认，<strong>MySQL崩溃已经提交的事务不会丢失，要完全符合ACID，必须使用默认设置1</strong>。2：每次事务提交时，MySQL将数据从log buffer写入日志文件，MySQL每秒执行一次fsync操作 将数据同步到磁盘中。每次事务提交时，都会将数据刷新到操作系统缓冲区，可以认为已经持久化磁盘，如果MySQL崩溃 已经提交的事务不会丢失。但是如果服务器宕机或者意外断电，操作系统缓存内的数据会丢失，所 以最多丢失1秒的事务。</p><p>只有设置为1是最安全但是性能消耗的方式，可以真正地保证事务的持久性，但是由于MySQL执行刷新操作 fsync() 是阻塞的，直到完成后才会返回，我们知道写磁盘的速度是很慢的，因此 MySQL 的性能 会明显地下降。0和2的性能最好的模式，综合安全性和性能的考虑，在业务中经常使用的2这种模式，在MySQL异 常重启时不会丢失数据，只有在服务器意外宕机时才会丢失1秒的数据，这种情况几率是很低的， 相对于性能来说，这时可以容忍的。</p><h5 id="五、为什么使用redo-log"><a href="#五、为什么使用redo-log" class="headerlink" title="五、为什么使用redo log"></a>五、为什么使用redo log</h5><p>日志文件也是磁盘文件，为什么不直接更新到数据文件中，而是要先更新到redo log中呢？如果事务提交时，我们需要更新的数据是分散在不同页不同扇区中的，更新数据时需要根据磁盘地址找 到对应的磁道，然后再找到对应的扇区，才能写入数据，这个时间一般需要10ms。一次事务提交的数据 需要多次的磁盘IO交互才能完成，这个是随机IO，读取和写入速度比较慢。而redo log文件是在磁盘中一块连续的区域，<strong>事务提交时</strong>，写入redo log时，我们只要找到找到第一 块扇区，只需要依次向后写入就行，也就是说只需要执行一次磁盘IO操作，这就是顺序IO。<strong>脏页落盘是随机IO，记录日志是顺序IO</strong>，通过使用WAL技术，先将更改操作记录在日志文件中，延迟落 盘，可以提高系统性能。需要注意的是，redo log主要用于崩溃恢复。磁盘中数据文件的数据的更新，仍旧来自于 buffer pool中的脏页落盘。redo log的特点</p><p>1.redo log 是InnoDB存储引擎层产生的，其他存储引擎没有。2.redo log是物理日志，记录的是“某个数据页上的数据做了什么修改”。3.redo log的文件数和大小是固定的，redo一个文件写满后会切换到下一个文件。从第一个文件开 始写，写到最后一个文件就又会回到第一个文件开始循环写。当系统空闲时或者redolog写满时，MySQL会将将redo log前面的数据擦除，对应的数据修改会被同步 到数据文件中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka的 groupid 与 auto.offset.reset</title>
    <link href="/2023/08/11/kafka%E7%9A%84%20groupid%20%E4%B8%8E%20auto.offset.reset/"/>
    <url>/2023/08/11/kafka%E7%9A%84%20groupid%20%E4%B8%8E%20auto.offset.reset/</url>
    
    <content type="html"><![CDATA[<p>通常我们消费kafka数据的时候都会设置两个参数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">Properties props = new Properties();<br>props.put(&quot;group.id&quot;, groupId);<br>props.put(&quot;auto.offset.reset&quot;, autoOffset);<br></code></pre></td></tr></table></figure><ul><li>kafka-0.10.1.X版本之前: auto.offset.reset 的值为 smallest 和 largest.(offest保存在zk中)</li><li>kafka-0.10.1.X版本之后: auto.offset.reset 的值更改为:earliest, latest 和 none (offest保存在kafka的一个特殊的topic名为:__consumer_offsets里面)</li></ul><h5 id="参数解读："><a href="#参数解读：" class="headerlink" title="参数解读："></a>参数解读：</h5><p>auto.offset.reset： 可理解为kafka consumer读取数据的策略，本地用的kafka版本为0.10，因此该参数可填earliest | latest | none。</p><ul><li>earliest： 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费</li><li>latest： 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据</li><li>none： topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常</li></ul><h5 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h5><h5 id="场景一："><a href="#场景一：" class="headerlink" title="场景一："></a>场景一：</h5><p>Kafka上在实时被灌入数据，但kafka上已经积累了两天的数据，如何从最新的offset开始消费？（最新指相对于当前系统时间最新）</p><blockquote><p>1.将group.id换成新的名字(相当于加入新的消费组)<br>2.网上文章写还要设置 properties.setProperty(“auto.offset.reset”, “latest”)<br>实验发现即使不设置这个，只要group.id是全新的，就会从最新的的offset开始消费</p></blockquote><h5 id="场景二："><a href="#场景二：" class="headerlink" title="场景二："></a>场景二：</h5><p>kafka在实时在灌入数据，kafka上已经积累了两天的数据，如何从两天前最开始的位置消费？</p><blockquote><p>1.将group.id换成新的名字<br>2.properties.setProperty(“auto.offset.reset”, “earliest”)</p></blockquote><h5 id="场景三："><a href="#场景三：" class="headerlink" title="场景三："></a>场景三：</h5><p>不更改group.id，只是添加了properties.setProperty(“auto.offset.reset”, “earliest”)，consumer会从两天前最开始的位置消费吗？</p><blockquote><p>不会，只要不更改消费组，只会从上次消费结束的地方继续消费</p></blockquote><h5 id="场景四："><a href="#场景四：" class="headerlink" title="场景四："></a>场景四：</h5><p>不更改group.id，只是添加了properties.setProperty(“auto.offset.reset”, “latest”)，consumer会从距离现在最近的位置消费吗？</p><blockquote><p>不会，只要不更改消费组，只会从上次消费结束的地方继续消费</p></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>auto.offset.rese参数一般只作用于新增加消费者组时。</p>]]></content>
    
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka消费者组重平衡能避免吗</title>
    <link href="/2023/08/08/%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E9%87%8D%E5%B9%B3%E8%A1%A1%E8%83%BD%E9%81%BF%E5%85%8D%E5%90%97/"/>
    <url>/2023/08/08/%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E9%87%8D%E5%B9%B3%E8%A1%A1%E8%83%BD%E9%81%BF%E5%85%8D%E5%90%97/</url>
    
    <content type="html"><![CDATA[<p>消费者组重平衡能避免吗?</p><p>重平衡，也就是 Rebalance， 就是让一个 Consumer Group 下所有的 Consumer 实例就如何消费订阅主题的所有分区达成共识的过程。在 Rebalance 过程中，所有 Consumer 实例共同参与，在协调者组件的帮助下，完成订阅主题分区的分配。但是，在整个过程中，所有实例都不能消费任何消息，因此它对 Consumer 的 TPS 影响很大。</p><p>所谓协调者，在 Kafka 中对应的术语是 Coordinator，它专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等。</p><p>具体来讲，Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。</p><p>所有 Broker 在启动时，都会创建和开启相应的 Coordinator 组件。也就是说，<strong>所有 Broker 都有各自的 Coordinator 组件</strong>。那么，Consumer Group 如何确定为它服务的 Coordinator 在哪台 Broker 上呢？答案就在之前说过的 Kafka 内部位移主题 __consumer_offsets 身上。</p><p>目前，Kafka 为某个 Consumer Group 确定 Coordinator 所在的 Broker 的算法有 2 个步骤。</p><p>第 1 步：确定由位移主题的哪个分区来保存该 Group 数据：partitionId&#x3D;Math.abs(groupId.hashCode() % offsetsTopicPartitionCount)。</p><p>第 2 步：找出该分区 Leader 副本所在的 Broker，该 Broker 即为对应的 Coordinator。</p><p>简单解释一下上面的算法。首先，Kafka 会计算该 Group 的 group.id 参数的哈希值。比如有个 Group 的 group.id 设置成了“test-group”，那么它的 hashCode 值就应该是 627841412。其次，Kafka 会计算 __consumer_offsets 的分区数，通常是 50 个分区，之后将刚才那个哈希值对分区数进行取模加求绝对值计算，即 abs(627841412 % 50) &#x3D; 12。此时，就知道了位移主题的分区 12 负责保存这个 Group 的数据。有了分区号，算法的第 2 步就变得很简单了，只需要找出位移主题分区 12 的 Leader 副本在哪个 Broker 上就可以了。这个 Broker，就是要找的 Coordinator。</p><p>在实际使用过程中，Consumer 应用程序，特别是 Java Consumer API，能够自动发现并连接正确的 Coordinator，不用操心这个问题。知晓这个算法的最大意义在于，它能够帮助解决<strong>定位问题</strong>。当 Consumer Group 出现问题，需要快速排查 Broker 端日志时，能够根据这个算法准确定位 Coordinator 对应的 Broker，不必一台 Broker 一台 Broker 地盲查。</p><p>Rebalance 的弊端是什么呢？总结起来有以下 3 点：</p><ol><li>Rebalance 影响 Consumer 端 TPS。在 Rebalance 期间，Consumer 会停下手头的事情，什么也干不了。</li><li>Rebalance 很慢。如果的 Group 下成员很多，就一定会有这样的痛点。</li><li>Rebalance 效率不高。当前 Kafka 的设计机制决定了每次 Rebalance 时，Group 下的所有成员都要参与进来，而且通常不会考虑局部性原理，但局部性原理对提升系统性能是特别重要的。</li></ol><p><strong>在真实的业务场景中，很多 Rebalance 都是计划外的或者说是不必要的</strong>。应用的 TPS 大多是被这类 Rebalance 拖慢的，因此避免这类 Rebalance 就显得很有必要了。下面就来说说如何避免 Rebalance。</p><p>要避免 Rebalance，还是要从 Rebalance 发生的时机入手。Rebalance 发生的时机有三个：</p><ul><li><strong>组成员数量发生变化</strong></li><li><strong>订阅主题数量发生变化</strong></li><li><strong>订阅主题的分区数发生变化</strong></li></ul><p>后面两个通常都是运维的主动操作，所以它们引发的 Rebalance 大都是不可避免的。主要说说因为<strong>组成员数量变化</strong>而引发的 Rebalance 该如何避免。</p><p>如果 Consumer Group 下的 Consumer 实例数量发生变化，就一定会引发 Rebalance。这是 Rebalance 发生的最常见的原因。 99% 的 Rebalance，都是这个原因导致的。</p><p>Consumer 实例增加的情况很好理解，当启动一个配置有相同 group.id 值的 Consumer 程序时，实际上就向这个 Group 添加了一个新的 Consumer 实例。此时，Coordinator 会接纳这个新实例，将其加入到组中，并重新分配分区。通常来说，增加 Consumer 实例的操作都是计划内的，可能是出于增加 TPS 或提高伸缩性的需要。总之，它不属于要规避的那类“不必要 Rebalance”。</p><p>更在意的是 Group 下实例数减少这件事。如果就是要停掉某些 Consumer 实例，那自不必说，关键是在某些情况下，Consumer 实例会被 Coordinator 错误地认为“已停止”从而被“踢出”Group。如果是这个原因导致的 Rebalance，就不能不管了。</p><p>Coordinator 会在什么情况下认为某个 Consumer 实例已挂从而要退组呢？</p><p>当 Consumer Group 完成 Rebalance 之后，每个 Consumer 实例都会定期地向 Coordinator 发送心跳请求，表明它还存活着。如果某个 Consumer 实例不能及时地发送这些心跳请求，Coordinator 就会认为该 Consumer 已经“死”了，从而将其从 Group 中移除，然后开启新一轮 Rebalance。Consumer 端有个参数，叫 session.timeout.ms，就是被用来表征此事的。该参数的默认值是 10 秒，即如果 Coordinator 在 10 秒之内没有收到 Group 下某 Consumer 实例的心跳，它就会认为这个 Consumer 实例已经挂了。可以这么说，session.timout.ms 决定了 Consumer 存活性的时间间隔。</p><p>除了这个参数，Consumer 还提供了一个允许控制发送心跳请求频率的参数，就是 heartbeat.interval.ms。这个值设置得越小，Consumer 实例发送心跳请求的频率就越高。频繁地发送心跳请求会额外消耗带宽资源，但好处是能够更加快速地知晓当前是否开启 Rebalance，因为，<strong>目前 Coordinator 通知各个 Consumer 实例开启 Rebalance 的方法，就是将 REBALANCE_NEEDED 标志封装进心跳请求的响应体中</strong>。</p><p>除了以上两个参数，Consumer 端还有一个参数，用于控制 Consumer 实际消费能力对 Rebalance 的影响，即 max.poll.interval.ms 参数。它限定了 Consumer 端应用程序两次调用 poll 方法的最大时间间隔。它的默认值是 5 分钟，表示的 Consumer 程序如果在 5 分钟之内无法消费完 poll 方法返回的消息，那么 Consumer 会主动发起“离开组”的请求，Coordinator 也会开启新一轮 Rebalance。</p><p>搞清楚了这些参数的含义，接下来来明确一下到底哪些 Rebalance 是“不必要的”。</p><p><strong>第一类非必要 Rebalance 是因为未能及时发送心跳，导致 Consumer 被“踢出”Group 而引发的</strong>。因此，需要仔细地设置<strong>session.timeout.ms 和 heartbeat.interval.ms</strong>的值。我在这里给出一些推荐数值，可以“无脑”地应用在的生产环境中。</p><ul><li>设置 session.timeout.ms &#x3D; 6s。</li><li>设置 heartbeat.interval.ms &#x3D; 2s。</li><li>要保证 Consumer 实例在被判定为“dead”之前，能够发送至少 3 轮的心跳请求，即 session.timeout.ms &gt;&#x3D; 3 * heartbeat.interval.ms。</li></ul><p>将 session.timeout.ms 设置成 6s 主要是为了让 Coordinator 能够更快地定位已经挂掉的 Consumer。毕竟，还是希望能尽快揪出那些“尸位素餐”的 Consumer，早日把它们踢出 Group。希望这份配置能够较好地帮助规避第一类“不必要”的 Rebalance。</p><p><strong>第二类非必要 Rebalance 是 Consumer 消费时间过长导致的</strong>。之前有一个客户，在他们的场景中，Consumer 消费数据时需要将消息处理之后写入到 MongoDB。显然，这是一个很重的消费逻辑。MongoDB 的一丁点不稳定都会导致 Consumer 程序消费时长的增加。此时，<strong>max.poll.interval.ms</strong>参数值的设置显得尤为关键。如果要避免非预期的 Rebalance，最好将该参数值设置得大一点，比的下游最大处理时间稍长一点。就拿 MongoDB 这个例子来说，如果写 MongoDB 的最长时间是 7 分钟，那么可以将该参数设置为 8 分钟左右。</p><p>总之，要为的业务处理逻辑留下充足的时间。这样，Consumer 就不会因为处理这些消息的时间太长而引发 Rebalance 了。</p><p>如果按照上面的推荐数值恰当地设置了这几个参数，却发现还是出现了 Rebalance，那么建议去排查一下<strong>Consumer 端的 GC 表现</strong>，比如是否出现了频繁的 Full GC 导致的长时间停顿，从而引发了 Rebalance。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>总而言之，一定要避免因为各种参数或逻辑不合理而导致的组成员意外离组或退出的情形，与之相关的主要参数有：</p><ul><li>session.timeout.ms</li><li>heartbeat.interval.ms</li><li>max.poll.interval.ms</li><li>GC 参数</li></ul><p>恰当地设置这些参数，一定能够大幅度地降低生产环境中的 Rebalance 数量，从而整体提升 Consumer 端 TPS。</p>]]></content>
    
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql三大日志</title>
    <link href="/2023/06/12/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/"/>
    <url>/2023/06/12/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p>日志是 <code>mysql </code>数据库的重要组成部分，记录着数据库运行期间各种状态信息。 <code>mysql</code><br>日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。作为开发，我们重点需要关注的是二进制日志( <code>binlog </code>)和事务日志(包括<code>redo log </code>和 <code>undo log </code>)，本文接下来会详细介绍这三种日志。</p><h5 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h5><p><code>binlog </code>用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。 <code>binlog </code>是 <code>mysql</code><br>的逻辑日志，并且由 <code>Server </code>层进行记录，使用任何存储引擎的 <code>mysql </code>数据库都会记录 <code>binlog </code>日志。</p><ul><li><strong>逻辑日志</strong>： 可以简单理解为记录的就是sql语句 。</li><li><strong>物理日志</strong>： <code>mysql </code>数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。</li></ul><p><code>binlog </code>是通过追加的方式进行写入的，可以通过 <code>max_binlog_size </code>参数设置每个 <code>binlog</code><br>文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p><h5 id="binlog使用场景"><a href="#binlog使用场景" class="headerlink" title="binlog使用场景"></a>binlog使用场景</h5><p>在实际应用中， <code>binlog </code>的主要使用场景有两个，分别是 <strong>主从复制</strong> 和 <strong>数据恢复</strong> 。</p><ol><li><strong>主从复制</strong> ：在 <code>Master </code>端开启 <code>binlog </code>，然后将 <code>binlog </code>发送到各个 <code>Slave </code>端， <code>Slave </code>端重放 <code>binlog </code>从而达到主从数据一致。</li><li><strong>数据恢复</strong> ：通过使用 <code>mysqlbinlog </code>工具来恢复数据。</li></ol><h5 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h5><p>对于 <code>InnoDB </code>存储引擎而言，只有在事务提交时才会记录 <code>biglog </code>，此时记录还在内存中，那么 <code>biglog</code><br>是什么时候刷到磁盘中的呢？ <code>mysql </code>通过 <code>sync_binlog </code>参数控制 <code>biglog </code>的刷盘时机，取值范围是 <code>0-N</code><br>：</p><ul><li>0：不去强制要求，由系统自行判断何时写入磁盘；</li><li>1：每次 <code>commit </code>的时候都要将 <code>binlog </code>写入磁盘；</li><li>N：每N个事务，才会将 <code>binlog </code>写入磁盘。</li></ul><p>从上面可以看出， <code>sync_binlog </code>最安全的是设置是 <code>1 </code>，这也是 <code>MySQL 5.7.7</code><br>之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p><h5 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h5><p><code>binlog </code>日志有三种格式，分别为 <code>STATMENT </code>、 <code>ROW </code>和 <code>MIXED </code>。</p><blockquote><p>在 <code>MySQL 5.7.7 </code>之前，默认的格式是 <code>STATEMENT </code>， <code>MySQL 5.7.7 </code>之后，默认值是 <code>ROW </code>。日志格式通过 <code>binlog-format </code>指定。</p></blockquote><ul><li><p><code>STATMENT </code>： 基于<code>SQL</code>语句的复制( <code>statement-based replication, SBR </code>)，每一条会修改数据的sql语句会记录到 <code>binlog </code>中 。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">* 优点： 不需要记录每一行的变化，减少了` binlog ` 日志量，节约了 ` IO ` , 从而提高了性能； <br>* 缺点： 在某些情况下会导致主从数据不一致，比如执行` sysdate() ` 、 ` slepp() ` 等 。 <br></code></pre></td></tr></table></figure></li><li><p><code>ROW </code>： 基于行的复制(<code>row-based replication, RBR</code>)，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了 。</p><ul><li>优点： 不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题 ；</li><li>缺点： 会产生大量的日志，尤其是<code>alter table</code>的时候会让日志暴涨</li></ul></li><li><p><code>MIXED </code>： 基于<code>STATMENT</code>和 <code>ROW </code>两种模式的混合复制( <code>mixed-based replication, MBR </code>)，一般的复制使用 <code>STATEMENT </code>模式保存 <code>binlog </code>，对于 <code>STATEMENT </code>模式无法复制的操作使用 <code>ROW </code>模式保存 <code>binlog</code></p></li></ul><h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><h5 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a>为什么需要redo log</h5><p>我们都知道，事务的四大特性里面有一个是 <strong>持久性</strong> ，具体来说就是<br><strong>只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态</strong> 。那么 <code>mysql</code><br>是如何保证一致性的呢？最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：</p><ol><li>因为 <code>Innodb </code>是以 <code>页 </code>为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li><li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！</li></ol><p>因此 <code>mysql </code>设计了 <code>redo log </code>， <strong>具体来说就是只记录事务对数据页做了哪些修改</strong><br>，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。</p><h5 id="redo-log基本概念"><a href="#redo-log基本概念" class="headerlink" title="redo log基本概念"></a>redo log基本概念</h5><p><code>redo log </code>包括两部分：**一个是内存中的日志缓冲( <code>redo log buffer </code>)，另一个是磁盘上的日志文件( <code>redo log file</code>)**。 <code>mysql </code>每执行一条 <code>DML </code>语句，先将记录写入 <code>redo log buffer </code><br>，后续某个时间点再一次性将多个操作记录写到 <code>redo log file </code>。这种 <strong>先写日志，再写磁盘</strong> 的技术就是 <code>MySQL</code><br>里经常说到的 <code>WAL(Write-Ahead Logging) </code>技术。</p><p>在计算机操作系统中，用户空间( <code>user space </code>)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间( <code>kernel space</code>)缓冲区( <code>OS Buffer </code>)。因此， <code>redo log buffer </code>写入 <code>redo log file </code>实际上是先写入 <code>OS Buffer </code>，然后再通过系统调用 <code>fsync() </code>将其刷到 <code>redo log file </code><br>中，过程如下：</p><p><img src="https://segmentfault.com/img/remote/1460000023827701" alt="img"></p><p><code>mysql </code>支持三种将 <code>redo log buffer </code>写入 <code>redo log file </code>的时机，可以通过 <code>innodb_flush_log_at_trx_commit</code> 参数配置，各参数值含义如下：</p><table><thead><tr><th>参数值</th><th>含义</th></tr></thead><tbody><tr><td>0（延迟写）</td><td>事务提交时不会将 <code>redo log buffer </code>中日志写入到 <code>os buffer </code>，而是每秒写入 <code>os buffer </code>并调用 <code>fsync() </code>写入到 <code>redo log file </code>中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</td></tr><tr><td>1（实时写，实时刷）</td><td>事务每次提交都会将 <code>redo log buffer </code>中的日志写入 <code>os buffer </code>并调用 <code>fsync() </code>刷到 <code>redo log file </code>中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。</td></tr><tr><td>2（实时写，延迟刷）</td><td>每次提交都仅写入到 <code>os buffer </code>，然后是每秒调用 <code>fsync() </code>将 <code>os buffer </code>中的日志写入到 <code>redo log file </code>。</td></tr></tbody></table><p><img src="https://segmentfault.com/img/remote/1460000023827700" alt="img"></p><h5 id="redo-log记录形式"><a href="#redo-log记录形式" class="headerlink" title="redo log记录形式"></a>redo log记录形式</h5><p>前面说过， <code>redo log </code>实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此 <code>redo log</code><br>实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。如下图：</p><p><img src="https://segmentfault.com/img/remote/1460000023827699" alt="img"></p><p>同时我们很容易得知， 在innodb中，既有<code>redo log</code>需要刷盘，还有 <code>数据页 </code>也需要刷盘， <code>redo log </code>存在的意义主要就是降低对 <code>数据页 </code>刷盘的要求 <strong>。在上图中， <code>write pos </code>表示 <code>redo log </code>当前记录的 <code>LSN</code> (逻辑序列号)位置， <code>check point </code>表示</strong> 数据页更改记录** 刷盘后对应 <code>redo log </code>所处的 <code>LSN </code>(逻辑序列号)位置。 <code>write pos </code>到 <code>check point </code>之间的部分是 <code>redo log </code>空着的部分，用于记录新的记录；<code>check point</code>到 <code>write pos </code>之间是 <code>redo log </code>待落盘的数据页更改记录。当 <code>write pos </code>追上 <code>check point </code>时，会先推动 <code>check point </code>向前移动，空出位置再记录新的日志。</p><p>启动 <code>innodb </code>的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为 <code>redo log </code>记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如 <code>binlog </code>)要快很多。 重启 <code>innodb </code>时，首先会检查磁盘中数据页的 <code>LSN </code>，如果数据页的 <code>LSN </code>小于日志中的 <code>LSN </code>，则会从 <code>checkpoint </code>开始恢复。 还有一种情况，在宕机前正处于<br><code>checkpoint </code>的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 <code>LSN </code>大于日志中的 <code>LSN</code><br>，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</p><h5 id="redo-log与binlog区别"><a href="#redo-log与binlog区别" class="headerlink" title="redo log与binlog区别"></a>redo log与binlog区别</h5><table><thead><tr><th></th><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>文件大小</td><td><code>redo log </code>的大小是固定的。</td><td><code>binlog </code>可通过配置参数 <code>max_binlog_size </code>设置每个<code>binlog</code>文件的大小。</td></tr><tr><td>实现方式</td><td><code>redo log </code>是 <code>InnoDB </code>引擎层实现的，并不是所有引擎都有。</td><td><code>binlog </code>是 <code>Server</code> 层实现的，所有引擎都可以使用 <code>binlog </code>日志</td></tr><tr><td>记录方式</td><td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td><td>binlog通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td></tr><tr><td>适用场景</td><td><code>redo log </code>适用于崩溃恢复(crash-safe)</td><td><code>binlog </code>适用于主从复制和数据恢复</td></tr></tbody></table><p>由 <code>binlog </code>和 <code>redo log </code>的区别可知： <code>binlog </code>日志只用于归档，只依靠 <code>binlog </code>是没有 <code>crash-safe</code>能力的。但只有 <code>redo log </code>也不行，因为 <code>redo log </code>是 <code>InnoDB </code><br>特有的，且日志上的记录落盘后会被覆盖掉。因此需要 <code>binlog </code>和 <code>redo log</code><br>二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p><h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>数据库事务四大特性中有一个是 <strong>原子性</strong> ，具体来说就是 <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。实际上， <strong>原子性</strong> 底层就是通过 <code>undo log </code>实现的。 <code>undo log </code>主要记录了数据的逻辑变化，比如一条 <code>INSERT</code>语句，对应一条 <code>DELETE </code>的 <code>undo log </code>，对于每个 <code>UPDATE </code>语句，对应一条相反的 <code>UPDATE </code>的<code>undo log</code>，这样在发生错误时，就能回滚到事务之前的数据状态。同时， <code>undo log </code>也是 <code>MVCC </code>(多版本并发控制)实现的关键</p><p>在MySQL中，undo log是用于实现事务的回滚和MVCC（多版本并发控制）的重要组件。<strong>它并不是在buffer pool（缓冲池）里面，而是在InnoDB存储引擎的表空间中。</strong></p><p>Buffer pool是用于缓存数据库的数据页的内存区域，其主要作用是减少磁盘I&#x2F;O操作，提高数据库的性能。而undo log则是用于记录事务对数据的修改操作，以便实现事务的原子性、一致性和隔离性，并支持数据库的并发访问。</p><p>在InnoDB存储引擎中，undo log通常位于表空间中的undo表空间中，其中记录了事务对数据的修改操作，包括修改前的数据和修改后的数据。这些信息可以用于回滚事务或者提供给其他事务的读操作，从而实现了数据库的多版本并发控制。</p><p>因此，undo log和buffer pool虽然都是InnoDB存储引擎的组成部分，但它们的作用和存储位置是不同的。buffer pool用于缓存数据库的数据页，而undo log用于记录事务的修改操作，实现事务的一致性和并发控制。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql双1设置</title>
    <link href="/2023/03/21/mysql%E5%8F%8C1/"/>
    <url>/2023/03/21/mysql%E5%8F%8C1/</url>
    
    <content type="html"><![CDATA[<p><code>innodb_flush_log_at_trx_commit</code> 和 <code>sync_binlog</code> 是 MySQL 的两个配置参数，前者是 InnoDB 引擎特有的。之所以把这两个参数放在一起讨论，是因为在实际应用中，它们的配置对于 MySQL 的性能有很大影响。</p><h5 id="1-innodb-flush-log-at-trx-commit"><a href="#1-innodb-flush-log-at-trx-commit" class="headerlink" title="1. innodb_flush_log_at_trx_commit"></a>1. innodb_flush_log_at_trx_commit</h5><p>简而言之，<a href="http://dev.mysql.com/doc/refman/4.1/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit"><code>innodb_flush_log_at_trx_commit</code></a> 参数指定了 InnoDB 在事务提交后的日志写入频率。这么说其实并不严谨，且看其不同取值的意义和表现。</p><ol><li>当 <code>innodb_flush_log_at_trx_commit</code> 取值为 <code>0</code> 的时候，log buffer 会 每秒写入到日志文件并刷写（flush）到磁盘。但每次事务提交不会有任何影响，也就是 log buffer 的刷写操作和事务提交操作没有关系。在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。</li><li>当取值为 <code>1</code> 时，每次事务提交时，log buffer 会被写入到日志文件并刷写到磁盘。这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I&#x2F;O，所以也最慢。</li><li>当取值为 <code>2</code> 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。</li></ol><p>上面说到的「最后 1s」并不是绝对的，有的时候会丢失更多数据。有时候由于调度的问题，每秒刷写（once-per-second flushing）并不能保证 100% 执行。对于一些数据一致性和完整性要求不高的应用，配置为 <code>2</code> 就足够了；如果为了最高性能，可以设置为 <code>0</code>。有些应用，如支付服务，对一致性和完整性要求很高，所以即使最慢，也最好设置为 <code>1</code>.</p><h5 id="2-sync-binlog"><a href="#2-sync-binlog" class="headerlink" title="2. sync_binlog"></a>2. sync_binlog</h5><p><a href="https://dev.mysql.com/doc/refman/5.5/en/replication-options-binary-log.html#sysvar_sync_binlog">sync_binlog</a> 是 MySQL 的二进制日志（binary log）同步到磁盘的频率。MySQL server 在 binary log 每写入 <code>sync_binlog</code> 次后，刷写到磁盘。</p><p>如果 <code>autocommit</code> 开启，每个语句都写一次 binary log，否则每次事务写一次。默认值是 <code>0</code>，不主动同步，而依赖操作系统本身不定期把文件内容 flush 到磁盘。设为 <code>1</code> 最安全，在每个语句或事务后同步一次 binary log，即使在崩溃时也最多丢失一个语句或事务的日志，但因此也最慢。</p><p>大多数情况下，对数据的一致性并没有很严格的要求，所以并不会把 <code>sync_binlog</code> 配置成 <code>1</code>. 为了追求高并发，提升性能，可以设置为 <code>100</code> 或直接用 <code>0</code>. 而和 <code>innodb_flush_log_at_trx_commit</code> 一样，对于支付服务这样的应用，还是比较推荐 <code>sync_binlog = 1</code>.</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql分区表</title>
    <link href="/2023/03/13/mysql%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    <url>/2023/03/13/mysql%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>分区表有什么问题，为什么公司规范不让使用分区表呢？ </p><h5 id="分区表是什么？"><a href="#分区表是什么？" class="headerlink" title="分区表是什么？"></a>分区表是什么？</h5><p>为了说明分区表的组织形式，我先创建一个表 t：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `ftime` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `c` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  KEY (`ftime`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>latin1<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (<span class="hljs-keyword">YEAR</span>(ftime))<br>(<span class="hljs-keyword">PARTITION</span> p_2017 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2017</span>) ENGINE <span class="hljs-operator">=</span> InnoDB,<br> <span class="hljs-keyword">PARTITION</span> p_2018 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2018</span>) ENGINE <span class="hljs-operator">=</span> InnoDB,<br> <span class="hljs-keyword">PARTITION</span> p_2019 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2019</span>) ENGINE <span class="hljs-operator">=</span> InnoDB,<br><span class="hljs-keyword">PARTITION</span> p_others <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE ENGINE <span class="hljs-operator">=</span> InnoDB);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;2017-4-1&#x27;</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">&#x27;2018-4-1&#x27;</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/06f041129783533de9c75580f9decdf5.png" alt="img"></p><p>图 1 表 t 的磁盘文件</p><p>我在表 t 中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在 p_2018 和 p_2019 这两个分区上。</p><p>可以看到，这个表包含了一个.frm 文件和 4 个.ibd 文件，每个分区对应一个.ibd 文件。也就是说：</p><ul><li>对于引擎层来说，这是 4 个表；</li><li>对于 Server 层来说，这是 1 个表。</li></ul><h5 id="分区表的引擎层行为"><a href="#分区表的引擎层行为" class="headerlink" title="分区表的引擎层行为"></a>分区表的引擎层行为</h5><p>我先给你举个在分区表加间隙锁的例子，目的是说明对于 InnoDB 来说，这是 4 个表。</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/d28d6ab873bd8337d88812d45b9266c7.png" alt="img"></p><p>图 2 分区表间隙锁示例</p><p>这里顺便复习一下，我在[第 21 篇文章]和你介绍的间隙锁加锁规则。</p><p>我们初始化表 t 的时候，只插入了两行数据， ftime 的值分别是，‘2017-4-1’ 和’2018-4-1’ 。session A 的 select 语句对索引 ftime 上这两个记录之间的间隙加了锁。如果是一个普通表的话，那么 T1 时刻，在表 t 的 ftime 索引上，间隙和加锁状态应该是图 3 这样的。</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/273c9ca869f5b52621641d73eb6f72d2.jpg" alt="img"></p><p>图 3 普通表的加锁范围</p><p>也就是说，‘2017-4-1’ 和’2018-4-1’ 这两个记录之间的间隙是会被锁住的。那么，sesion B 的两条插入语句应该都要进入锁等待状态。</p><p>但是，从上面的实验效果可以看出，session B 的第一个 insert 语句是可以执行成功的。这是因为，对于引擎来说，p_2018 和 p_2019 是两个不同的表，也就是说 2017-4-1 的下一个记录并不是 2018-4-1，而是 p_2018 分区的 supremum。所以 T1 时刻，在表 t 的 ftime 索引上，间隙和加锁的状态其实是图 4 这样的：</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/92f63aba0b24adefac7316c75463b95c.jpg" alt="img"></p><p>图 4 分区表 t 的加锁范围</p><p>由于分区表的规则，session A 的 select 语句其实只操作了分区 p_2018，因此加锁范围就是图 4 中深绿色的部分。</p><p>所以，session B 要写入一行 ftime 是 2018-2-1 的时候是可以成功的，而要写入 2017-12-1 这个记录，就要等 session A 的间隙锁。</p><p>图 5 就是这时候的 show engine innodb status 的部分结果。</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/e3d83d9ba89de9a6f541c9a2f24a3b0f.png" alt="img"></p><p>图 5 session B 被锁住信息</p><p>看完 InnoDB 引擎的例子，我们再来一个 MyISAM 分区表的例子。</p><p>我首先用 alter table t engine&#x3D;myisam，把表 t 改成 MyISAM 表；然后，我再用下面这个例子说明，对于 MyISAM 引擎来说，这是 4 个表。</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/941306d4a7193455dcf1cfebf7678876.png" alt="img"></p><p>图 6 用 MyISAM 表锁验证</p><p>在 session A 里面，我用 sleep(100) 将这条语句的执行时间设置为 100 秒。由于 MyISAM 引擎只支持表锁，所以这条 update 语句会锁住整个表 t 上的读。</p><p>但我们看到的结果是，session B 的第一条查询语句是可以正常执行的，第二条语句才进入锁等待状态。</p><p>这正是因为 MyISAM 的表锁是在引擎层实现的，session A 加的表锁，其实是锁在分区 p_2018 上。因此，只会堵住在这个分区上执行的查询，落到其他分区的查询是不受影响的。</p><p>看到这里，你可能会说，分区表看来还不错嘛，为什么不让用呢？我们使用分区表的一个重要原因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式。</p><p>接下来，我们一起看看手动分表和分区表有什么区别。</p><p>比如，按照年份来划分，我们就分别创建普通表 t_2017、t_2018、t_2019 等等。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新。在性能上，这和分区表并没有实质的差别。</p><p>分区表和手工分表，<strong>一个是由 server 层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。</strong></p><p>其实这两个方案的区别，主要是在 server 层上。从 server 层看，我们就不得不提到分区表一个被广为诟病的问题：打开表的行为。</p><h5 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h5><p>每当第一次访问一个分区表的时候，MySQL 需要把所有的分区都访问一遍。<strong>一个典型的报错情况</strong>是这样的：如果一个分区表的分区很多，比如超过了 1000 个，而 MySQL 启动的时候，open_files_limit 参数使用的是默认值 1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。</p><p>下图就是我创建的一个包含了很多分区的表 t_myisam，执行一条插入语句后报错的情况。</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/abfa0054ec43d97fb18ba3c1c8829ae7.png" alt="img"></p><p>图 7 insert 语句报错</p><p>可以看到，这条 insert 语句，明显只需要访问一个分区，但语句却无法执行。</p><p>这时，你一定从表名猜到了，这个表我用的是 MyISAM 引擎。是的，因为使用 InnoDB 引擎的话，并不会出现这个问题。</p><p>MyISAM 分区表使用的分区策略，我们称为<strong>通用分区策略</strong>（generic partitioning），每次访问分区都由 server 层控制。通用分区策略，是 MySQL 一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。</p><p>从 MySQL 5.7.9 开始，InnoDB 引擎引入了<strong>本地分区策略</strong>（native partitioning）。这个策略是在 InnoDB 内部自己管理打开分区的行为。</p><p>MySQL 从 5.7.17 开始，将 MyISAM 分区表标记为即将弃用 (deprecated)，意思是“从这个版本开始不建议这么使用，请使用替代方案。在将来的版本中会废弃这个功能”。</p><p>从 MySQL 8.0 版本开始，就不允许创建 MyISAM 分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有 InnoDB 和 NDB 这两个引擎支持了本地分区策略。</p><p>接下来，我们再看一下分区表在 server 层的行为。</p><h5 id="分区表的-server-层行为"><a href="#分区表的-server-层行为" class="headerlink" title="分区表的 server 层行为"></a>分区表的 server 层行为</h5><p>如果从 server 层看的话，一个分区表就只是一个表。</p><p>这句话是什么意思呢？接下来，我就用下面这个例子来和你说明。如图 8 和图 9 所示，分别是这个例子的操作序列和执行结果图。</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/0eca5a3190161e59ea58493915bd5e81.png" alt="img"></p><p>图 8 分区表的 MDL 锁</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/afe662f5e051a2ceb96a87624a589aa8.png" alt="img"></p><p>图 9 show processlist 结果</p><p>可以看到，虽然 session B 只需要操作 p_2107 这个分区，但是由于 session A 持有整个表 t 的 MDL 锁，就导致了 session B 的 alter 语句被堵住。</p><p>这也是 DBA 同学经常说的，分区表，在做 DDL 的时候，影响会更大。如果你使用的是普通分表，那么当你在 truncate 一个分表的时候，肯定不会跟另外一个分表上的查询语句，出现 MDL 锁冲突。</p><p>到这里我们小结一下：</p><ol><li>MySQL 在第一次打开分区表的时候，需要访问所有的分区；</li><li>在 server 层，认为这是同一张表，因此所有分区共用同一个 MDL 锁；</li><li>在引擎层，认为这是不同的表，因此 MDL 锁之后的执行过程，会根据分区表规则，只访问必要的分区。</li><li><strong>MySQL 要求分区表中的主键必须包含分区字段。</strong>(自己加的)</li></ol><p>而关于“必要的分区”的判断，就是根据 SQL 语句中的 where 条件，结合分区规则来实现的。比如我们上面的例子中，where ftime&#x3D;‘2018-4-1’，根据分区规则 year 函数算出来的值是 2018，那么就会落在 p_2019 这个分区。</p><p>但是，如果这个 where 条件改成 where ftime&gt;&#x3D;‘2018-4-1’，虽然查询结果相同，但是这时候根据 where 条件，就要访问 p_2019 和 p_others 这两个分区。</p><p>如果查询语句的 where 条件中没有分区 key，那就只能访问所有分区了。当然，这并不是分区表的问题。即使是使用业务分表的方式，where 条件中没有使用分表的 key，也必须访问所有的分表。</p><p>我们已经理解了分区表的概念，那么什么场景下适合使用分区表呢？</p><h5 id="分区表的应用场景"><a href="#分区表的应用场景" class="headerlink" title="分区表的应用场景"></a>分区表的应用场景</h5><p>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。</p><p>如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过 alter table t drop partition …这个语法删掉分区，从而删掉过期的历史数据。</p><p>这个 alter table t drop partition …操作是直接删除分区文件，效果跟 drop 普通表类似。与使用 delete 语句删除数据相比，优势是速度快、对系统影响小。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka的副本机制</title>
    <link href="/2023/02/16/Apache%20Kafka%20%E7%9A%84%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E3%80%82/"/>
    <url>/2023/02/16/Apache%20Kafka%20%E7%9A%84%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>所谓的副本机制（Replication），也可以称之为备份机制，通常是指分布式系统在多台网络互联的机器上保存有相同的数据拷贝。副本机制有什么好处呢？</p><ol><li><strong>提供数据冗余</strong>。即使系统部分组件失效，系统依然能够继续运转，因而增加了整体可用性以及数据持久性。</li><li><strong>提供高伸缩性</strong>。支持横向扩展，能够通过增加机器的方式来提升读性能，进而提高读操作吞吐量。</li><li><strong>改善数据局部性</strong>。允许将数据放入与用户地理位置相近的地方，从而降低系统延时。</li></ol><p>这些优点都是在分布式系统教科书中最常被提及的，但是有些遗憾的是，对于 Apache Kafka 而言，目前只能享受到副本机制带来的第 1 个好处，也就是提供数据冗余实现高可用性和高持久性。为什么Kafka 没能提供第 2 点和第 3 点好处呢？</p><h5 id="副本定义"><a href="#副本定义" class="headerlink" title="副本定义"></a>副本定义</h5><p>Kafka 是有主题概念的，而每个主题又进一步划分成若干个分区。副本的概念实际上是在分区层级下定义的，每个分区配置有若干个副本。</p><p><strong>所谓副本（Replica），本质就是一个只能追加写消息的提交日志（多个Segment文件）</strong>。根据 Kafka 副本机制的定义，同一个分区下的所有副本保存有相同的消息序列，这些副本分散保存在不同的 Broker 上，从而能够对抗部分 Broker 宕机带来的数据不可用。</p><p>在实际生产环境中，每台 Broker 都可能保存有各个主题下不同分区的不同副本，因此，单个 Broker 上存有成百上千个副本的现象是非常正常的。</p><p>接下来我们来看一张图，它展示的是一个有 3 台 Broker 的 Kafka 集群上的副本分布情况。从这张图中，我们可以看到，主题 1 分区 0 的 3 个副本分散在 3 台 Broker 上，其他主题分区的副本也都散落在不同的 Broker 上，从而实现数据冗余。</p><p>![image-20220728111329358](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220728111329358.png)</p><h5 id="副本角色"><a href="#副本角色" class="headerlink" title="副本角色"></a>副本角色</h5><p>既然分区下能够配置多个副本，而且这些副本的内容还要一致，那么很自然的一个问题就是：我们该如何确保副本中所有的数据都是一致的呢？特别是对 Kafka 而言，当生产者发送消息到某个主题后，消息是如何同步到对应的所有副本中的呢？针对这个问题，最常见的解决方案就是采用<strong>基于领导者（Leader-based）的副本机制</strong>。Apache Kafka 就是这样的设计。</p><p>基于领导者的副本机制的工作原理如下图所示，我来简单解释一下这张图里面的内容。</p><p>![image-20220728111313694](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220728111313694.png)</p><p>第一，在 Kafka 中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本。</p><p>第二，Kafka 的副本机制比其他分布式系统要更严格一些。在 Kafka 中，追随者副本是不对外提供服务的。这就是说，任何一个追随者副本都不能响应消费者和生产者的读写请求。所有的请求都必须由领导者副本来处理，或者说，所有的读写请求都必须发往领导者副本所在的 Broker，由该 Broker 负责处理。追随者副本不处理客户端请求，它唯一的任务就是从领导者副本<strong>异步拉取</strong>消息，并写入到自己的提交日志中，从而实现与领导者副本的同步。</p><p>第三，当领导者副本挂掉了，或者说领导者副本所在的 Broker 宕机时，Kafka 依托于 ZooKeeper 提供的监控功能能够实时感知到，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。老 Leader 副本重启回来后，只能作为追随者副本加入到集群中。</p><p><strong>追随者副本是不对外提供服务的</strong>。</p><p>对于客户端用户而言，Kafka 的追随者副本没有任何作用，它既不能像 MySQL 那样帮助领导者副本“抗读”，也不能实现将某些副本放到离客户端近的地方来改善数据局部性。</p><p>既然如此，Kafka 为什么要这样设计呢？其实这种副本机制有两个方面的好处。</p><p>1.<strong>方便实现“Read-your-writes”</strong>。</p><p>所谓 Read-your-writes，顾名思义就是，当使用生产者 API 向 Kafka 成功写入消息后，马上使用消费者 API 去读取刚才生产的消息。</p><p>举个例子，比如平时发微博时，发完一条微博，肯定是希望能立即看到的，这就是典型的 Read-your-writes 场景。如果允许追随者副本对外提供服务，由于副本同步是异步的，因此有可能出现追随者副本还没有从领导者副本那里拉取到最新的消息，从而使得客户端看不到最新写入的消息。</p><p>2.<strong>方便实现单调读（Monotonic Reads）</strong>。</p><p>什么是单调读呢？就是对于一个消费者用户而言，在多次消费消息时，它不会看到某条消息一会儿存在一会儿不存在。</p><p>如果允许追随者副本提供读服务，那么假设当前有 2 个追随者副本 F1 和 F2，它们异步地拉取领导者副本数据。倘若 F1 拉取了 Leader 的最新消息而 F2 还未及时拉取，那么，此时如果有一个消费者先从 F1 读取消息之后又从 F2 拉取消息，它可能会看到这样的现象：第一次消费时看到的最新消息在第二次消费时不见了，这就不是单调读一致性。但是，如果所有的读请求都是由 Leader 来处理，那么 Kafka 就很容易实现单调读一致性。</p><h5 id="In-sync-Replicas（ISR）"><a href="#In-sync-Replicas（ISR）" class="headerlink" title="In-sync Replicas（ISR）"></a>In-sync Replicas（ISR）</h5><p>追随者副本不提供服务，只是定期地异步拉取领导者副本中的数据而已。既然是异步的，就存在着不可能与 Leader 实时同步的风险。在探讨如何正确应对这种风险之前，我们必须要精确地知道同步的含义是什么。或者说，Kafka 要明确地告诉我们，追随者副本到底在什么条件下才算与 Leader 同步。</p><p>基于这个想法，Kafka 引入了 In-sync Replicas，也就是所谓的 ISR 副本集合。ISR 中的副本都是与 Leader 同步的副本，相反，不在 ISR 中的追随者副本就被认为是与 Leader 不同步的。那么，到底什么副本能够进入到 ISR 中呢？</p><p>我们首先要明确的是，Leader 副本天然就在 ISR 中。也就是说，<strong>ISR 不只是追随者副本集合，它必然包括 Leader 副本。甚至在某些情况下，ISR 只有 Leader 这一个副本</strong>。</p><p>另外，能够进入到 ISR 的追随者副本要满足一定的条件</p><p>![image-20220728111301338](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220728111301338.png)</p><p>图中有 3 个副本：1 个领导者副本和 2 个追随者副本。Leader 副本当前写入了 10 条消息，Follower1 副本同步了其中的 6 条消息，而 Follower2 副本只同步了其中的 3 条消息。</p><p>这张图中的 2 个 Follower 副本都有可能与 Leader 不同步，但也都有可能与 Leader 同步。也就是说，Kafka 判断 Follower 是否与 Leader 同步的标准，不是看相差的消息数，而是<strong>Broker 端参数 replica.lag.time.max.ms 参数值</strong>。这个参数的含义是 Follower 副本能够落后 Leader 副本的最长时间间隔，当前默认值是 10 秒。这就是说，只要一个 Follower 副本落后 Leader 副本的时间不连续超过 10 秒，那么 Kafka 就认为该 Follower 副本与 Leader 是同步的，即使此时 Follower 副本中保存的消息明显少于 Leader 副本中的消息。</p><p>Follower 副本唯一的工作就是不断地从 Leader 副本拉取消息，然后写入到自己的提交日志中。如果这个同步过程的速度持续慢于 Leader 副本的消息写入速度，那么在 replica.lag.time.max.ms 时间后，此 Follower 副本就会被认为是与 Leader 副本不同步的，因此不能再放入 ISR 中。此时，Kafka 会自动收缩 ISR 集合，将该副本“踢出”ISR。</p><p>倘若该副本后面慢慢地追上了 Leader 的进度，那么它是能够重新被加回 ISR 的。这也表明，ISR 是一个动态调整的集合，而非静态不变的。</p><h5 id="Unclean-领导者选举（Unclean-Leader-Election）"><a href="#Unclean-领导者选举（Unclean-Leader-Election）" class="headerlink" title="Unclean 领导者选举（Unclean Leader Election）"></a>Unclean 领导者选举（Unclean Leader Election）</h5><p>既然 ISR 是可以动态调整的，那么自然就可以出现这样的情形：ISR 为空。因为 Leader 副本天然就在 ISR 中，如果 ISR 为空了，就说明 Leader 副本也“挂掉”了，Kafka 需要重新选举一个新的 Leader。可是 ISR 是空，此时该怎么选举新 Leader 呢？</p><p><strong>Kafka 把所有不在 ISR 中的存活副本都称为非同步副本</strong>。通常来说，非同步副本落后 Leader 太多，因此，如果选择这些副本作为新 Leader，就可能出现数据的丢失。毕竟，这些副本中保存的消息远远落后于老 Leader 中的消息。在 Kafka 中，选举这种副本的过程称为 Unclean 领导者选举。<strong>Broker 端参数 unclean.leader.election.enable 控制是否允许 Unclean 领导者选举</strong>。</p><p>开启 Unclean 领导者选举可能会造成数据丢失，但好处是，它使得分区 Leader 副本一直存在，不至于停止对外提供服务，因此提升了高可用性。反之，禁止 Unclean 领导者选举的好处在于维护了数据的一致性，避免了消息丢失，但牺牲了高可用性。</p><p>一个分布式系统通常只能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）中的两个。显然，在这个问题上，Kafka 赋予你选择 C 或 A 的权利。</p><p>你可以根据你的实际业务场景决定是否开启 Unclean 领导者选举。不过，建议<strong>不要</strong>开启它，毕竟还可以通过其他的方式来提升高可用性。如果为了这点儿高可用性的改善，牺牲了数据一致性，那就非常不值当了。</p><ol><li>Kafka集群partition replication默认自动分配分析</li></ol><p>下面以一个Kafka集群中4个Broker举例，创建1个topic包含4个Partition，2 Replication；数据Producer流动如图所示：</p><p>(1)</p><p>![image-20230809110806602](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230809110806602.png)</p><p>(2)当集群中新增2节点，Partition增加到6个时分布情况如下：</p><p>![image-20230809110822903](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230809110822903.png)</p><h5 id="副本分配逻辑规则如下："><a href="#副本分配逻辑规则如下：" class="headerlink" title="副本分配逻辑规则如下："></a>副本分配逻辑规则如下：</h5><p>在Kafka集群中，每个Broker都有均等分配Partition的Leader机会。<br>上述图Broker Partition中，箭头指向为副本，以Partition-0为例:broker1中parition-0为Leader，Broker2中Partition-0为副本。<br>上述图种每个Broker(按照BrokerId有序)依次分配主Partition,下一个Broker为副本，如此循环迭代分配，多副本都遵循此规则。</p><h5 id="副本分配算法如下："><a href="#副本分配算法如下：" class="headerlink" title="副本分配算法如下："></a>副本分配算法如下：</h5><p>将所有N Broker和待分配的i个Partition排序.<br>将第i个Partition分配到第(i mod n)个Broker上.<br>将第i个Partition的第j个副本分配到第((i + j) mod n)个Broker上. </p>]]></content>
    
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka partition中文件存储</title>
    <link href="/2023/01/28/kafka%20partiton%E4%B8%AD%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/01/28/kafka%20partiton%E4%B8%AD%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Kafka部分名词解释如下：</p><ul><li>Broker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。</li><li>Topic：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发。</li><li>Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。</li><li>Segment：partition物理上由多个segment组成，下面2.2和2.3有详细说明。</li><li>offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息.</li></ul><p>分析过程分为以下4个步骤：</p><ul><li>topic中partition存储分布</li><li>partiton中文件存储方式</li><li>partiton中segment文件存储结构</li><li>在partition中如何通过offset查找message</li></ul><h5 id="topic中partition存储分布"><a href="#topic中partition存储分布" class="headerlink" title="topic中partition存储分布"></a>topic中partition存储分布</h5><p>假设实验环境中Kafka集群只有一个broker，xxx&#x2F;message-folder为数据文件存储根目录，在Kafka broker中server.properties文件配置(参数log.dirs&#x3D;xxx&#x2F;message-folder)，例如创建2个topic名称分别为report_push、launch_info, partitions数量都为partitions&#x3D;4 存储路径和目录规则为： xxx&#x2F;message-folder</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|--report_push-0</span><br><span class="hljs-string">|--report_push-1</span><br><span class="hljs-string">|--report_push-2</span><br><span class="hljs-string">|--report_push-3</span><br><span class="hljs-string">|--launch_info-0</span><br><span class="hljs-string">|--launch_info-1</span><br><span class="hljs-string">|--launch_info-2</span><br><span class="hljs-string">|--launch_info-3</span><br></code></pre></td></tr></table></figure><p>在Kafka文件存储中，<strong>同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1</strong>。 </p><h5 id="Partition的数据文件"><a href="#Partition的数据文件" class="headerlink" title="Partition的数据文件"></a><strong>Partition的数据文件</strong></h5><p>Partition中的每条Message由offset来表示它在这个partition中的偏移量，这个offset不是该Message在partition数据文件中的实际存储位置，而是逻辑上一个值，它唯一确定了partition中的一条Message。因此，可以认为offset是partition中Message的id。partition中的每条Message包含了以下三个属性：</p><ul><li>offset</li><li>MessageSize</li><li>data</li></ul><p>其中offset为long型，MessageSize为int32，表示data有多大，data为message的具体内容。它的格式和<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.xgss.net/tag/kafka">Kafka</a>通讯协议中介绍的MessageSet格式是一致。</p><p>Partition的数据文件则包含了若干条上述格式的Message，按offset由小到大排列在一起。它的实现类为FileMessageSet，类图如下：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-8492898/eb6285e025c76f9166f856363d908f5f.png" alt="FileMessageSet类图"></p><p>它的主要方法如下：</p><ul><li>append: 把给定的ByteBufferMessageSet中的Message写入到这个数据文件中。</li><li>searchFor: 从指定的startingPosition开始搜索找到第一个Message其offset是大于或者等于指定的offset，并返回其在文件中的位置Position。它的实现方式是从startingPosition开始读取12个字节，分别是当前MessageSet的offset和size。如果当前offset小于指定的offset，那么将position向后移动LogOverHead+MessageSize（其中LogOverHead为offset+messagesize，为12个字节）。</li><li>read：准确名字应该是slice，它截取其中一部分返回一个新的FileMessageSet。它不保证截取的位置数据的完整性。</li><li>sizeInBytes: 表示这个FileMessageSet占有了多少字节的空间。</li><li>truncateTo: 把这个文件截断，这个方法不保证截断位置的Message的完整性。</li><li>readInto: 从指定的相对位置开始把文件的内容读取到对应的ByteBuffer中。</li></ul><p>我们来思考一下，如果一个partition只有一个数据文件会怎么样？</p><ol><li>新数据是添加在文件末尾（调用FileMessageSet的append方法），不论文件数据文件有多大，这个操作永远都是O(1)的。</li><li>查找某个offset的Message（调用FileMessageSet的searchFor方法）是顺序查找的。因此，如果数据文件很大的话，查找的效率就低。</li></ol><p><strong>那<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.xgss.net/tag/kafka">Kafka</a>是如何解决查找效率的的问题呢？有两大法宝：1) 分段 2) 索引。</strong></p><h5 id="数据文件的分段"><a href="#数据文件的分段" class="headerlink" title="数据文件的分段"></a><strong>数据文件的分段</strong></h5><p>Kafka解决查询效率的手段之一是将数据文件分段，比如有100条Message，它们的offset是从0到99。假设将数据文件分成5段，第一段为0-19，第二段为20-39，以此类推，每段放在一个单独的数据文件里面，数据文件以该段中最小的offset命名。<strong>这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段中。</strong></p><h5 id="为数据文件建索引"><a href="#为数据文件建索引" class="headerlink" title="为数据文件建索引"></a><strong>为数据文件建索引</strong></h5><p>数据文件分段使得可以在一个较小的数据文件中查找对应offset的Message了，但是这依然需要顺序扫描才能找到对应offset的Message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。 索引文件中包含若干个索引条目，每个条目表示数据文件中一条Message的索引。索引包含两个部分（均为4个字节的数字），分别为相对offset和position。</p><ul><li>相对offset：因为数据文件分段以后，每个数据文件的起始offset不为0，相对offset表示这条Message相对于其所属数据文件中最小的offset的大小。举例，分段后的一个数据文件的offset是从20开始，那么offset为25的Message在index文件中的相对offset就是25-20 &#x3D; 5。存储相对offset可以减小索引文件占用的空间。</li><li>position，表示该条Message在数据文件中的绝对位置。只要打开文件并移动文件指针到这个position就可以读取对应的Message了。</li></ul><p>index文件中并没有为数据文件中的每条Message建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。但缺点是没有建立索引的Message也不能一次定位到其在数据文件的位置，从而需要做一次顺序扫描，但是这次顺序扫描的范围就很小了。</p><p>在Kafka中，索引文件的实现类为OffsetIndex，它的类图如下：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-8492898/877a96453c4219055ecf60dddd9425fa.png" alt="OffsetIndex类图"></p><p>主要的方法有：</p><ul><li>append方法，添加一对offset和position到index文件中，这里的offset将会被转成相对的offset。</li><li>lookup, 用二分查找的方式去查找小于或等于给定offset的最大的那个offset</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h5><p>我们以几张图来总结一下Message是如何在Kafka中存储的，以及如何查找指定offset的Message的。</p><p>Message是按照topic来组织，每个topic可以分成多个的partition，比如：有5个partition的名为为page_visits的topic的目录结构为：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-8492898/9158a1c4ed8eb1684bec9427006cf0a0.png" alt="topic_partition"></p><p>partition是分段的，每个段叫LogSegment，包括了一个数据文件和一个索引文件，下图是某个partition目录下的文件：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-8492898/17373022ea446cf444436674b5554577.png" alt="partition"></p><p>可以看到，这个partition有4个LogSegment。</p><p>查找Message原理图：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-8492898/c9c1962bc04948b8aebcf9b7a2922c3a.png" alt="search"></p><p>比如：要查找绝对offset为7的Message：</p><ol><li>首先是用二分查找确定它是在哪个LogSegment中，自然是在第一个Segment中。</li><li>打开这个Segment的index文件，也是用二分查找找到offset小于或者等于指定offset的索引条目中最大的那个offset。自然offset为6的那个索引是我们要找的，通过索引文件我们知道offset为6的Message在数据文件中的位置为9807。</li><li>打开数据文件，从位置为9807的那个地方开始顺序扫描直到找到offset为7的那条Message。</li></ol><p>这套机制是建立在offset是有序的。索引文件被映射到内存中，所以查找的速度还是很快的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka是如何做到高性能的</title>
    <link href="/2023/01/08/Kafka%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E8%BF%99%E4%B9%88%E9%AB%98%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84/"/>
    <url>/2023/01/08/Kafka%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E8%BF%99%E4%B9%88%E9%AB%98%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>Kafka 单个节点的极限处理能力接近每秒钟 2000 万条消息，吞吐量达到每秒钟 600MB。</p><p>那kafka是如何做到的呢？</p><p>  <img src="https://segmentfault.com/img/bVbIC7u" alt="00-33-50.jpg"></p><h5 id="1-分区"><a href="#1-分区" class="headerlink" title="1. 分区"></a>1. 分区</h5><p>  生产者往Kafka发送消息时必须指定发往哪个主题，消费者需要订阅某个主题才能进行消费。一个主题下的分区可以分布在集群的不同broker上面，也就是说，一个主题可以横跨多个broker。这样的话，生产者在指定主题（可以指定也可以不指定分区）发送消息的时候，Kafka会将消息分发至不同的分区，如果这些分区不在同一个broker上，就相当于并发的写入多台broker，性能自然要比写入单台broker要高。对于消费者，Kafka引入了消费组(Consumer Group)的概念，每个消费者都有一个对应的消费组。一个分区只能被一个消费组中的一个消费者消费，但是可以被不同消费组中的另一个消费者消费。可以在一个消费组里起多个消费者，每个消费者消费一个分区，这样就提高了消费者的性能。需要注意的是，消费组里的消费者个数如果多于分区数的话，那些多出来的消费者就会处于空闲状态，所以一个消费组里的消费者个数跟分区数相等就好了。下图展示了消费者组与分区的关系。<br>    <img src="https://segmentfault.com/img/bVbIC7v" alt="22-08-58.jpg"></p><p>  </p><p>分区的设计使得Kafka消息的读写性能可以突破单台broker的I&#x2F;O性能瓶颈，可以在创建主题的时候指定分区数，也可以在主题创建完成之后去修改分区数，通过增加分区数可以实现水平扩展，但是要注意，分区数也不是越多越好，一般达到某一个阈值之后，再增加分区数性能反而会下降，具体阈值需要对Kafka集群进行压测才能确定。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="2-使用批量消息提升服务端处理能力"><a href="#2-使用批量消息提升服务端处理能力" class="headerlink" title="2. 使用批量消息提升服务端处理能力"></a>2. 使用批量消息提升服务端处理能力</h5><p>Kafka producer会将相同topic分区下的一组消息打包在一起形成一个批次（batch）以提升网络I&#x2F;O性能。(在必要情况下，我们可以对生产者的batch size进行一定的调整)<br>默认情况下，producer会立即发送batch，这样一个batch中通常不会包含太多的消息。为了提高batch的效率，生产者通常会对<strong>linger.ms</strong>来人为设置一个较小的延迟来保证有足够多的消息记录能封装在一个batch中。一旦过了linger.ms设置的事件，或者batch size已经达到最大值(<strong>batch.size的参数值</strong>)，这个batch将被认为已经完成。</p><p>当你调用 send() 方法发送一条消息之后，无论你是同步发送还是异步发送，Kafka 都不会立即就把这条消息发送出去。它会先把这条消息，存放在内存中缓存起来，然后选择合适的时机把缓存中的所有消息组成一批，一次性发给 Broker。简单地说，就是攒一波一起发。</p><p>在 Kafka 的服务端，也就是 Broker 这一端，又是如何处理这一批一批的消息呢？</p><p>在服务端，Kafka 不会把一批消息再还原成多条消息，再一条一条地处理，这样太慢了。Kafka 这块儿处理的非常聪明，每批消息都会被当做一个“批消息”来处理。也就是说，在 Broker 整个处理流程中，无论是写入磁盘、从磁盘读出来、还是复制到其他副本这些流程中，<strong>批消息都不会被解开，一直是作为一条“批消息”来进行处理的。</strong></p><p>在消费时，消息同样是以批为单位进行传递的，Consumer 从 Broker 拉到一批消息后，在客户端把批消息解开，再一条一条交给用户代码处理。</p><p>比如说，你在客户端发送 30 条消息，在业务程序看来，是发送了 30 条消息，而对于 Kafka 的 Broker 来说，它其实就是处理了 1 条包含 30 条消息的“批消息”而已。显然处理 1 次请求要比处理 30 次请求要快得多。</p><p>构建批消息和解开批消息分别在发送端和消费端的客户端完成，不仅减轻了 Broker 的压力，最重要的是减少了 Broker 处理请求的次数，提升了总体的处理能力。</p><p>这就是 Kafka 用批量消息提升性能的方法。</p><p>我们知道，相比于网络传输和内存，磁盘 IO 的速度是比较慢的。对于消息队列的服务端来说，性能的瓶颈主要在磁盘 IO 这一块。接下来我们看一下，Kafka 在磁盘 IO 这块儿做了哪些优化。</p><h5 id="3-使用顺序读写提升磁盘-IO-性能"><a href="#3-使用顺序读写提升磁盘-IO-性能" class="headerlink" title="3. 使用顺序读写提升磁盘 IO 性能"></a>3. 使用顺序读写提升磁盘 IO 性能</h5><p>对于磁盘来说，它有一个特性，就是顺序读写的性能要远远好于随机读写。在 SSD（固态硬盘）上，顺序读写的性能要比随机读写快几倍，如果是机械硬盘，这个差距会达到几十倍。为什么呢？</p><p>操作系统每次从磁盘读写数据的时候，需要先寻址，也就是先要找到数据在磁盘上的物理位置，然后再进行数据读写。如果是机械硬盘，这个寻址需要比较长的时间，因为它要移动磁头，这是个机械运动，机械硬盘工作的时候会发出咔咔的声音，就是移动磁头发出的声音。</p><p>顺序读写相比随机读写省去了大部分的寻址时间，它只要寻址一次，就可以连续地读写下去，所以说，性能要比随机读写要好很多。</p><p>Kafka 就是充分利用了磁盘的这个特性。它的存储设计非常简单，对于每个分区，它把从 Producer 收到的消息，顺序地写入对应的 log 文件中，一个文件写满了，就开启一个新的文件这样顺序写下去。消费的时候，也是从某个全局的位置开始，也就是某一个 log 文件中的某个位置开始，顺序地把消息读出来。</p><p>这样一个简单的设计，充分利用了顺序读写这个特性，极大提升了 Kafka 在使用磁盘时的 IO 性能。</p><p>接下来我们说一下 Kafka 是如何实现缓存的。</p><h5 id="4-利用-PageCache-加速消息读写"><a href="#4-利用-PageCache-加速消息读写" class="headerlink" title="4. 利用 PageCache 加速消息读写"></a>4. 利用 PageCache 加速消息读写</h5><p>Kafka并不太依赖JVM内存大小，而是主要利用Page Cache，如果使用应用层缓存（JVM堆内存），会增加GC负担，增加停顿时间和延迟，创建对象的开销也会比较高。</p><p>读取操作可以直接在Page Cache上进行，如果消费和生产速度相当，甚至不需要通过物理磁盘直接交换数据，这是Kafka高吞吐量的一个重要原因。</p><p>这么做还有一个优势，如果Kafka重启，JVM内的Cache会失效，Page Cache依然可用。</p><p><img src="https://pic2.zhimg.com/80/v2-af6f2640475607eb8d897c7c26342809_1440w.webp" alt="img"></p><p>在 Kafka 中，它会利用 PageCache 加速消息读写。PageCache 是现代操作系统都具有的一项基本特性。通俗地说，PageCache 就是操作系统在内存中给磁盘上的文件建立的缓存。无论我们使用什么语言编写的程序，在调用系统的 API 读写文件的时候，并不会直接去读写磁盘上的文件，应用程序实际操作的都是 PageCache，也就是文件在内存中缓存的副本。</p><p>应用程序在写入文件的时候，操作系统会先把数据写入到内存中的 PageCache，然后再一批一批地写到磁盘上。读取文件的时候，也是从 PageCache 中来读取数据，这时候会出现两种可能情况。</p><p>一种是 PageCache 中有数据，那就直接读取，这样就节省了从磁盘上读取数据的时间；另一种情况是，PageCache 中没有数据，这时候操作系统会引发一个缺页中断，应用程序的读取线程会被阻塞，操作系统把数据从文件中复制到 PageCache 中，然后应用程序再从 PageCache 中继续把数据读出来，这时会真正读一次磁盘上的文件，这个读的过程就会比较慢。</p><p>用户的应用程序在使用完某块 PageCache 后，操作系统并不会立刻就清除这个 PageCache，而是尽可能地利用空闲的物理内存保存这些 PageCache，除非系统内存不够用，操作系统才会清理掉一部分 PageCache。清理的策略一般是 LRU 或它的变种算法，这个算法我们不展开讲，它保留 PageCache 的逻辑是：优先保留最近一段时间最常使用的那些 PageCache。</p><p>Kafka 在读写消息文件的时候，充分利用了 PageCache 的特性。一般来说，消息刚刚写入到服务端就会被消费，按照 LRU 的“优先清除最近最少使用的页”这种策略，读取的时候，对于这种刚刚写入的 PageCache，命中的几率会非常高。</p><p>也就是说，大部分情况下，消费读消息都会命中 PageCache，带来的好处有两个：一个是读取的速度会非常快，另外一个是，给写入消息让出磁盘的 IO 资源，间接也提升了写入的性能。</p><h5 id="5-ZeroCopy：零拷贝技术"><a href="#5-ZeroCopy：零拷贝技术" class="headerlink" title="5. ZeroCopy：零拷贝技术"></a>5. ZeroCopy：零拷贝技术</h5><p>  零拷贝技术是一种避免CPU将数据从一块存储拷贝到另一块存储的技术。Kafka使用零拷贝技术将数据直接从磁盘复制到网卡设备缓冲区中，而不需要经过应用程序的转发。<br>  通常应用程序将磁盘上的数据传送至网卡需要经过4步：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 调用read()，将数据从磁盘复制到内核模式的缓冲区；<br><span class="hljs-bullet">2.</span> CPU会将数据从内核模式复制到用户模式下的缓冲区；<br><span class="hljs-bullet">3.</span> 调用write()，将数据从用户模式下复制到内核模式下的Socket缓冲区；<br><span class="hljs-bullet">4.</span> 将数据从内核模式的Socket缓冲区复制到网卡设备。<br></code></pre></td></tr></table></figure><p>  上面的步骤中，第2、3步将数据从内核模式经过用户模式再绕回内核模式，浪费了两次复制过程。采用零拷贝技术，Kafka可以直接请求内核把磁盘中的数据复制到Socket缓冲区，而不用再经过用户模式。</p><h5 id="6-日志分段存储"><a href="#6-日志分段存储" class="headerlink" title="6. 日志分段存储"></a>6. 日志分段存储</h5><p>  为了防止日志（Log）过大，Kafka引入了日志分段（LogSegment）的概念，将日志切分成多个日志分段。在磁盘上，日志是一个目录，每个日志分段对应于日志目录下的日志文件、偏移量索引文件、时间戳索引文件（可能还有其他文件）。<br>  向日志中追加消息是顺序写入的，只有最后一个日志分段才能执行写入操作，之前所有的日志分段都不能写入数据。<br>  为了便于检索，每个日志分段都有两个索引文件：偏移量索引文件和时间戳索引文件。每个日志分段都有一个基准偏移量baseOffset，用来表示当前日志分段中第一条消息的offset。偏移量索引文件和时间戳索引文件是以稀疏索引的方式构造的，偏移量索引文件中的偏移量和时间戳索引文件中的时间戳都是严格单调递增的。查询指定偏移量（或时间戳）时，使用二分查找快速定位到偏移量（或时间戳）的位置。可见Kafka中对消息的查找速度还是非常快的。</p><h5 id="kafka存储模型"><a href="#kafka存储模型" class="headerlink" title="kafka存储模型"></a>kafka存储模型</h5><h5 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h5><p>Kafka节点上，一个Partition对应一个磁盘目录，命名为_，分为多个LogSegment，一个LogSegment，一个LogSegment对应磁盘上一个日志文件和一个索引文件，日志文件命名规则为[baseOffset].log，baseOffset是日志文件中第一条消息的offset。</p><p>写入时数据直接append到文件末尾，所以不管文件多大，写入总是O(1)的时间复杂度。</p><p><img src="https://pic2.zhimg.com/80/v2-720b48c75b7a04c89452084c0c0d145d_1440w.webp" alt="img"></p><h5 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h5><p>索引是分段和稀疏索引的方式，二分查找定位日志位点，返回低位点。和日志不同，索引文件因为比较小，用mmap的方式操作，速度很快。</p><p><img src="https://pic3.zhimg.com/80/v2-38c2ed40892d07bab47c02d7a554e296_1440w.webp" alt="img"></p><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="7-Kafka线程模型"><a href="#7-Kafka线程模型" class="headerlink" title="7. Kafka线程模型"></a>7. Kafka线程模型</h5><p>1(Acceptor) + N(Processor) + M(KafkaRequestHandler)，在Netty，Tomcat，Nginx上面都能看见类似的设计</p><p>N &#x3D; num.networker.threads</p><p>M &#x3D; num.io.threads</p><p>一个EndPoint(网卡)对于一个Acceptor，一般来说就一个</p><p><img src="https://pic4.zhimg.com/80/v2-0f860c6481476ae796fa067a19cb70c3_1440w.webp" alt="img"></p><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5>]]></content>
    
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql binlog学习</title>
    <link href="/2022/11/02/24%20MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84%EF%BC%9F/"/>
    <url>/2022/11/02/24%20MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h5 id="MySQL-主备的基本原理"><a href="#MySQL-主备的基本原理" class="headerlink" title="MySQL 主备的基本原理"></a>MySQL 主备的基本原理</h5><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/a66c154c1bc51e071dd2cc8c1d6ca6a3.png" alt="img"></p><p>主备流程图</p><p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写 binlog。</p><p>备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：</p><ol><li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li><li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 <strong>io_thread</strong> 和 <strong>sql_thread</strong>。其中 io_thread 负责与主库建立连接。</li><li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li><li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li><li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li></ol><p>这里需要说明，后来由于多线程复制方案的引入，sql_thread 演化成为了多个线程。</p><p>那么binlog 里面到底是什么内容，为什么备库拿过去可以直接执行？</p><h5 id="binlog-的三种格式对比"><a href="#binlog-的三种格式对比" class="headerlink" title="binlog 的三种格式对比"></a>binlog 的三种格式对比</h5><p> binlog 有两种格式，一种是 statement，一种是 row。还有第三种格式，叫作 mixed，其实它就是前两种格式的混合。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`t`</span> (<br>  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`a`</span> int(<span class="hljs-number">11</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`t_modified`</span> timestamp <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> DEFAULT CURRENT_TIMESTAMP,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`a`</span> (<span class="hljs-symbol">`a`</span>),<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`t_modified`</span>(<span class="hljs-symbol">`t_modified`</span>)<br>) ENGINE=InnoDB;<br> <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2018-11-13&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;2018-11-12&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;2018-11-11&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;2018-11-10&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;2018-11-09&#x27;</span>);<br></code></pre></td></tr></table></figure><p>如果要在表中删除一行数据的话，看看这个 delete 语句的 binlog 是怎么记录的。</p><p>注意，下面这个语句包含注释，如果用 MySQL 客户端来做这个实验的话，要记得加 -c 参数，否则客户端会自动去掉注释。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> t <span class="hljs-comment">/*comment*/</span>  <span class="hljs-keyword">where</span> a&gt;=<span class="hljs-number">4</span> <span class="hljs-keyword">and</span> t_modified&lt;=<span class="hljs-string">&#x27;2018-11-10&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>当 binlog_format&#x3D;statement 时，binlog 里面记录的就是 SQL 语句的原文。   可以用</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">mysql&gt; show binlog events in &#x27;master.<span class="hljs-number">000001</span>&#x27;;<br></code></pre></td></tr></table></figure><p>命令看 binlog 中的内容。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/b9818f73cd7d38a96ddcb75350b52931.png" alt="img"></p><p>看一下这条 delete 命令的执行效果图：</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/96c2be9c0fcbff66883118526b26652b.png" alt="img"></p><p>图 4 delete 执行 warnings</p><p>可以看到，运行这条 delete 命令产生了一个 warning，原因是当前 binlog 设置的是 statement 格式，并且语句中有 limit，所以这个命令可能是 unsafe 的。</p><p>为什么这么说呢？这是因为 delete 带 <strong>limit</strong>，很可能会出现主备数据不一致的情况。比如上面这个例子：</p><ol><li>如果 delete 语句使用的是索引 a，那么会根据索引 a 找到第一个满足条件的行，也就是说删除的是 a&#x3D;4 这一行；</li><li>但如果使用的是索引 t_modified，那么删除的就是 t_modified&#x3D;’2018-11-09’也就是 a&#x3D;5 这一行。</li></ol><p>由于 statement 格式下，记录到 binlog 里的是语句原文，因此可能会出现这样一种情况：在主库执行这条 SQL 语句的时候，用的是索引 a；而在备库执行这条 SQL 语句的时候，却使用了索引 t_modified。因此，MySQL 认为这样写是有风险的。</p><p>那么，如果把 binlog 的格式改为 binlog_format&#x3D;‘row’， 是不是就没有这个问题了呢？</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/d67a38db154afff610ae3bb64e266826.png" alt="img"></p><p>可以看到，与 statement 格式的 binlog 相比，前后的 BEGIN 和 COMMIT 是一样的。但是，row 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。</p><ol><li>Table_map event，用于说明接下来要操作的表是 test 库的表 t;</li><li>Delete_rows event，用于定义删除的行为。</li></ol><p>需要借助 mysqlbinlog 工具，用下面这个命令解析和查看 binlog 中的内容。因为图 5 中的信息显示，这个事务的 binlog 是从 8900 这个位置开始的，所以可以用 start-position 参数来指定从这个位置的日志开始解析。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">mysqlbinlog</span>  -vv <span class="hljs-class"><span class="hljs-keyword">data</span>/master.000001 <span class="hljs-comment">--start-position=8900;</span></span><br></code></pre></td></tr></table></figure><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/c342cf480d23b05d30a294b114cebfc2.png" alt="img"></p><p>图 6 row 格式 binlog 示例的详细信息</p><ul><li>server id 1，表示这个事务是在 server_id&#x3D;1 的这个库上执行的。</li><li>每个 event 都有 CRC32 的值，这是因为把参数 binlog_checksum 设置成了 CRC32。</li><li>Table_map event 跟在图 5 中看到的相同，显示了接下来要打开的表，map 到数字 226。这条 SQL 语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的 Table_map event、都会 map 到一个单独的数字，用于区分对不同表的操作。</li><li>在 mysqlbinlog 的命令中，使用了 -vv 参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1&#x3D;4、 @2&#x3D;4 这些值）。</li><li>binlog_row_image 的默认配置是 FULL，<strong>因此 Delete_event 里面，包含了删掉的行的所有字段的值</strong>。如果把 binlog_row_image 设置为 MINIMAL，则只会记录必要的信息，在这个例子里，就是只会记录 id&#x3D;4 这个信息。</li><li>最后的 Xid event，用于表示事务被正确地提交了。</li></ul><p>当 binlog_format 使用 row 格式的时候，binlog 里面记录了真实删除行的主键 id，这样 binlog 传到备库去的时候，就肯定会删除 id&#x3D;4 的行，不会有主备删除不同行的问题。</p><h5 id="为什么会有-mixed-格式的-binlog？"><a href="#为什么会有-mixed-格式的-binlog？" class="headerlink" title="为什么会有 mixed 格式的 binlog？"></a>为什么会有 mixed 格式的 binlog？</h5><p>基于上面的信息， 来讨论一个问题：<strong>为什么会有 mixed 这种 binlog 格式的存在场景？</strong>推论过程是这样的：</p><ul><li>因为有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式。</li><li>但 row 格式的缺点是，<strong>很占空间</strong>。比如用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</li><li>所以，MySQL 就取了个折中方案，也就是有了 mixed 格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</li></ul><p>也就是说，mixed 格式可以利用 statment 格式的优点，同时又避免了数据不一致的风险。</p><p>因此，如果线上 MySQL 设置的 binlog 格式是 statement 的话，那基本上就可以认为这是一个不合理的设置。至少应该把 binlog 的格式设置为 mixed。</p><p>比如 这个例子，设置为 mixed 后，就会记录为 row 格式；而如果执行的语句去掉 limit 1，就会记录为 statement 格式。</p><p>当然 要说的是，现在越来越多的场景要求把 MySQL 的 binlog 格式设置成 row。这么做的理由有很多，最重要的：<strong>恢复数据</strong>。</p><p>接下来， 就分别从 delete、insert 和 update 这三种 SQL 语句的角度，来看看数据恢复的问题。</p><p>即使  执行的是 delete 语句，row 格式的 binlog 也会把被删掉的行的整行信息保存起来。所以，如果在执行完一条 delete 语句以后，发现删错数据了，可以直接把 binlog 中记录的 delete 语句转成 insert，把被错删的数据插入回去就可以恢复了。</p><p>如果是执行错了 insert 语句呢？那就更直接了。row 格式下，insert 语句的 binlog 里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，直接把 insert 语句转成 delete 语句，删除掉这被误插入的一行数据就可以了。</p><p>如果执行的是 update 语句的话，binlog 里面会记录修改前整行的数据和修改后的整行数据。所以，如果   误执行了 update 语句的话，只需要把这个 event 前后的两行信息对调一下，再去数据库里面执行，就能恢复这个更新操作了。</p><p>其实，由 delete、insert 或者 update 语句导致的数据操作错误，需要恢复到操作之前状态的情况，也时有发生。MariaDB 的<a href="https://mariadb.com/kb/en/library/flashback/">Flashback</a>工具就是基于上面介绍的原理来回滚数据的。</p><p>虽然 mixed 格式的 binlog 现在已经用得不多了(<strong>5.7版本之后默认使用row</strong>)，但这里  还是要再借用一下 mixed 格式来说明一个问题，来看一下这条 SQL 语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>, now());<br></code></pre></td></tr></table></figure><p>如果 把 binlog 格式设置为 mixed，  MySQL 会把它记录为 row 格式还是 statement 格式呢？</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/0150301698979255a6f27711c35e9eef.png" alt="img"></p><p>图 7 mixed 格式和 now()</p><p>可以看到，MySQL 用的居然是 statement 格式。   一定会奇怪，如果这个 binlog 过了 1 分钟才传给备库的话，那主备的数据不就不一致了吗？</p><p>接下来， 再用 mysqlbinlog 工具来看看：</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/1ad3a4c4b9a71955edba5195757dd041.png" alt="img"></p><p>图 8 TIMESTAMP 命令</p><p>从图中的结果可以看到，原来 binlog 在记录 event 的时候，多记了一条命令：SET TIMESTAMP&#x3D;1546103491。它用 SET TIMESTAMP 命令约定了接下来的 now() 函数的返回时间。</p><p>因此，不论这个 binlog 是 1 分钟之后被备库执行，还是 3 天后用来恢复这个库的备份，这个 insert 语句插入的行，值都是固定的。也就是说，通过这条 SET TIMESTAMP 命令，MySQL 就确保了主备数据的一致性。</p><p>  之前看过有人在重放 binlog 数据的时候，是这么做的：用 mysqlbinlog 解析出日志，然后把里面的 statement 语句直接拷贝出来执行。</p><p>   现在知道了，这个方法是有风险的。因为有些语句的执行结果是依赖于上下文命令的，直接执行的结果很可能是错误的。</p><p>所以，用 binlog 来恢复数据的标准做法是，<strong>用 mysqlbinlog 工具解析出来，然后把解析结果整个发给 MySQL 执行</strong>。类似下面的命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysqlbinlog master.000001  <span class="hljs-attribute">--start-position</span>=2738 <span class="hljs-attribute">--stop-position</span>=2973 | mysql -h127.0.0.1 -P13000 -u<span class="hljs-variable">$user</span> -p<span class="hljs-variable">$pwd</span>;<br></code></pre></td></tr></table></figure><p>这个命令的意思是，将 master.000001 文件里面从第 2738 字节到第 2973 字节中间这段内容解析出来，放到 MySQL 去执行。</p><h5 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h5><p>binlog 的特性确保了在备库执行相同的 binlog，可以得到与主库相同的状态。</p><p>因此， 正常情况下主备的数据是一致的。也就是说，图 1 中 A、B 两个节点的内容是一致的。其实，图 1 中  画的是 M-S 结构，但实际生产上使用比较多的是双 M 结构，也就是图 9 所示的主备切换流程。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/20ad4e163115198dc6cf372d5116c956.png" alt="img"></p><p>图 9 MySQL 主备切换流程 – 双 M 结构</p><p>对比图 9 和图 1，   可以发现，双 M 结构和 M-S 结构，其实区别只是多了一条线，即：节点 A 和 B 之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。</p><p>但是，双 M 结构还有一个问题需要解决。</p><p>业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（  建议   把参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。</p><p>那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？</p><p>从上面的图 6 中可以看到，MySQL 在 binlog 中记录了这个命令第一次执行时所在实例的 server id。因此， 可以用下面的逻辑，来解决两个节点间的循环复制的问题：</p><ol><li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ol><p>按照这个逻辑，如果 设置了双 M 结构，日志的执行流就会变成这样：</p><ol><li>从节点 A 更新的事务，binlog 里面记的都是 A 的 server id；</li><li>传到节点 B 执行一次以后，节点 B 生成的 binlog 的 server id 也是 A 的 server id；</li><li>再传回给节点 A，A 判断到这个 server id 与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B+树是如何进行查询的</title>
    <link href="/2022/10/15/B+%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84/"/>
    <url>/2022/10/15/B+%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p><strong>InnoDB 是如何存储数据的？</strong></p><p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同的，最常使用的是 InnoDB 存储引擎。</p><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p>数据库的 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>数据页包括七个部分，结构如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f78da573e6dc4d00f8023cac699345ba.png" alt="图片"></p><p>这 7 个部分的作用如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7cb783d4da641c7b5bf719112f8d2e94.png" alt="图片"></p><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/25fab6b5a80b43d01a96f1480ed797bc.png" alt="图片"></p><p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p><p>数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。</p><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p><p>那 InnoDB 是如何给记录创建页目录的呢？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/944d760ea3437eb0624e0952f89b22a7.png" alt="图片"></p><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li></ol><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><p>以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：</p><ul><li>先二分得出槽中间位是 (0+4)&#x2F;2&#x3D;2 ，2号槽里最大的记录为 8。因为 11 &gt; 8，所以需要从 2 号槽后继续搜索记录；</li><li>再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)&#x2F;2&#x3D; 3，3 号槽里最大的记录为 12。因为 11 &lt; 12，所以主键为 11 的记录在 3 号槽里；</li><li>再从 3 号槽指向的主键值为 9 记录开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。</li></ul><p>看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p><p>这点不用担心，InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组中的记录只能有 1 条记录；</li><li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li><li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul><h5 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h5><p>上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p><p>但是，当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p><p>为了解决这个问题，<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I&#x2F;O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8ea6f9361ad8adac588c3b48737e140c.png" alt="图片"></p><p>通过上图，我们看出 B+ 树的特点：</p><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>我们再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：</p><ul><li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；</li><li>在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；</li><li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li></ul><p>可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</p><h5 id="聚集索引和二级索引"><a href="#聚集索引和二级索引" class="headerlink" title="聚集索引和二级索引"></a>聚集索引和二级索引</h5><p>另外，索引又可以分成聚集索引和非聚集索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且<strong>由于数据在物理上只会保存一份，所以聚簇索引只能有一个</strong>。</p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引&#x2F;辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><p>二级索引的 B+ 树如下图，数据部分为主键值：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9f2808f25f9c38a63059a4a04cd32ba6.png" alt="图片"></p><p>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS 在 CountDownLatch 等类中的应用原理是什么？</title>
    <link href="/2022/10/13/aqs/"/>
    <url>/2022/10/13/aqs/</url>
    
    <content type="html"><![CDATA[<h5 id="AQS-用法"><a href="#AQS-用法" class="headerlink" title="AQS 用法"></a>AQS 用法</h5><p> JDK 里<strong>利用 AQS 类的主要步骤</strong>：</p><ul><li><strong>第一步</strong>，新建一个自己的线程协作工具类，在内部写一个 Sync 类，该 Sync 类继承 AbstractQueuedSynchronizer，即 AQS；</li><li><strong>第二步</strong>，想好设计的线程协作工具类的协作逻辑，在 Sync 类里，根据是否是独占，来重写对应的方法。如果是独占，则重写 tryAcquire 和 tryRelease 等方法；如果是非独占，则重写 tryAcquireShared 和 tryReleaseShared 等方法；</li><li><strong>第三步</strong>，在自己的线程协作工具类中，实现获取&#x2F;释放的相关方法，并在里面调用 AQS 对应的方法，如果是独占则调用 acquire 或 release 等方法，非独占则调用 acquireShared 或 releaseShared 或 acquireSharedInterruptibly 等方法。</li></ul><p>通过这三步就可以实现对 AQS 的利用了。由于这三个步骤是经过浓缩和提炼的，所以现在你可能感觉有些不太容易理解，我们后面会有具体的实例来帮助理解，这里先有一个初步的印象即可。</p><p>你可能注意到了，上面的第二步是根据某些条件来重写特定的一部分方法，这个做法好像之前很少遇到过，或者说你可能会想，是不是有更好的做法？比如通过实现接口的方式，因为实现某一个接口之后，自然就知道需要重写其中哪些方法了，为什么要先继承类，然后自己去判断选择哪些方法进行重写呢？这不是自己给自己设置障碍吗？</p><p>关于这个问题的答案，其实在 AQS 的原作者 Doug Lea 的论文中已经进行了说明，他认为如果是实现接口的话，那<strong>每一个抽象方法都需要实现</strong>。比如你把整个 AQS 作为接口，那么需要实现的方法有很多，包括 tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared 等，但是实际上我们并不是每个方法都需要重写，根据需求的不同，有选择的去实现一部分就足以了，所以就设计为不采用实现接口，而采用继承类并重写方法的形式。</p><p>那可能你又有疑问了，继承类后，是不强制要求重写方法的，所以如果我们一个方法都不重写，行不行呢？答案是，如果不重写刚才所讲的 tryAcquire 等方法，是不行的，因为在执行的时候会抛出异常，我们来看下 AQS 对这些方法的默认的实现就知道了。</p><p>下面有四个方法的代码，分别是 tryAcquire、tryRelease、tryAcquireShared 和 tryReleaseShared 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br><br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br><br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br><br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它们内部只有一行实现代码，就是直接抛出异常，所以要求我们在继承 AQS 之后，必须把相关方法去重写、覆盖，这样未来我们写的线程协作类才能正常的运行。</p><h5 id="AQS-在-CountDownLatch-的应用"><a href="#AQS-在-CountDownLatch-的应用" class="headerlink" title="AQS 在 CountDownLatch 的应用"></a>AQS 在 CountDownLatch 的应用</h5><p>上面讲了使用 AQS 的基本流程，现在我们用例子来帮助理解，一起来看看 AQS 在 CountDownLatch 中的应用。</p><p>在 CountDownLatch 里面有一个子类，该类的类名叫 <strong>Sync，这个类正是继承自 AQS</strong>。下面给出了 CountDownLatch 部分代码的截取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatch</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * Synchronization control For CountDownLatch.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * Uses AQS state to represent count.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">4982264981922014374L</span>;<br><br>        Sync(<span class="hljs-type">int</span> count) &#123;<br><br>            setState(count);<br><br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br><br>            <span class="hljs-keyword">return</span> getState();<br><br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><br>            <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br><br>            <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br><br>                    <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br><br>            &#125;<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br><br>   <span class="hljs-comment">//省略其他代码...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以很明显看到最开始一个 Sync 类继承了 AQS，这正是上一节所讲的“第一步，新建一个自己的线程协作工具类，在内部写一个 Sync 类，该 Sync 类继承 AbstractQueuedSynchronizer，即 AQS”。而在 CountDownLatch 里面还有一个 sync 的变量，正是 Sync 类的一个对象。</p><p>同时，我们看到，Sync 不但继承了 AQS 类，而且<strong>还重写了 tryAcquireShared 和 tryReleaseShared 方法</strong>，这正对应了“第二步，想好设计的线程协作工具类的协作逻辑，在 Sync 类里，根据是否是独占，来重写对应的方法。如果是独占，则重写 tryAcquire 或 tryRelease 等方法；如果是非独占，则重写 tryAcquireShared 和 tryReleaseShared 等方法”。</p><p>这里的 CountDownLatch 属于非独占的类型，因此它重写了 tryAcquireShared 和 tryReleaseShared 方法，那么这两个方法的具体含义是什么呢？别急，接下来就让我们对 CountDownLatch 类里面最重要的 4 个方法进行分析，逐步揭开它的神秘面纱。</p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>首先来看看构造函数。CountDownLatch 只有一个构造方法，传入的参数是需要“倒数”的次数，每次调用 countDown 方法就会倒数 1，直到达到了最开始设定的次数之后，相当于是“打开了门闩”，所以之前在等待的线程可以继续工作了。</p><p>我们具体来看下构造函数的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br><br>    <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看到，当 count &lt; 0 时会抛出异常，当 count &gt; &#x3D; 0，即代码 this.sync &#x3D; new Sync( count ) ，往 Sync 中传入了 count，这个里的 Sync 的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Sync(<span class="hljs-type">int</span> count) &#123;<br><br>     setState(count);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>该构造函数调用了 AQS 的 setState 方法，并且把 count 传进去了，而 setState 正是给 AQS 中的 state 变量赋值的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br><br>    state = newState;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们通过 CountDownLatch 构造函数将传入的 count <strong>最终传递到 AQS 内部的 state 变量</strong>，给 state 赋值，state 就代表还需要倒数的次数。</p><h5 id="getCount"><a href="#getCount" class="headerlink" title="getCount"></a>getCount</h5><p>接下来介绍 getCount 方法，该方法的作用是获取当前剩余的还需要“倒数”的数量，getCount 方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br><br>     <span class="hljs-keyword">return</span> sync.getCount();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>该方法 return 的是 sync 的 getCount：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br><br>     <span class="hljs-keyword">return</span> getState();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们一步步把源码追踪下去，getCount 方法调用的是 AQS 的 getState：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-keyword">return</span> state;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如代码所示，protected final int getState 方法直接 return 的就是 state 的值，所以最终它获取到的就在 AQS 中 state 变量的值。</p><h5 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h5><p>我们再来看看 countDown 方法，该方法其实就是 CountDownLatch 的“<strong>释放</strong>”方法，下面来看下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br><br>    sync.releaseShared(<span class="hljs-number">1</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 countDown 方法中调用的是 sync 的 releaseShared 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br><br>        doReleaseShared();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，releaseShared 先进行 if 判断，判断 tryReleaseShared 方法的返回结果，因此先把目光聚焦到 tryReleaseShared 方法中，tryReleaseShared 源码如下所示 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br><br>    <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br><br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>方法内是一个 for 的死循环，在循环体中，最开始是通过 getState 拿到当前 state 的值并赋值给变量 c，这个 c 可以理解为是 count 的缩写，如果此时 c &#x3D; 0，则意味着已经倒数为零了，会直接会执行下面的 return false 语句，一旦 tryReleaseShared 方法返回 false，再往上看上一层的 releaseShared 方法，就会直接跳过整个 if (tryReleaseShared(arg)) 代码块，直接返回 false，相当于 releaseShared 方法不产生效果，也就意味着 countDown 方法不产生效果。</p><p>再回到 tryReleaseShared 方法中往下看 return false 下面的语句，如果 c 不等于 0，在这里会先把 c-1 的值赋给 nextc，然后再利用 CAS 尝试把 nextc 赋值到 state 上。如果赋值成功就代表本次 countDown 方法操作成功，也就意味着把 AQS 内部的 state 值减了 1。最后，是 return nextc &#x3D;&#x3D; 0，如果 nextc 为 0，意味着本次倒数后恰好达到了规定的倒数次数，门闩应当在此时打开，所以 tryReleaseShared 方法会返回 true，那么再回到之前的 releaseShared 方法中，可以看到，接下来会调用 doReleaseShared 方法，效果是<strong>对之前阻塞的线程进行唤醒，让它们继续执行</strong>。</p><p>如果结合具体的数来分析，可能会更清晰。假设 c &#x3D; 2，则代表需要倒数的值是 2，nextc &#x3D; c-1，所以 nextc 就是 1，然后利用 CAS 尝试把 state 设置为 1，假设设置成功，最后会 return nextc &#x3D;&#x3D; 0，此时 nextc 等于 1，不等于 0，所以返回 false，也就意味着 countDown 之后成功修改了 state 的值，把它减 1 了，但并没有唤醒线程。</p><p>下一次执行 countDown时，c 的值就是 1，而 nextc &#x3D; c - 1，所以 nextc 等于 0，若这时 CAS 操作成功，最后 return nextc &#x3D;&#x3D; 0，所以方法返回 true，一旦 tryReleaseShared 方法 return true，则 releaseShared 方法会调用 doReleaseShared 方法，把所有之前阻塞的线程都唤醒。</p><h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><p>接着我们来看看 await 方法，该方法是 CountDownLatch 的“<strong>获取</strong>”方法，调用 await 方法会把线程阻塞，直到倒数为 0 才能继续执行。await 方法和 countDown 是配对的，追踪源码可以看到 await 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>它会调用 sync 的 acquireSharedInterruptibly ，并且传入 1。acquireSharedInterruptibly 方法源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br><br>        doAcquireSharedInterruptibly(arg);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它除了对于中断的处理之外，比较重要的就是 tryAcquireShared 方法。这个方法很简单，它会直接判断 getState 的值是不是等于 0，如果等于 0 就返回 1，不等于 0 则返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>getState 方法获取到的值是剩余需要倒数的次数，如果此时剩余倒数的次数大于 0，那么 getState 的返回值自然不等于 0，因此 tryAcquireShared 方法会返回 -1，一旦返回 -1，再看到 if (tryAcquireShared(arg) &lt; 0) 语句中，就会符合 if 的判断条件，并且去执行 doAcquireSharedInterruptibly 方法，然后会<strong>让线程进入阻塞状态</strong>。</p><p>我们再来看下另一种情况，当 state 如果此时已经等于 0 了，那就意味着倒数其实结束了，不需要再去等待了，就是说门闩是打开状态，所以说此时 getState 返回 0，tryAcquireShared 方法返回 1 ，一旦返回 1，对于 acquireSharedInterruptibly 方法而言相当于立刻返回，也就意味着 await 方法会立刻返回，那么此时<strong>线程就不会进入阻塞状态了</strong>，相当于倒数已经结束，立刻放行了。</p><p>这里的 await 和 countDown 方法，正对应了本讲一开始所介绍的“第三步，在自己的线程协作工具类中，实现获取&#x2F;释放的相关方法，并在里面调用 AQS 对应的方法，如果是独占则调用 acquire 或 release 等方法，非独占则调用 acquireShared 或 releaseShared 或 acquireSharedInterruptibly 等方法。”</p><h5 id="AQS-在-CountDownLatch-的应用总结"><a href="#AQS-在-CountDownLatch-的应用总结" class="headerlink" title="AQS 在 CountDownLatch 的应用总结"></a>AQS 在 CountDownLatch 的应用总结</h5><p>最后对 AQS 在 CountDownLatch 的应用进行总结。当线程调用 CountDownLatch 的 await 方法时，便会尝试获取“共享锁”，不过一开始通常获取不到锁，于是线程被阻塞。“共享锁”可获取到的条件是“锁计数器”的值为 0，而“锁计数器”的初始值为 count，当每次调用 CountDownLatch 对象的 countDown 方法时，也可以把“锁计数器” -1。通过这种方式，调用 count 次 countDown 方法之后，“锁计数器”就为 0 了，于是之前等待的线程就会继续运行了，并且此时如果再有线程想调用 await 方法时也会被立刻放行，不会再去做任何阻塞操作了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql主从复制</title>
    <link href="/2022/10/04/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/2022/10/04/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h5 id="如何实现-MySQL-的读写分离？"><a href="#如何实现-MySQL-的读写分离？" class="headerlink" title="如何实现 MySQL 的读写分离？"></a>如何实现 MySQL 的读写分离？</h5><p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p><h5 id="MySQL-主从复制原理的是啥？"><a href="#MySQL-主从复制原理的是啥？" class="headerlink" title="MySQL 主从复制原理的是啥？"></a>MySQL 主从复制原理的是啥？</h5><p>MySQL的复制原理概述上来讲大体可以分为这三步</p><ol><li>在主库上把数据更改，记录到二进制日志（Binary Log）中。</li><li>从库将主库上的日志复制到自己的中继日志（Relay Log）中。</li><li>备库读取中继日志中的事件，将其重放到备库数据之上。</li></ol><p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/mysql-master-slave.png"><img src="https://github.com/doocs/advanced-java/raw/main/docs/high-concurrency/images/mysql-master-slave.png" alt="mysql-master-slave"></a></p><p>这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是<strong>有延时</strong>的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p><p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p><p>所以 MySQL 实际上在这一块有两个机制，一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p><p>这个所谓<strong>半同步复制</strong>，也叫 <code>semi-sync</code> 复制，指的就是主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成了。</p><p>所谓<strong>并行复制</strong>，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是库级别的并行。</p><h5 id="MySQL主从复制模式"><a href="#MySQL主从复制模式" class="headerlink" title="MySQL主从复制模式"></a>MySQL主从复制模式</h5><p>MySQL的主从复制其实是支持， <strong>异步复制</strong> 、 <strong>半同步复制</strong> 、 <strong>GTID复制</strong> 等多种复制模式的。</p><p>主从复制最好使用半同步复制(5.7版本以上默认采用)，这样子从库在把主库binlog读到relayLog之后会返回一个ack给主库， 如果是采用异步复制,binlog如果因为网络问题没传输到从库，然后主库又刚好挂了，触发了主从节点切换，新的主库就丢失了最新的数据，主从同步肯定是有延迟的，如果是要求强同步的场景，最好强制走主库查询(或者sleep)，如果怕主库压力太大，一定要走从库，那就要借助GTID全局事务ID，通过判断主备无延迟方案来查询从库</p><h5 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h5><p>MySQL的默认复制模式就是异步模式，主要是 指MySQL的主服务器上的I&#x2F;O线程，将数据写到binlong中就直接返回给客户端数据更新成功，不考虑数据是否传输到从服务器，以及是否写入到relaylog中 。在这种模式下，复制数据其实是有风险的，一旦数据只写到了主库的binlog中还没来得及同步到从库时，就会造成数据的丢失。</p><p>但是这种模式确也是效率最高的，因为变更数据的功能都只是在主库中完成就可以了，从库复制数据不会影响到主库的写数据操作。</p><p><img src="https://pic4.zhimg.com/80/v2-0c3c03942c8c32fc6bf840dd59457cc3_720w.webp" alt="img"></p><p>上面我也说了，这种异步复制模式虽然效率高，但是数据丢失的风险很大，所以就有了后面要介绍的半同步复制模式。</p><h5 id="半同步模式"><a href="#半同步模式" class="headerlink" title="半同步模式"></a>半同步模式</h5><p>MySQL从 <strong>5.5</strong> 版本开始通过以插件的形式开始支持半同步的主从复制模式。什么是半同步主从复制模式呢？(5.7以上版本默认采用半同步)</p><p>这里通过对比的方式来说明一下：</p><ul><li><strong>异步复制模式</strong> ：上面我们已经介绍了，异步复制模式，主库在执行完客户端提交的事务后，只要将执行逻辑写入到binlog后，就立即返回给客户端，并不关心从库是否执行成功，这样就会有一个隐患，就是在主库执行的binlog还没同步到从库时，主库挂了，这个时候从库就就会被强行提升为主库，这个时候就有可能造成数据丢失。</li><li><strong>同步复制模式</strong> ：当主库执行完客户端提交的事务后，需要等到所有从库也都执行完这一事务后，才返回给客户端执行成功。因为要等到所有从库都执行完，执行过程中会被阻塞，等待返回结果，所以性能上会有很严重的影响。</li><li><strong>半同步复制模式</strong> ：半同步复制模式，可以说是介于异步和同步之间的一种复制模式，主库在执行完客户端提交的事务后，要等待至少一个从库接收到binlog并将数据写入到relay log中才返回给客户端成功结果。半同步复制模式，比异步模式提高了数据的可用性，但是也产生了一定的性能延迟，最少要一个TCP&#x2F;IP连接的往返时间。</li></ul><p>半同步复制模式，可以很明确的知道，在一个事务提交成功之后，此事务至少会存在于两个地方一个是主库一个是从库中的某一个。 主要原理是，在master的dump线程去通知从库时，增加了一个ACK机制，也就是会确认从库是否收到事务的标志码，master的dump线程不但要发送binlog到从库，还有负责接收slave的ACK。当出现异常时，Slave没有ACK事务，那么将自动降级为异步复制，直到异常修复后再自动变为半同步复制</p><p>MySQL半同步复制的流程如下：</p><p><img src="https://pic4.zhimg.com/80/v2-b60c1eba9bb7663439b326cb6059ede3_720w.webp" alt="img"></p><h5 id="半同步复制的隐患"><a href="#半同步复制的隐患" class="headerlink" title="半同步复制的隐患"></a>半同步复制的隐患</h5><p>半同步复制模式也存在一定的数据风险，当事务在主库提交完后等待从库ACK的过程中，如果Master宕机了，这个时候就会有两种情况的问题。</p><ul><li><strong>事务还没发送到Slave上</strong> ：若事务还没发送Slave上，客户端在收到失败结果后，会重新提交事务，因为重新提交的事务是在新的Master上执行的，所以会执行成功，后面若是之前的Master恢复后，会以Slave的身份加入到集群中，这个时候，之前的事务就会被执行两次，第一次是之前此台机器作为Master的时候执行的，第二次是做为Slave后从主库中同步过来的。</li><li><strong>事务已经同步到Slave上</strong> ：因为事务已经同步到Slave了，所以当客户端收到失败结果后，再次提交事务，你那么此事务就会在当前Slave机器上执行两次。</li></ul><p>为了解决上面的隐患，MySQL从5.7版本开始，增加了一种新的半同步方式。新的半同步方式的执行过程是将“ <strong>Storage Commit</strong> ”这一步移动到了“ <strong>Write Slave dump</strong> ”后面。这样保证了 <strong>只有Slave的事务ACK后，才提交主库事务</strong> 。MySQL 5.7.2版本新增了一个参数来进行配置： rpl_semi_sync_master_wait_point ，此参数有两个值可配置：</p><ul><li><strong>AFTER_SYNC</strong> ：参数值为AFTER_SYNC时，代表采用的是新的半同步复制方式。</li><li><strong>AFTER_COMMIT</strong> ：代表采用的是之前的旧方式的半同步复制模式。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-f134389146adc74ebf6ad938ba201a51_720w.webp" alt="img"></p><p>MySQL从5.7.2版本开始，默认的半同步复制方式就是 AFTER_SYNC 方式了，但是方案不是万能的，因为 AFTER_SYNC 方式是在事务同步到Slave后才提交主库的事务的，若是当主库等待Slave同步成功的过程中Master挂了，这个Master事务提交就失败了，客户端也收到了事务执行失败的结果了，但是Slave上已经将binLog的内容写到Relay Log里了，这个时候，Slave数据就会多了，但是多了数据一般问题不算严重，多了总比少了好。MySQL，在没办法解决分布式数据一致性问题的情况下，它能保证的是不丢数据，多了数据总比丢数据要好。</p><p>这里说几个的半同步复制模式的参数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs text">mysql&gt; show variables like &#x27;%Rpl%&#x27;;<br>+-------------------------------------------+------------+<br>| Variable_name                             | Value      |<br>+-------------------------------------------+------------+<br>| rpl_semi_sync_master_enabled              | ON         |<br>| rpl_semi_sync_master_timeout              | 10000      |<br>| rpl_semi_sync_master_trace_level          | 32         |<br>| rpl_semi_sync_master_wait_for_slave_count | 1          |<br>| rpl_semi_sync_master_wait_no_slave        | ON         |<br>| rpl_semi_sync_master_wait_point           | AFTER_SYNC |<br>| rpl_stop_slave_timeout                    | 31536000   |<br>+-------------------------------------------+------------+<br>-- 半同步复制模式开关<br>rpl_semi_sync_master_enabled<br>-- 半同步复制，超时时间，单位毫秒，当超过此时间后，自动切换为异步复制模式 <br>rpl_semi_sync_master_timeout<br>-- MySQL 5.7.3引入的，该变量设置主需要等待多少个slave应答，才能返回给客户端，默认为1。<br>rpl_semi_sync_master_wait_for_slave_count<br>-- 此值代表当前集群中的slave数量是否还能够满足当前配置的半同步复制模式，默认为ON，当不满足半同步复制模式后，全部Slave切换到异步复制，此值也会变为OFF<br>rpl_semi_sync_master_wait_no_slave<br>-- 代表半同步复制提交事务的方式，5.7.2之后，默认为AFTER_SYNC<br>rpl_semi_sync_master_wait_point<br></code></pre></td></tr></table></figure><h5 id="GTID模式"><a href="#GTID模式" class="headerlink" title="GTID模式"></a>GTID模式</h5><p>MySQL从5.6版本开始推出了GTID复制模式，GTID即全局事务ID (global transaction identifier)的简称，GTID是由UUID+TransactionId组成的，UUID是单个MySQL实例的唯一标识，在第一次启动MySQL实例时会自动生成一个server_uuid, 并且默认写入到数据目录下的auto.cnf(mysql&#x2F;data&#x2F;auto.cnf)文件里。TransactionId是该MySQL上执行事务的数量，随着事务数量增加而递增。这样保证了 <strong>GTID在一组复制中，全局唯一</strong> 。</p><p>这样通过GTID可以清晰地看到，当前事务是从哪个实例上提交的，提交的第多少个事务。</p><p>来看一个GTID的具体形式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">mysql&gt; show master status;<br>+-----------+----------+--------------+------------------+-------------------------------------------+<br>| File      | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                         |<br>+-----------+----------+--------------+------------------+-------------------------------------------+<br>| on.000003 |      187 |              |                  | 76147e28-8086-4f8c-9f98-1cf33d92978d:1-322|<br>+-----------+----------+--------------+------------------+-------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>GTID：76147e28-8086-4f8c-9f98-1cf33d92978d:1-322</p><p>UUID：76147e28-8086-4f8c-9f98-1cf33d92978d</p><p>TransactionId:1-322</p><h5 id="GTID的工作原理"><a href="#GTID的工作原理" class="headerlink" title="GTID的工作原理"></a>GTID的工作原理</h5><p>由于GTID在一组主从复制集群中的唯一性，从而保证了每个GTID的事务只在一个MySQL上执行一次。</p><p>那么是怎么实现这种机制的呢？GTID的原理又是什么样的呢？</p><p>当从服务器连接主服务器时，把自己执行过的GTID（ <strong>Executed_Gtid_Set: 即已经执行的事务编码</strong> ）以及获取到GTID（ <strong>Retrieved_Gtid_Set: 即从库已经接收到主库的事务编号</strong> ）都传给主服务器。主服务器会从服务器缺少的GTID以及对应的transactionID都发送给从服务器，让从服务器补全数据。当主服务器宕机时，会找出同步数据最成功的那台conf服务器，直接将它提升为主服务器。若是强制要求某一台不是同步最成功的一台从服务器为主，会先通过change命令到最成功的那台服务器，将GTID进行补全，然后再把强制要求的那台机器提升为主。</p><p>主要数据同步机制可以分为这几步：</p><ul><li>master更新数据时，在事务前生产GTID，一同记录到binlog中。</li><li>slave端的i&#x2F;o线程，将变更的binlog写入到relay log中。</li><li>sql线程从relay log中获取GTID，然后对比Slave端的binlog是否有记录。</li><li>如果有记录，说明该GTID的事务已经执行，slave会忽略该GTID。</li><li>如果没有记录，Slave会从relay log中执行该GTID事务，并记录到binlog。</li><li>在解析过程中，判断是否有主键，如果没有主键就使用二级索引，再没有二级索引就扫描全表。</li></ul><p>初始结构如下图</p><p><img src="https://pic2.zhimg.com/80/v2-c74cf8185cfcf81e654a140b246b0371_720w.webp" alt="img"></p><p>当Master出现宕机后，就会演变成下图。</p><p><img src="https://pic1.zhimg.com/80/v2-3b65e1ed52fa33bf0e601dfdbba4d4a4_720w.webp" alt="img"></p><p>通过上图我们可以看出来，当Master挂掉后，Slave-1执行完了Master的事务，Slave-2延时一些，所以没有执行完Master的事务，这个时候提升Slave-1为主，Slave-2连接了新主（Slave-1）后，将最新的GTID传给新主，然后Slave-1就从这个GTID的下一个GTID开始发送事务给Slave-2。 这种自我寻找复制位置的模式减少事务丢失的可能性以及故障恢复的时间。</p><h5 id="GTID的优劣势"><a href="#GTID的优劣势" class="headerlink" title="GTID的优劣势"></a>GTID的优劣势</h5><p>通过上面的分析我们可以得出GTID的优势是：</p><ul><li>每一个事务对应一个执行ID，一个GTID在一个服务器上只会执行一次;</li><li>GTID是用来代替传统复制的方法，GTID复制与普通复制模式的最大不同就是不需要指定二进制文件名和位置;</li><li>减少手工干预和降低服务故障时间，当主机挂了之后通过软件从众多的备机中提升一台备机为主机;</li></ul><p>GTID的缺点也很明显：</p><ul><li>首先不支持非事务的存储引擎；</li><li>不支持create table … select 语句复制(主库直接报错);(原理: 会生成两个sql, 一个是DDL创建表SQL, 一个是insert into 插入数据的sql; 由于DDL会导致自动提交, 所以这个sql至少需要两个GTID, 但是GTID模式下, 只能给这个sql生成一个GTID)</li><li>不允许一个SQL同时更新一个事务引擎表和非事务引擎表;</li><li>在一个MySQL复制群组中，要求全部开启GTID或关闭GTID。</li><li>开启GTID需要重启 (mysql5.7除外);</li><li>开启GTID后，就不再使用原来的传统复制方式（不像半同步复制，半同步复制失败后，可以降级到异步复制）;</li><li>对于create temporary table 和 drop temporary table语句不支持;</li><li>不支持sql_slave_skip_counter;</li></ul><p>最后说几个开启GTID的必备条件：</p><ul><li>MySQL 5.6 版本，在my.cnf文件中添加:</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">gtid_mode=on (必选)                    #开启gtid功能<br>log_bin=log-bin=mysql-bin (必选)       #开启binlog二进制日志功能<br>log-slave-updates=1 (必选)             #也可以将1写为on<br>enforce-gtid-consistency=1 (必选)      #也可以将1写为on<br></code></pre></td></tr></table></figure><ul><li>MySQL 5.7或更高版本，在my.cnf文件中添加:</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">gtid_mode=on    (必选)<br>enforce-gtid-consistency=1  （必选）<br>log_bin=mysql-bin           （可选）    #高可用切换，最好开启该功能<br>log-slave-updates=1     （可选）       #高可用切换，最好打开该功能<br></code></pre></td></tr></table></figure><blockquote><p>原文链接： <a href="https://link.zhihu.com/?target=http://www.cnblogs.com/jimoer/p/14673646.html">http://www.cnblogs.com/jimoer/p/14</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何确保消息不丢失</title>
    <link href="/2022/09/23/05%20%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1/"/>
    <url>/2022/09/23/05%20%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1/</url>
    
    <content type="html"><![CDATA[<p><strong>Kafka 只对“已提交”的消息（committed message）做有限度的持久化保证。</strong></p><p>第一个核心要素是“<strong>已提交的消息</strong>”。什么是已提交的消息？当 Kafka 的若干个 Broker 成功地接收到一条消息并写入到日志文件后，它们会告诉生产者程序这条消息已成功提交。此时，这条消息在 Kafka 看来就正式变为“已提交”消息了。</p><p>那为什么是若干个 Broker 呢？这取决于对“已提交”的定义。可以选择只要有一个 Broker 成功保存该消息就算是已提交，也可以是令所有 Broker 都成功保存该消息才算是已提交。不论哪种情况，Kafka 只对已提交的消息做持久化保证这件事情是不变的。</p><p>第二个核心要素就是“<strong>有限度的持久化保证</strong>”，也就是说 Kafka 不可能保证在任何情况下都做到不丢失消息。就是说 Kafka 不丢消息是有前提条件的。假如消息保存在 N 个 Kafka Broker 上，那么这个前提条件就是这 N 个 Broker 中至少有 1 个存活。只要这个条件成立，Kafka 就能保证你的这条消息永远不会丢失。</p><p>总结一下，Kafka 是能做到不丢失消息的，只不过这些消息必须是已提交的消息，而且还要满足一定的条件。当然，说明这件事并不是要为 Kafka 推卸责任，而是为了在出现该类问题时能够明确责任边界。</p><h5 id="检测消息丢失的方法"><a href="#检测消息丢失的方法" class="headerlink" title="检测消息丢失的方法"></a>检测消息丢失的方法</h5><p><strong>可以利用消息队列的有序性来验证是否有消息丢失。</strong>原理非常简单，在 Producer 端，给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的连续性。</p><p>如果没有消息丢失，Consumer 收到消息的序号必然是连续递增的，或者说收到的消息，其中的序号必然是上一条消息的序号 +1。如果检测到序号不连续，那就是丢消息了。还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因。</p><p>大多数消息队列的客户端都支持拦截器机制，可以利用这个拦截器机制，在 Producer 发送消息之前的拦截器中将序号注入到消息中，在 Consumer 收到消息的拦截器中检测序号的连续性，这样实现的好处是消息检测的代码不会侵入到业务代码中，待系统稳定后，也方便将这部分检测的逻辑关闭或者删除。</p><p>首先，像 Kafka 和 RocketMQ 这样的消息队列，它是不保证在 Topic 上的严格顺序的，只能保证分区上的消息是有序的，所以在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。</p><p>如果 Producer 是多实例的，由于并不好协调多个 Producer 之间的发送顺序，所以也需要每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续性。</p><p>Consumer 实例的数量最好和分区数量一致，做到 Consumer 和分区一一对应，这样会比较方便地在 Consumer 内检测消息序号的连续性。</p><h5 id="确保消息可靠传递"><a href="#确保消息可靠传递" class="headerlink" title="确保消息可靠传递"></a>确保消息可靠传递</h5><p>一条消息从生产到消费完成这个过程，可以划分三个阶段</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%AB%98%E6%89%8B%E8%AF%BE/assets/81a01f5218614efea2838b0808709205.jpg" alt="img"></p><ul><li><strong>生产阶段</strong>: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker 端。</li><li><strong>存储阶段</strong>: 在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。</li><li><strong>消费阶段</strong>: 在这个阶段，Consumer 从 Broker 上拉取消息，经过网络传输发送到 Consumer 上。</li></ul><p><strong>1. 生产阶段</strong></p><p>在生产阶段，消息队列通过最常用的请求确认机制，来保证消息的可靠传递：当你的代码调用发消息方法时，消息队列的客户端会把消息发送到 Broker，<strong>Broker 收到消息后，会给客户端返回一个确认响应</strong>，表明消息已经收到了。客户端收到响应后，完成了一次正常消息的发送。</p><p>只要 Producer 收到了 Broker 的确认响应，就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户。</p><p><strong>在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失。</strong>以 Kafka 为例，看一下如何可靠地发送消息：</p><p>同步发送时，只要注意捕获异常即可。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">try &#123;<br>    RecordMetadata metadata = producer.send(<span class="hljs-type">record</span>).<span class="hljs-keyword">get</span>();<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot; 消息发送成功。&quot;);<br>&#125; catch (Throwable e) &#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot; 消息发送失败！&quot;);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(e);<br>&#125;<br></code></pre></td></tr></table></figure><p>异步发送时，则需要在回调方法里进行检查。这个地方是需要特别注意的，很多丢消息的原因就是，使用了异步发送，却没有在回调中检查发送结果。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">producer.send(<span class="hljs-type">record</span>, (metadata, <span class="hljs-keyword">exception</span>) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (metadata != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot; 消息发送成功。&quot;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot; 消息发送失败！&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">exception</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>2. 存储阶段</strong></p><p>在存储阶段正常情况下，只要 Broker 在正常运行，就不会出现丢失消息的问题，但是如果 Broker 出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的。</p><p><strong>如果对消息的可靠性要求非常高，可以通过配置 Broker 参数来避免因为宕机丢消息。</strong></p><p>对于单个节点的 Broker，需要配置 Broker 参数，在收到消息后，将消息写入磁盘后再给 Producer 返回确认响应，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息，恢复后还可以继续消费。例如，在 RocketMQ 中，需要将刷盘方式 flushDiskType 配置为 SYNC_FLUSH 同步刷盘。</p><p>如果是 Broker 是由多个节点组成的集群，需要将 Broker 集群配置成：至少将消息发送到 2 个以上的节点，再给客户端回复发送确认响应。这样当某个 Broker 宕机时，其他的 Broker 可以替代宕机的 Broker，也不会发生消息丢失。后面我会专门安排一节课，来讲解在集群模式下，消息队列是如何通过消息复制来确保消息的可靠性的。</p><p><strong>3. 消费阶段</strong></p><p>消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递，客户端从 Broker 拉取消息后，执行用户的消费业务逻辑，成功后，才会给 Broker 发送消费确认响应。如果 Broker 没有收到消费确认响应，下次拉消息的时候还会返回同一条消息，确保消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失。</p><p>在编写消费代码时需要注意的是，<strong>不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。</strong></p><p>同样，以用 Python 语言消费 RabbitMQ 消息为例，来看一下如何实现一段可靠的消费代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def callback(ch, method, properties, body):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; [x] 收到消息 %r&quot;</span> % body)<br>    # 在这儿处理收到的消息<br>    database.save(body)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; [x] 消费完成 &quot;</span>)<br>    # 完成消费业务逻辑后发送消费确认响应<br>    ch.basic_ack(delivery_tag = method.delivery_tag)<br> <br>channel.basic_consume(<span class="hljs-attribute">queue</span>=<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-attribute">on_message_callback</span>=callback)<br></code></pre></td></tr></table></figure><p>可以看到，在消费的回调方法 callback 中，正确的顺序是，先是把消息保存到数据库中，然后再发送消费确认响应。这样如果保存消息到数据库失败了，就不会执行消费确认的代码，下次拉到的还是这条消息，直到消费成功。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>在生产阶段，你需要捕获消息发送的错误，并重发消息。</li><li>在存储阶段，你可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个 Broker 宕机或者磁盘损坏而丢失。</li><li>在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql是怎么保证数据不丢的</title>
    <link href="/2022/08/02/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84%EF%BC%9F/"/>
    <url>/2022/08/02/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。</p><p>那么redo log 的写入流程是怎么样的，如何保证 redo log 真实地写入了磁盘？</p><h5 id="binlog-的写入机制"><a href="#binlog-的写入机制" class="headerlink" title="binlog 的写入机制"></a>binlog 的写入机制</h5><p>其实，binlog 的写入逻辑比较简单：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p><p>一个事务的 binlog 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了 binlog cache 的保存问题。</p><p>系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><p>事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。状态如图 1 所示。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/9ed86644d5f39efb0efec595abb92e3e.png" alt="img"></p><p>图 1 binlog 写盘状态</p><p>可以看到，每个线程有自己 binlog cache，但是共用同一份 binlog 文件。</p><ul><li>图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。</li><li>图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下， 认为 fsync 才占磁盘的 IOPS。</li></ul><p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p><ol><li>sync_binlog&#x3D;0 的时候，表示每次提交事务都只 write，不 fsync；</li><li>sync_binlog&#x3D;1 的时候，表示每次提交事务都会执行 fsync；</li><li>sync_binlog&#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li></ol><p>因此，在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。</p><p>但是，将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。</p><h5 id="redo-log-的写入机制"><a href="#redo-log-的写入机制" class="headerlink" title="redo log 的写入机制"></a>redo log 的写入机制</h5><p>事务在执行过程中，生成的 redo log 是要先写到 redo log buffer 的。</p><p>redo log buffer 里面的内容，是不是每次生成后都要直接持久化到磁盘呢？答案是，不需要。</p><p><strong>如果事务执行期间 MySQL 发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</strong></p><p>那么，另外一个问题是，事务还没提交的时候，redo log buffer 中的部分日志有没有可能被持久化到磁盘呢？</p><p>答案是，确实会有。</p><p>这个问题，要从 redo log 可能存在的三种状态说起。这三种状态，对应的就是图 2 中的三个颜色块。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/9d057f61d3962407f413deebc80526d4.png" alt="img"></p><p>图 2 MySQL redo log 存储状态</p><p>这三种状态分别是：</p><ol><li>存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分；</li><li>写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。</li></ol><p>日志写到 redo log buffer 是很快的，wirte 到 page cache 也差不多，但是持久化到磁盘的速度就慢多了。</p><p>为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：</p><ol><li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li><li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li><li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li></ol><p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p><p>注意，事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。</p><p>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。</p><ol><li><strong>一种是，redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。</strong>注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。</li><li><strong>另一种是，并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。</strong>假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。</li></ol><p>这里需要说明的是，时序上 redo log 先 prepare， 再写 binlog，最后再把 redo log commit。</p><p>如果把 innodb_flush_log_at_trx_commit 设置成 1，那么 redo log 在 prepare 阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于 prepare 的 redo log，再加上 binlog 来恢复的。</p><p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB 就认为 redo log 在 commit 的时候就不需要 fsync 了，只会 write 到文件系统的 page cache 中就够了。</p><p>通常 说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p><p>这时候，你可能有一个疑问，这意味着  从 MySQL 看到的 TPS 是每秒两万的话，每秒就会写四万次磁盘。但是，  用工具测试出来，磁盘能力也就两万左右，怎么能实现两万的 TPS？</p><p>解释这个问题，就要用到组提交（group commit）机制了。</p><p>这里，  需要先介绍日志逻辑序列号（log sequence number，LSN）的概念。LSN 是单调递增的，用来对应 redo log 的一个个写入点。每次写入长度为 length 的 redo log， LSN 的值就会加上 length。</p><p>LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log。关于 LSN 和 redo log、checkpoint 的关系，  会在后面的文章中详细展开。</p><p>如图 3 所示，是三个并发事务 (trx1, trx2, trx3) 在 prepare 阶段，都写完 redo log buffer，持久化到磁盘的过程，对应的 LSN 分别是 50、120 和 160。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/933fdc052c6339de2aa3bf3f65b188cc.png" alt="img"></p><p>图 3 redo log 组提交</p><p>从图中可以看到，</p><ol><li>trx1 是第一个到达的，会被选为这组的 leader；</li><li>等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；</li><li>trx1 去写盘的时候，带的就是 LSN&#x3D;160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；</li><li>这时候 trx2 和 trx3 就可以直接返回了。</li></ol><p>所以，一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p><p>在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。</p><p>为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间。在介绍两阶段提交的时候，  曾经给你画了一个图，现在  把它截过来。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/98b3b4ff7b36d6d72e38029b86870551.png" alt="img"></p><p>图 4 两阶段提交</p><p>图中，  把“写 binlog”当成一个动作。但实际上，写 binlog 是分成两步的：</p><ol><li>先把 binlog 从 binlog cache 中写到磁盘上的 binlog 文件；</li><li>调用 fsync 持久化。</li></ol><p>MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后。也就是说，上面的图变成了这样：</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/5ae7d074c34bc5bd55c82781de670c28.png" alt="img"></p><p>图 5 两阶段提交细化</p><p>这么一来，binlog 也可以组提交了。在执行图 5 中第 4 步把 binlog fsync 到磁盘时，如果有多个事务的 binlog 已经写完了，也是一起持久化的，这样也可以减少 IOPS 的消耗。</p><p>不过通常情况下第 3 步执行得会很快，所以 binlog 的 write 和 fsync 间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如 redo log 的效果那么好。</p><p>如果你想提升 binlog 组提交的效果，可以通过设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 来实现。</p><ol><li>binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</li><li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</li></ol><p>这两个条件是或的关系，也就是说只要有一个满足条件就会调用 fsync。</p><p>所以，当 binlog_group_commit_sync_delay 设置为 0 的时候，binlog_group_commit_sync_no_delay_count 也无效了。</p><p>之前有同学在评论区问到，WAL 机制是减少磁盘写，可是每次提交事务都要写 redo log 和 binlog，这磁盘读写次数也没变少呀？</p><p>现在你就能理解了，WAL 机制主要得益于两个方面：</p><ol><li><strong>redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快；</strong></li><li><strong>组提交机制，可以大幅度降低磁盘的 IOPS 消耗。</strong></li></ol><p>分析到这里， 再来回答这个问题：<strong>如果你的 MySQL 现在出现了性能瓶颈，而且瓶颈在 IO 上，可以通过哪些方法来提升性能呢？</strong></p><p>针对这个问题，可以考虑以下三种方法：</p><ol><li><strong>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</strong></li><li><strong>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</strong></li><li><strong>将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。</strong></li></ol><p>  不建议你把 innodb_flush_log_at_trx_commit 设置成 0。因为把这个参数设置成 0，表示 redo log 只保存在内存中，这样的话 MySQL 本身异常重启也会丢数据，风险太大。而 redo log 写到文件系统的 page cache 的速度也是很快的，所以将这个参数设置成 2 跟设置成 0 其实性能差不多，但这样做 MySQL 异常重启时就不会丢数据了，相比之下风险会更小。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>在专栏的[第 2 篇]和[第 15 篇]文章中，     分析了，如果 redo log 和 binlog 是完整的，MySQL 是如何保证 crash-safe 的。今天这篇文章，  着重   介绍的是 MySQL 是“怎么保证 redo log 和 binlog 是完整的”。</p><p>希望这三篇文章串起来的内容，能够让你对 crash-safe 这个概念有更清晰的理解。</p><p>之前的第 15 篇答疑文章发布之后，有同学继续留言问到了一些跟日志相关的问题，这里为了方便你回顾、学习，  再集中回答一次这些问题。</p><p><strong>问题 1：</strong>执行一个 update 语句以后，  再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢？</p><p>回答：这可能是因为 WAL 机制的原因。update 语句执行完成后，InnoDB 只保证写完了 redo log、内存，可能还没来得及将数据写到磁盘。</p><p><strong>问题 2：</strong>为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</p><p>回答：MySQL 这么设计的主要原因是，binlog 是不能“被打断的”。一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。</p><p>而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中。redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p><p><strong>问题 3：</strong>事务执行期间，还没到提交阶段，如果发生 crash 的话，redo log 肯定丢了，这会不会导致主备不一致呢？</p><p>回答：不会。因为这时候 binlog 也还在 binlog cache 里，没发给备库。crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p><p><strong>问题 4：</strong>如果 binlog 写完盘以后发生 crash，这时候还没给客户端答复就重启了。等客户端再重连进来，发现事务已经提交成功了，这是不是 bug？</p><p>回答：不是。</p><p>你可以设想一下更极端的情况，整个事务都提交成功了，redo log commit 完成了，备库也收到 binlog 并执行了。但是主库和客户端网络断开了，导致事务成功的包返回不回去，这时候客户端也会收到“网络断开”的异常。这种也只能算是事务成功的，不能认为是 bug。</p><p>实际上数据库的 crash-safe 保证的是：</p><ol><li>如果客户端收到事务成功的消息，事务就一定持久化了；</li><li>如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了；</li><li>如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。<strong>此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。</strong></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么选择B+树作为索引的数据结构</title>
    <link href="/2022/01/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h5 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h5><ul><li><strong>索引</strong>是帮助MySQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong></li><li>索引数据结构<ul><li>二叉树</li><li>红黑树</li><li>Hash表</li><li>B-Tree</li></ul></li><li>索引的建立就是数据排序的过程</li></ul><h5 id="为什么二叉树不适合做索引"><a href="#为什么二叉树不适合做索引" class="headerlink" title="为什么二叉树不适合做索引"></a>为什么二叉树不适合做索引</h5><ul><li><p>因为当数据在插入的数据，如果是排好序的，二叉树则会退化成链表，这样就失去了索引的意义。特别是自增主键，默认就是会建索引的。</p></li><li><p><img src="https://image-show.oss-cn-shenzhen.aliyuncs.com/typora_img/image-20210302220334083.png" alt="image-20210302220334083"></p></li></ul><h5 id="为什么红黑树不适合做索引"><a href="#为什么红黑树不适合做索引" class="headerlink" title="为什么红黑树不适合做索引"></a>为什么红黑树不适合做索引</h5><ul><li>因为红黑树是弱平衡树，如果插入的数据是排好序的，则只会单边增长，查询效率依然不高效。特别是自增数据量大的时候，高度非常大。</li></ul><p><a href="https://image-show.oss-cn-shenzhen.aliyuncs.com/typora_img/image-20210302220226726.png"><img src="https://image-show.oss-cn-shenzhen.aliyuncs.com/typora_img/image-20210302220226726.png" alt="image-20210302220226726"></a></p><h5 id="为什么Hash表不适合做索引"><a href="#为什么Hash表不适合做索引" class="headerlink" title="为什么Hash表不适合做索引"></a>为什么Hash表不适合做索引</h5><ul><li>哈希表对于范围查找和排序效率低，但对于单个数据的查询效率很高。</li></ul><h5 id="B-Tree结构"><a href="#B-Tree结构" class="headerlink" title="B-Tree结构"></a>B-Tree结构</h5><ul><li>叶节点具有相同的深度，叶节点的指针为空</li><li>所有索引元素不重复</li><li>节点中的数据索引从左到右递增排列</li></ul><p><a href="https://image-show.oss-cn-shenzhen.aliyuncs.com/typora_img/image-20210302220611151.png"><img src="https://image-show.oss-cn-shenzhen.aliyuncs.com/typora_img/image-20210302220611151.png" alt="image-20210302220611151"></a></p><h5 id="B-Tree结构-1"><a href="#B-Tree结构-1" class="headerlink" title="B+Tree结构"></a>B+Tree结构</h5><ul><li>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引</li><li>叶子节点包含所有索引字段</li><li>叶子节点用指针链接，提高区间访问性能；</li></ul><p><a href="https://image-show.oss-cn-shenzhen.aliyuncs.com/typora_img/image-20210302220741769.png"><img src="https://image-show.oss-cn-shenzhen.aliyuncs.com/typora_img/image-20210302220741769.png" alt="image-20210302220741769"></a></p><h5 id="MySQL-为什么使用-B-树来作索引"><a href="#MySQL-为什么使用-B-树来作索引" class="headerlink" title="MySQL 为什么使用 B+ 树来作索引"></a>MySQL 为什么使用 B+ 树来作索引</h5><ul><li>由于mysql通常将数据存放在磁盘中，读取数据就会产生磁盘IO消耗。而B+树的非叶子节点中不保存数据，B树中非叶子节点会保存数据，通常一个节点大小会设置为磁盘页大小，<strong>这样B+树每个节点可放更多的key，B树则更少。这样就造成了，B树的高度会比B+树更高，从而会产生更多的磁盘IO消耗。</strong></li><li>B+树叶子节点构成链表，更利用范围查找和排序。而B树进行范围查找和排序则要对树进行递归遍历</li></ul><h5 id="B树与B-树比较"><a href="#B树与B-树比较" class="headerlink" title="B树与B+树比较"></a>B树与B+树比较</h5><ul><li>B+树层级更少，查找更快</li><li>B+树查询速度稳定：<strong>由于B+树所有数据都存储在叶子节点，所以查询任意数据的次数都是树的高度h</strong></li><li>B+树有利于范围查找</li><li>B+树全节点遍历更快：所有叶子节点构成链表，全节点扫描，只需遍历这个链表即可</li><li>B树优点：如果在B树中查找的数据离根节点近，由于B树节点中保存有数据，那么这时查询速度比B+树快。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql MVCC</title>
    <link href="/2022/01/13/mysql%20MVCC/"/>
    <url>/2022/01/13/mysql%20MVCC/</url>
    
    <content type="html"><![CDATA[<p>![image-20210813102852376](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210813102852376.png)</p><h5 id="可重复读级别下"><a href="#可重复读级别下" class="headerlink" title="可重复读级别下"></a>可重复读级别下</h5><p>Q1为3，Q2为1</p><p>k这一行数据会有多个版本号，这个版本号就是每个事务的transactionId（简称t_id），t_id是每个事务的唯一主键，是每个事务开始的时候向INNODB的事务系统申请的，是按申请顺序严格递增的，每次事务更新数据的时候，都会生成一个新的数据版本，并且把t_id赋值给这个数据版本的事务ID ，记为row t_id ,同时，这行数据旧的数据版本也要保留。</p><p><strong>也就是说，数据表中的一行记录，其实可能有多个版本，每个版本有自己的row t_id</strong></p><p>![image-20210813103537224](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210813103537224.png)</p><p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果，但是之后，这个事务执行期间，其它事务的更新对它不可见。</p><p>因此，INNODB代码实现上，一个事务只需要在启动的时候，找到所有已经提交的事务ID的最大值，记为Up_limit_id，如果一个数据版本的row t_id大于up_limit_id，就不承认这个版本，必须要找到它的上一个版本。当然，如果一个事务自己更新的数据，自己还是要认的。</p><p>后面新的事务产生的row t_id肯定是大于up_limit_id的，对当前事务肯定是不可见的，但如果说，有一个事务早于当前事务启动，并且在后面更新了数据，由于这个事务早于当前事务开启，t_id也就小于当前事务的t_id,那么，当前事务会认可这个数据版本吗？ 答案是不会的，因为除了上面说的那个规则，还有一个规则就是：事务启动的时候还要保存“现在正在执行的所有事务ID列表” ，如果一个row t_id在这列表中，也要不可见。</p><p>接下来，看一下为什么Q2的结果是1；</p><p>假设： 事务A开始前，系统里已经提交的事务最大ID，即up_limit_id是99；</p><p>事务A、B、C的版本号分别是100、101、102，且当前系统里没有别的事务；</p><p>三个事务开始前，（1，1）这一行数据的row t_id是90。</p><p>这样，事务A、B、C的up_limit_id都是99</p><p>![image-20210813105845254](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210813105845254.png)</p><p>流程：第一个有效更新是事务C，把数据从（1，1）改成了（1，2）。这个时候，这条数据的最新版本的rowt t_id是102，而90成了历史版本。</p><p>第二个有效更新是事务B，把数据从（1，2）改成了（1，3），这个数据的最新版本row t_id是101，102成了历史版本。</p><p>现在事务A来读数据了，它的up_limit_id是99。</p><p>找到（1，3）的时候，判 断row t_id &#x3D; 101 &gt; 99，要不起；</p><p>找上一个历史版本，一看row t_id &#x3D; 102；还是要不起；</p><p>往前找，（1，1），row t_id &#x3D; 90 ，是可见数据了。</p><p>（1，1）这个历史版本在事务A提交后，就会被删掉。</p><p>假设事务A在读取K之前先执行一次update语句，会是什么结果？</p><p>事务A会拿到最新的数据，（1，3）进行update变成（1，4），再次执行select，拿出来就是（1，4）了。</p><p>因为更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读” current read；</p><p>所以更新的时候，就把row t_id更新为100了，自己的up_limit_id也变成了100，查询的时候，row t_id &#x3D; up_limit_id ，是可见的数据了。</p><h5 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h5><p><strong>快照读的幻读是用MVCC解决的，当前的读的幻读是用间隙锁解决的。</strong></p><p>innodb的默认事务隔离级别是rr（可重复读）。它的实现技术是mvcc。该技术不仅可以保证innodb的可重复读，而且可以防止幻读。（这也就是是此前以rr隔离级别实践时，不仅可以防止可重复读，也防止了幻读）但是它防止的是快照读，也就是读取的数据虽然是一致的，但是数据是历史数据。</p><blockquote><p>这个帖子里面就有一个实例：<a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">MySQL的InnoDB的幻读问题</a><br>一些文章写到InnoDB的可重复读避免了“幻读”（phantom read），这个说法并不准确。</p></blockquote><p>那InnoDB指出的可以避免幻读是怎么回事呢？</p><blockquote><p>以下翻译自MySQL官网文档（<a href="http://download.nust.na/pub6/mysql/doc/refman/5.5/en/innodb-next-key-locking.html%EF%BC%89%EF%BC%8C%E7%BF%BB%E8%AF%91%E6%B0%B4%E5%B9%B3%E4%B8%80%E8%88%AC%EF%BC%8C%E8%AF%B7%E8%A7%81%E8%B0%85%E3%80%82">http://download.nust.na/pub6/mysql/doc/refman/5.5/en/innodb-next-key-locking.html），翻译水平一般，请见谅。</a></p></blockquote><p>当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读。也就是说的间隙锁。</p><p>InnoDB提供了next-key locks，但需要应用程加锁</p><p>举个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> child <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql事务隔离</title>
    <link href="/2022/01/11/03%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81%EF%BC%9F/"/>
    <url>/2022/01/11/03%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p><h5 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h5><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T(c <span class="hljs-type">int</span>) engine<span class="hljs-operator">=</span>InnoDB;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> T(c) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/7dea45932a6b722eb069d2264d0066f8.png" alt="img"></p><p>我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。</p><ul><li>若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li><li>若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</li><li>若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</li></ul><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。</p><p>配置的方式是，将启动参数 transaction-isolation 的值设置成 READ-COMMITTED。你可以用 show variables 来查看当前的值。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; show variables like <span class="hljs-emphasis">&#x27;transaction_isolation&#x27;</span>;<br><span class="hljs-section"> </span><br><span class="hljs-section">+-----------------------+----------------+</span><br><span class="hljs-code"> </span><br>| Variable<span class="hljs-emphasis">_name | Value |</span><br><span class="hljs-emphasis"> </span><br><span class="hljs-emphasis">+-----------------------+----------------+</span><br><span class="hljs-emphasis"> </span><br><span class="hljs-emphasis">| transaction_</span>isolation | READ-COMMITTED |<br><span class="hljs-section"> </span><br><span class="hljs-section">+-----------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想<strong>你可能会问那什么时候需要“可重复读”的场景呢</strong>？我们来看一个数据校对逻辑的案例。</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p><h5 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h5><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/assets/d9c313809e5ac148fc39feff532f0fee.png" alt=" img"></p><p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p><p>回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p><p>为什么建议尽量不要使用长事务。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p><p>总结事务隔离的实现：</p><ol><li>锁机制：MySQL 使用锁来控制并发事务对数据的访问。在不同的隔离级别下，MySQL 采用不同的锁策略。比如，在可重复读隔离级别下，通过行级锁（Record-Level Locking）来保证事务对数据的独占性。</li><li>MVCC（多版本并发控制）：MySQL 通过在每个数据行上保存多个版本来实现事务的隔离。每个事务在读取数据时，会根据自己的事务 ID（Transaction ID）和快照版本号（Snapshot Version）来确定可见的数据。这样可以避免了读取到未提交或已删除的脏数据。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一条sql更新语句是如何执行的？</title>
    <link href="/2022/01/11/02_%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/"/>
    <url>/2022/01/11/02_%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>一条更新语句的执行流程是怎样的呢？</p><p>MySQL 可以恢复到半个月内任意一秒的状态，这是怎样做到的呢？</p><p>下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T(<br>ID <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>c <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>如果要将 ID&#x3D;2 这一行的值加 1，SQL 语句就会这么写：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysql&gt; update T <span class="hljs-built_in">set</span> <span class="hljs-attribute">c</span>=c+1 where <span class="hljs-attribute">ID</span>=2;<br></code></pre></td></tr></table></figure><p>查询语句的那一套流程，更新语句也是同样会走一遍。</p><p><a href="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png"><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></a>img</p><p>MySQL 的逻辑架构图</p><p>执行语句前要先连接数据库，这是连接器的工作。</p><p>在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL，那这两个词肯定是绕不过的</p><h5 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h5><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><a href="https://static001.geekbang.org/resource/image/b0/9c/b075250cad8d9f6c791a52b6a600f69c.jpg"><img src="https://static001.geekbang.org/resource/image/b0/9c/b075250cad8d9f6c791a52b6a600f69c.jpg" alt="img"></a>img</p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><h5 id="为什么-redo-log-具有-crash-safe-的能力，而-binlog-没有？"><a href="#为什么-redo-log-具有-crash-safe-的能力，而-binlog-没有？" class="headerlink" title="为什么 redo log 具有 crash-safe 的能力，而 binlog 没有？"></a>为什么 redo log 具有 crash-safe 的能力，而 binlog 没有？</h5><p>一个事务提交之后，mysql挂了，修改的数据不一定已经落盘了，所以需要redo log。</p><p>redo log 是什么？</p><p>一个固定大小，<strong>“循环写”</strong>的日志文件，记录的是物理日志——“在某个数据页上做了某个修改”。</p><p>binlog 是什么？</p><p>一个无限大小，<strong>“追加写”</strong>的日志文件，记录的是逻辑日志——“给 ID&#x3D;2 这一行的 c 字段加1”。</p><p>redo log 和 binlog 有一个很大的区别就是，一个是循环写，一个是追加写。也就是说 redo log 只会记录未刷盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。binlog 是追加日志，保存的是全量的日志。</p><p>当<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a> crash 后，想要恢复<strong>未刷盘但已经写入 redo log 和 binlog 的数据</strong>到内存时，binlog 是无法恢复的。虽然 binlog 拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有。</p><p>举个栗子，binlog 记录了两条日志：</p><ol><li>给 ID&#x3D;2 这一行的 c 字段加1</li><li>给 ID&#x3D;2 这一行的 c 字段加1</li></ol><p>在记录1刷盘后，记录2未刷盘时，数据库 crash。重启后，只通过 binlog 数据库无法判断这两条记录哪条已经写入磁盘，哪条没有写入磁盘，不管是两条都恢复至内存，还是都不恢复，对 ID&#x3D;2 这行数据来说，都不对。</p><p>但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中抹掉，数据库重启后，直接把 redo log 中的数据都恢复至内存(buffer pool)就可以了。这就是为什么 redo log 具有 crash-safe 的能力，而 binlog 不具备。</p><h5 id="当数据库-crash-后，如何恢复未刷盘的数据到内存中？"><a href="#当数据库-crash-后，如何恢复未刷盘的数据到内存中？" class="headerlink" title="当数据库 crash 后，如何恢复未刷盘的数据到内存中？"></a>当数据库 crash 后，如何恢复未刷盘的数据到内存中？</h5><p>根据 redo log 和 binlog 的两阶段提交，未持久化的数据分为几种情况：</p><ol><li>change buffer 写入，redo log 虽然做了 fsync 但未 commit，binlog 未 fsync 到磁盘，这部分数据丢失。</li><li>change buffer 写入，redo log fsync 未 commit，binlog 已经 fsync 到磁盘，先从 binlog 恢复 redo log，再从 redo log 恢复 change buffer。</li><li>change buffer 写入，redo log 和 binlog 都已经 fsync，直接从 redo log 里恢复。</li></ol><p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h5 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h5><p>前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p><p>这两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p><ol><li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p>这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p><p><a href="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png"><img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img"></a>img</p><p>update 语句执行流程</p><p>你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。</p><h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><p>前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的 update 语句来做例子。假设当前 ID&#x3D;2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><ol><li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<br>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。<br>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li><li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p><p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h5 id="在两阶段提交的不同时刻，MySQL-异常重启会出现什么现象。"><a href="#在两阶段提交的不同时刻，MySQL-异常重启会出现什么现象。" class="headerlink" title="在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象。"></a><strong>在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象。</strong></h5><p>如果在图中时刻 A 的地方，也就是写入 redo log 处于 prepare 阶段之后、写 binlog 之前，发生了崩溃（crash），由于此时 binlog 还没写，redo log 也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog 还没写，所以也不会传到备库。到这里，大家都可以理解。</p><p>大家出现问题的地方，主要集中在时刻 B，也就是 binlog 写完，redo log 还没 commit 前发生 crash，那崩溃恢复的时候 MySQL 会怎么处理？</p><p>我们先来看一下崩溃恢复时的判断规则。</p><ol><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；</li><li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整： a. 如果是，则提交事务； b. 否则，回滚事务。</li></ol><p>这里，时刻 B 发生 crash 对应的就是 2(a) 的情况，崩溃恢复过程中事务会被提交。</p><p>现在，我们继续延展一下这个问题。</p><h5 id="追问-1：MySQL-怎么知道-binlog-是完整的"><a href="#追问-1：MySQL-怎么知道-binlog-是完整的" class="headerlink" title="追问 1：MySQL 怎么知道 binlog 是完整的?"></a>追问 1：MySQL 怎么知道 binlog 是完整的?</h5><p>回答：一个事务的 binlog 是有完整格式的：</p><ul><li>statement 格式的 binlog，最后会有 COMMIT；</li><li>row 格式的 binlog，最后会有一个 XID event。</li></ul><p>另外，在 MySQL 5.6.2 版本以后，还引入了 binlog-checksum 参数，用来验证 binlog 内容的正确性。对于 binlog 日志由于磁盘原因，可能会在日志中间出错的情况，MySQL 可以通过校验 checksum 的结果来发现。所以，MySQL 还是有办法验证事务 binlog 的完整性的。</p><h5 id="追问-2：redo-log-和-binlog-是怎么关联起来的"><a href="#追问-2：redo-log-和-binlog-是怎么关联起来的" class="headerlink" title="追问 2：redo log 和 binlog 是怎么关联起来的?"></a>追问 2：redo log 和 binlog 是怎么关联起来的?</h5><p>回答：它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p><ul><li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</li><li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</li></ul><h5 id="追问-3：处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计"><a href="#追问-3：处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计" class="headerlink" title="追问 3：处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?"></a>追问 3：处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?</h5><p>回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻 B，也就是 binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。</p><p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><h5 id="追问-4：如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#追问-4：如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="追问 4：如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>追问 4：如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h5><p>回答：其实，两阶段提交是经典的分布式系统问题，并不是 MySQL 独有的。</p><p>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。</p><p>对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果 redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和 binlog 日志又不一致了。</p><p>两阶段提交就是为了给所有人一个机会，当每个人都说“我 ok”的时候，再一起提交。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用mycat分库分表</title>
    <link href="/2021/06/09/mycat%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <url>/2021/06/09/mycat%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>由于公司部分项目使用了mycat来做分库分表，所以就花了点时间了解一下mycat</p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>下面是mycat主要配置文件</p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>mycat命令，启动、重启、停止等</td></tr><tr><td>catlet</td><td>catlet为Mycat的一个扩展功能</td></tr><tr><td>conf</td><td>Mycat 配置信息,重点关注</td></tr><tr><td>lib</td><td>Mycat引用的jar包，Mycat是java开发的</td></tr><tr><td>logs</td><td>日志文件，包括Mycat启动的日志和运行的日志。</td></tr></tbody></table><p>Mycat的配置文件都在conf目录里面，这里介绍几个常用的文件：</p><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>server.xml</td><td>Mycat的配置文件，设置账号、参数等</td></tr><tr><td>schema.xml</td><td>Mycat对应的物理数据库和数据库表的配置</td></tr><tr><td>rule.xml</td><td>Mycat分片（分库分表）规则</td></tr></tbody></table><p>Mycat的架构其实很好理解，Mycat是代理，Mycat后面就是物理数据库。和Web服务器的Nginx类似。对于使用者来说，访问的都是Mycat，不会接触到后端的数据库。<br>我们现在做一个主从、读写分离，简单分表的示例。</p><table><thead><tr><th>服务器</th><th>IP</th><th>说明</th></tr></thead><tbody><tr><td>Mycat</td><td>192.168.0.2</td><td>mycat服务器，连接数据库时，连接此服务器</td></tr><tr><td>database1</td><td>192.168.0.3</td><td>物理数据库1，真正存储数据的数据库</td></tr><tr><td>database2</td><td>192.168.0.4</td><td>物理数据库2，真正存储数据的数据库</td></tr></tbody></table><p>Mycat作为主数据库中间件，肯定是与代码弱关联的，所以代码是不用修改的，使用Mycat后，连接数据库是不变的，默认端口是8066。连接方式和普通数据库一样，如：jdbc:mysql:&#x2F;&#x2F;192.168.0.2:8066&#x2F;</p><p><strong>server.xml</strong></p><p>示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;schemas&quot;</span>&gt;</span>lunch<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;readOnly&quot;</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br><br><span class="hljs-comment">&lt;!-- 表级 DML 权限设置 --&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">&lt;privileges check=&quot;false&quot;&gt;</span><br><span class="hljs-comment">&lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt;</span><br><span class="hljs-comment">&lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt;</span><br><span class="hljs-comment">&lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt;</span><br><span class="hljs-comment">&lt;/schema&gt;</span><br><span class="hljs-comment">&lt;/privileges&gt;</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br></code></pre></td></tr></table></figure><p>重点关注下面这段，其他默认即可。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>user</td><td>用户配置节点</td></tr><tr><td>–name</td><td>登录的用户名，也就是连接Mycat的用户名</td></tr><tr><td>–password</td><td>登录的密码，也就是连接Mycat的密码</td></tr><tr><td>–schemas</td><td>数据库名，这里会和schema.xml中的配置关联，多个用逗号分开，例如需要这个用户需要管理两个数据库db1,db2，则配置db1,dbs</td></tr><tr><td>–privileges</td><td>配置用户针对表的增删改查的权限，具体见文档吧</td></tr></tbody></table><p>我这里配置了一个账号test 密码也是test,针对数据库lunch,读写权限都有，没有针对表做任何特殊的权限。</p><p><strong>schema.xml</strong><br>schema.xml是最主要的配置项，首先看我的配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mycat</span>:schema <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;schema.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mycat:schema</span> <span class="hljs-attr">xmlns:mycat</span>=<span class="hljs-string">&quot;http://io.mycat/&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 数据库配置，与server.xml中的数据库对应 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lunch&quot;</span> <span class="hljs-attr">checkSQLschema</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">sqlMaxLimit</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lunchmenu&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;restaurant&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userlunch&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dictionary&quot;</span> <span class="hljs-attr">primaryKey</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">autoIncrement</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1,dn2&quot;</span>  <span class="hljs-attr">rule</span>=<span class="hljs-string">&quot;mod-long&quot;</span> /&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 分片配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn1&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;test1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;lunch&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn2&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;test2&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;lunch&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 物理数据库配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test1&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user();<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostM1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;192.168.0.2:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test2&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user();<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostS1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;192.168.0.3:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mycat:schema</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>schema</td><td>数据库设置，此数据库为逻辑数据库，name与server.xml中schema对应</td></tr><tr><td>dataNode</td><td>分片信息，也就是分库相关配置</td></tr><tr><td>dataHost</td><td>物理数据库，真正存储数据的数据库</td></tr></tbody></table><p>每个节点的属性逐一说明：</p><p><strong>schema:</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>逻辑数据库名，与server.xml中的schema对应</td></tr><tr><td>checkSQLschema</td><td>数据库前缀相关设置，建议看文档，这里暂时设为folse</td></tr><tr><td>sqlMaxLimit</td><td>select 时默认的limit，避免查询全表</td></tr></tbody></table><p><strong>table:</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>表名，物理数据库中表名</td></tr><tr><td>dataNode</td><td>表存储到哪些节点，多个节点用逗号分隔。节点为下文dataNode设置的name</td></tr><tr><td>primaryKey</td><td>主键字段名，自动生成主键时需要设置</td></tr><tr><td>autoIncrement</td><td>是否自增</td></tr><tr><td>rule</td><td>分片规则名，具体规则下文rule详细介绍</td></tr></tbody></table><p><strong>dataNode</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>节点名，与table中dataNode对应</td></tr><tr><td>datahost</td><td>物理数据库名，与datahost中name对应</td></tr><tr><td>database</td><td>物理数据库中数据库名</td></tr></tbody></table><p><strong>dataHost</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>物理数据库名，与dataNode中dataHost对应</td></tr><tr><td>balance</td><td>均衡负载的方式</td></tr><tr><td>writeType</td><td>写入方式</td></tr><tr><td>dbType</td><td>数据库类型</td></tr><tr><td>heartbeat</td><td>心跳检测语句，注意语句结尾的分号要加。</td></tr></tbody></table><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><h5 id="数据库分表分库"><a href="#数据库分表分库" class="headerlink" title="数据库分表分库"></a>数据库分表分库</h5><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mycat</span>:schema <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;schema.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mycat:schema</span> <span class="hljs-attr">xmlns:mycat</span>=<span class="hljs-string">&quot;http://io.mycat/&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 数据库配置，与server.xml中的数据库对应 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lunch&quot;</span> <span class="hljs-attr">checkSQLschema</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">sqlMaxLimit</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lunchmenu&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;restaurant&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userlunch&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dictionary&quot;</span> <span class="hljs-attr">primaryKey</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">autoIncrement</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1,dn2&quot;</span>  <span class="hljs-attr">rule</span>=<span class="hljs-string">&quot;mod-long&quot;</span> /&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 分片配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn1&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;test1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;lunch&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn2&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;test2&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;lunch&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 物理数据库配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test1&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user();<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostM1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;192.168.0.2:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test2&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user();<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostS1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;192.168.0.3:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mycat:schema</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我在192.168.0.2、192.168.0.3均有数据库lunch。<br>lunchmenu、restaurant、userlunch、users这些表都只写入节点dn1，也就是192.168.0.2这个服务，而dictionary写入了dn1、dn2两个节点，也就是192.168.0.2、192.168.0.3这两台服务器。分片的规则为：mod-long。<br>主要关注rule属性，rule属性的内容来源于rule.xml这个文件，Mycat支持10种分表分库的规则，基本能满足你所需要的要求，这个必须赞一个，其他数据库中间件好像都没有这么多。<br>table中的rule属性对应的就是rule.xml文件中tableRule的name,具体有哪些分表和分库的实现，建议还是看下文档。我这里选择的mod-long就是将数据平均拆分。因为我后端是两台物理库，所以rule.xml中mod-long对应的function count为2，见下面部分代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tableRule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mod-long&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">columns</span>&gt;</span>id<span class="hljs-tag">&lt;/<span class="hljs-name">columns</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">algorithm</span>&gt;</span>mod-long<span class="hljs-tag">&lt;/<span class="hljs-name">algorithm</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tableRule</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">function</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mod-long&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- how many data nodes --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">function</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h5><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mycat</span>:schema <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;schema.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mycat:schema</span> <span class="hljs-attr">xmlns:mycat</span>=<span class="hljs-string">&quot;http://io.mycat/&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 数据库配置，与server.xml中的数据库对应 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lunch&quot;</span> <span class="hljs-attr">checkSQLschema</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">sqlMaxLimit</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lunchmenu&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;restaurant&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userlunch&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dictionary&quot;</span> <span class="hljs-attr">primaryKey</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">autoIncrement</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>  /&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 分片配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn1&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;test1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;lunch&quot;</span> /&gt;</span><br><br><br><span class="hljs-comment">&lt;!-- 物理数据库配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test1&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user();<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostM1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;192.168.0.2:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">readHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostM1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;192.168.0.3:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">readHost</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mycat:schema</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样的配置与前一个示例配置改动如下：<br>删除了table分配的规则,以及datanode只有一个<br>datahost也只有一台，但是writehost总添加了readhost,balance改为1，表示读写分离。<br>以上配置达到的效果就是102.168.0.2为主库，192.168.0.3为从库。</p><p>注意：<strong>Mycat主从分离只是在读的时候做了处理，写入数据的时候，只会写入到writehost，需要通过mycat的主从复制将数据复制到readhos</strong>t，这个问题当时候我纠结了好久，数据写入writehost后，readhost一直没有数据，以为是自己配置的问题，后面才发现Mycat就没有实现主从复制的功能，毕竟数据库本身自带的这个功能才是最高效稳定的。</p><blockquote><p>至于其他的场景，如同时主从和分表分库也是支持的了，只要了解这个实现以后再去修改配置，都是可以实现的。而热备及故障专业官方推荐使用haproxy配合一起使用，大家可以试试。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5539408/y56e3jms3a.png?imageView2/2/w/1200" alt="img"></p></blockquote><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>Mycat的启动也很简单，启动命令在Bin目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#启动</span></span><br>mycat start<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#停止</span></span><br>mycat stop<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#重启</span></span><br>mycat restart<br></code></pre></td></tr></table></figure><p>如果在启动时发现异常，在logs目录中查看日志。</p><ul><li>wrapper.log 为程序启动的日志，启动时的问题看这个</li><li>mycat.log 为脚本执行时的日志，SQL脚本执行报错后的具体错误内容,查看这个文件。mycat.log是最新的错误日志，历史日志会根据时间生成目录保存。</li></ul><p>mycat启动后，执行命令不成功，可能实际上配置有错误，导致后面的命令没有很好的执行。</p><p>Mycat带来的最大好处就是使用是完全不用修改原有代码的，在mycat通过命令启动后，你只需要将数据库连接切换到Mycat的地址就可以了。如下面就可以进行连接了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>h192<span class="hljs-number">.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-operator">-</span>P8806 <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p123456<br></code></pre></td></tr></table></figure><p>连接成功后可以执行sql脚本了。<br>所以，可以直接通过sql管理工具（如：navicat、datagrip）连接，执行脚本。我一直用datagrip来进行日常简单的管理，这个很方便。</p><p>Mycat还有一个管理的连接，端口号是9906.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>h192<span class="hljs-number">.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-operator">-</span>P9906 <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p123456<br></code></pre></td></tr></table></figure><p>连接后可以根据管理命令查看Mycat的运行情况，当然，喜欢UI管理方式的人，可以安装一个Mycat-Web来进行管理，有兴趣自行搜索。</p><p>简而言之，开发中使用Mycat和直接使用Mysql机会没有差别。</p><h5 id="myCat查询原理"><a href="#myCat查询原理" class="headerlink" title="myCat查询原理"></a>myCat查询原理</h5><blockquote><p><strong>核心原理：</strong><br> a、非分片关键字（取模的字段）查询会搜索所有的分库分表，结果归并后按照sql语句排序返回，如果未设置排序，则按分库随机返回结果<br> b、分片关键字查询会直接定位到对应的分库，执行相应的sql语句返回结果。</p></blockquote><p>以求模分片方式为例验证：<br> 修改&#x2F;usr&#x2F;local&#x2F;mycat&#x2F;conf&#x2F;log4j2.xml日志级别为debug，即可查询查询语句。</p><h5 id="1-非分片关键字查询，则会读取所有分片中的结果，然后按sql需求返回。"><a href="#1-非分片关键字查询，则会读取所有分片中的结果，然后按sql需求返回。" class="headerlink" title="1.非分片关键字查询，则会读取所有分片中的结果，然后按sql需求返回。"></a>1.非分片关键字查询，则会读取所有分片中的结果，然后按sql需求返回。</h5><p>![image-20230603160350838](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230603160350838.png)</p><h5 id="2-分片关键字查询，则直接读取所在库。"><a href="#2-分片关键字查询，则直接读取所在库。" class="headerlink" title="2.分片关键字查询，则直接读取所在库。"></a>2.分片关键字查询，则直接读取所在库。</h5><p>![image-20230603160406237](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230603160406237.png)</p><p>（<strong>如果是C端，一般不存在全量查询，所以比较适合mycat，但如果是后台数据报表的需求，很多全量查询的话，性能就不好了</strong>）</p><h5 id="mycat缺点"><a href="#mycat缺点" class="headerlink" title="mycat缺点"></a>mycat缺点</h5><p>1、<code>Mycat</code>单库分表需要准备空白表，提前制定好分表规则。</p><p>分表的时候使用到了该字段作为分表字段，数据会按照制定好的分表规则存入不同的数据库或表里面。<code>Mycat</code>中是不允许修改作为分表依据的列的，所以更新是需要去掉此列。</p><p>2、非关键字查询</p><p>3、由于读写分离后，从数据库的数据可能与主数据库的数据不一致，因此需要特别关注数据一致性问题。</p><p>![image-20230603163618803](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230603163618803.png)（可以用注解的方式强制走主库）</p><h5 id="与sharding-jdbc的区别"><a href="#与sharding-jdbc的区别" class="headerlink" title="与sharding jdbc的区别"></a>与sharding jdbc的区别</h5><p><strong>相同点：</strong></p><p>a、设计理念相同，主流程都是SQL解析–&gt;SQL路由–&gt;SQL改写–&gt;SQL执行–&gt;结果归并</p><p>b、查询的原理一致，非分片字段查询都会查询所有分片然后结果归并，分片字段查询则直接搜索分片数据库查询。</p><p><strong>不同点：</strong></p><p>他们类似于SpringCloud Ribbon与Nginx区别。</p><p>Mycat是基于Proxy，类似于nginx，它复写了MySQL协议，将MycatServer伪装成一个MySQL数据库。优点是保证数据库的安全性，归并数据结果完全解耦，缺点是效率偏低。</p><p>Sharding-JDBC是基于JDBC的扩展，是以jar包的形式提供轻量级服务的。优点是效率较高，缺点是归并数据结果没有实现解耦，有可能会影响到我们业务逻辑代码。还容易内存溢出，所以要做分页处理。</p><p>MyCat是一个第三方服务器端数据库中间件，客户端所有的jdbc请求都必须要先交给MyCat，再有MyCat转发到具体的真实服务器中。<br>Sharding-Jdbc是一个本地数据库中间件框架，采用Jar形式，在本地应用层重写Jdbc原生的方法，实现数据库分片形式。</p><h5 id="sharding-jdbc工作原理"><a href="#sharding-jdbc工作原理" class="headerlink" title="sharding jdbc工作原理"></a>sharding jdbc工作原理</h5><p>以下是 Sharding JDBC 的一般工作原理：</p><ol><li>数据源路由：Sharding JDBC 通过数据源路由功能，将 SQL 语句路由到相应的数据源（数据库实例）。路由的规则通常基于某种分片策略，比如按照分片键的哈希值或范围进行路由。这样可以将数据分散存储在不同的数据库实例中。</li><li>SQL 解析和执行：Sharding JDBC 在收到 SQL 语句后，会解析其中涉及的表名、字段等信息，然后根据配置的分片规则决定具体的路由目标。接着，它会将 SQL 语句发送到对应的数据源执行，并将结果合并返回给应用程序。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表环的入口数学原理</title>
    <link href="/2021/06/08/%E9%93%BE%E8%A1%A8%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3/"/>
    <url>/2021/06/08/%E9%93%BE%E8%A1%A8%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>看一张简图。（图侵删）</p><p><img src="https://pic2.zhimg.com/80/v2-00f7b9c343d11b19bfad3fac2d2b1669_1440w.webp" alt="img"></p><p>假设：</p><ul><li>从<strong>头节点到入口的</strong>距离为 ab。</li><li>从<strong>入口到相遇点</strong>的距离为 bc。</li><li>从<strong>相遇点到入口</strong>的距离为 cb。</li></ul><p>则<strong>链表环的长度</strong> &#x3D; bc + cb。</p><p>那么快慢指针相遇时所走过的步数为：</p><p>fast_step &#x3D; ab + bc + n * (bc + cb) 【公式 1】</p><p>slow_step &#x3D; ab + bc 【公式 2】</p><p>n 指的是 fast 指针走过的圈数，<strong>n 的取值肯定是 n ≥ 1</strong>，因为快指针 fast 最少要多跑一圈才能追上慢指针 slow。</p><p>又由于快指针每次走 2 步，慢指针每次走 1 步，所以又有：</p><p>fast_step &#x3D; 2 * slow_step 【公式 3】</p><p>综合公式 1、公式 2、公式 3，得出：</p><p>ab + bc + n * (bc + cb) &#x3D; 2 * (ab + bc) 【公式 4】</p><p>整理得：</p><p>ab &#x3D; (n - 1) * (bc + cb) + cb 【公式 5】</p><p>其中 (n - 1) * (bc + cb) 正好是 (n - 1) 个环形的长度。</p><p>为了更好的理解公式 5，我们假设 n &#x3D; 1，也就是快指针 fast 指针走一圈就可以碰到慢指针 slow。</p><p>那么公式 5 变成：</p><p>ab &#x3D; cb</p><p>ab 是从节点到入口的距离，cb 是从相遇节点到入口的距离，这说明什么呢？</p><p><strong>说明同时从头节点和相遇节点出发的两个指针，每次走 1 步，最终会在入口处相遇。</strong></p><p>所以如果判断链表是环形链表，“找入口”就成了，在找到快慢指针相遇节点时，设置两个新节点 flag1 和 flag2。</p><p>其中 flag1 指向头节点，flag2 指向快慢指针相遇节点，然后每次移动 1 步，直至 flag1 和 flag2 相遇。</p><p><strong>Code</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> ListNode EntryNodeOfLoop(ListNode pHead)<br>&#123;<br>    <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">null</span> || pHead.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    ListNode fast = pHead;<br>    ListNode slow = pHead;<br><br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>)&#123;<br>        fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>        slow = slow.<span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>            ListNode slow2 = pHead;<br>            <span class="hljs-keyword">while</span>(slow2 != slow)&#123;<br>                slow2 = slow2.<span class="hljs-keyword">next</span>;<br>                slow = slow.<span class="hljs-keyword">next</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> slow2;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有序性、可见行、原子性问题</title>
    <link href="/2021/02/13/%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E8%A1%8C%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2021/02/13/%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E8%A1%8C%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。</p><p>![image-20211030165027454](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211030165027454.png)</p><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p><p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的“坑”。</p><p>![image-20211030165106100](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211030165106100.png)</p><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a&#x3D;6；b&#x3D;7；”编译器优化后可能变成“b&#x3D;7；a&#x3D;6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。</p><p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance() 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。</p><p>![image-20211030165449044](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211030165449044.png)</p><p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance &#x3D;&#x3D; null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance &#x3D;&#x3D; null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p><p>\1. 分配一块内存 M； </p><p>\2. 在内存 M 上初始化 Singleton 对象；</p><p>\3. 然后 M 的地址赋值给 instance 变量。</p><p>但是实际上优化后的执行路径却是这样的：</p><p>\1. 分配一块内存 M； </p><p>\2. 将 M 的地址赋值给 instance 变量；</p><p>\3. 最后在内存 M 上初始化 Singleton 对象。</p><p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 会发现instance !&#x3D; null，所以直接返回 instance，而此时的instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。</p><p>![image-20211030165615505](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211030165615505.png)</p><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性问题的源头就是 <strong>线程切换</strong>，但在多核 CPU 的大背景下，不允许线程切换是不可能的。</p><p>Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count +&#x3D; 1，至少需要三条 CPU 指令。</p><p>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</p><p>指令 2：之后，在寄存器中执行 +1 操作；</p><p>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</p><p>操作系统做任务切换，可以发生在任何一条<strong>CPU 指令</strong>执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count&#x3D;0，如果线程 A在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+&#x3D;1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p><p>我们潜意识里面觉得 count+&#x3D;1 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+&#x3D;1 之前，也可以发生在 count+&#x3D;1 之后，但就是不会发生在中间。<strong>我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性</strong>。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。</p><p><strong>“原子性”的本质</strong>是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，<strong>操作的中间状态对外不可见</strong>。例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A减少了 100，账户 B 还没来得及发生变化）。所以<strong>解决原子性问题，是要保证中间状态对外不可见</strong>。</p><blockquote><p>互斥: 同一时刻只有一个线程执行</p></blockquote><p>实际上，上面这句话的意思是: 对共享变量的修改是互斥的，也就是说线程 A 修改共享变量时其他线程不能修改(即使a线程时间片到期，其它线程获取到时间片执行时也拿不到🔒)，这就不存在操作被打断的问题了，那么如何实现互斥呢？</p><p>管程，对应的英文是 Monitor，很多 Java 领域的同学都喜欢将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”，这个是意译，而我自己也更倾向于使用“管程”。所谓<strong>管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发</strong>。翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。</p><h5 id="管程实现互斥"><a href="#管程实现互斥" class="headerlink" title="管程实现互斥"></a>管程实现互斥</h5><p>管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。在下图中，管程 X 将共享变量 queue 这个队列和相关的操作入队 enq()、出队 deq() 都封装起来了；线程 A 和线程 B 如果想访问共享变量 queue，只能通过调用管程提供的 enq()、deq() 方法来实现；enq()、deq() 保证互斥性，只允许一个线程进入管程。不知你有没有发现，管程模型和面向对象高度契合的。估计这也是 Java 选择管程的原因吧。而我在前面章节介绍的互斥锁用法，其背后的模型其实就是它。</p><p>![image-20211030150423494](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211030150423494.png)</p><h5 id="synchronized实现管程（解决原子性问题）"><a href="#synchronized实现管程（解决原子性问题）" class="headerlink" title="synchronized实现管程（解决原子性问题）"></a>synchronized实现管程（解决原子性问题）</h5><p>Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。MESA模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。具体如下图所示。</p><p>![image-20211030150459852](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211030150459852.png)</p><p>Java 内置的管程方案（synchronized）使用简单，synchronized 关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是仅支持一个条件变量；而 Java SDK 并发包实现的管程支持多个条件变量，不过并发包里的锁，需要开发人员自己进行加锁和解锁操作。</p><p>![image-20211125112016452](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211125112016452.png)</p><h5 id="Lock和condition实现管程"><a href="#Lock和condition实现管程" class="headerlink" title="Lock和condition实现管程"></a>Lock和condition实现管程</h5><p><strong>Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题</strong>。</p><p>Java 语言本身提供的 synchronized 也是管程的一种实现，既然 Java 从语言层面已经实现了管程了，那为什么还要在 SDK 里提供另外一种实现呢？很显然它们之间是有巨大区别的。那区别在哪里呢？</p><p><strong>再造管程的理由</strong></p><p>在 Java 的 1.5 版本中，synchronized 性能不如SDK 里面的 Lock，但 1.6 版本之后，synchronized 做了很多优化，将性能追了上来，所以 1.6之后的版本又有人推荐使用 synchronized 了。那性能是否可以成为“重复造轮子”的理由呢？</p><p>显然不能。因为性能问题优化一下就可以了，完全没必要“重复造轮子”。<strong>破坏不可抢占条件</strong>方案，这个方案synchronized 没有办法解决。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。但我们希望的是：</p><p>\1. <strong>能够响应中断</strong>。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。</p><p>\2. <strong>支持超时</strong>。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</p><p>\3. <strong>非阻塞地获取锁</strong>。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</p><p>这三种方案可以全面弥补 synchronized 的问题。这三个方案就是“重复造轮子”的主要原因，体现在 API 上，就是 Lock 接口的三个方法。详情如下：</p><p>![image-20211030152635936](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211030152635936.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql DDL</title>
    <link href="/2020/11/21/mysql%20DDL/"/>
    <url>/2020/11/21/mysql%20DDL/</url>
    
    <content type="html"><![CDATA[<h5 id="MySQL-DDL-的原理简析"><a href="#MySQL-DDL-的原理简析" class="headerlink" title="MySQL DDL 的原理简析"></a>MySQL DDL 的原理简析</h5><h5 id="1、copy-算法"><a href="#1、copy-算法" class="headerlink" title="1、copy 算法"></a>1、copy 算法</h5><p>较简单的实现方法，MySQL 会建立一个新的临时表，把源表的所有数据写入到临时表，在此期间无法对源表进行数据写入。MySQL在完成临时表的写入之后，用临时表替换掉源表。这个算法主要被早期(&lt;&#x3D;5.5)版本所使用。</p><h5 id="2、inplace-算法"><a href="#2、inplace-算法" class="headerlink" title="2、inplace 算法"></a>2、inplace 算法</h5><p>从 5.6 开始，常用的 DDL 都默认使用这个算法。inplace 算法包含两类：inplace-no-rebuild 和 inplace-rebuild，两者的主要差异在于是否需要重建源表。</p><p>inplace 算法的操作阶段主要分为三个：Prepare阶段： - 创建新的临时 frm 文件(与 InnoDB 无关)。 - 持有 EXCLUSIVE-MDL 锁，禁止读写。 - 根据 alter 类型，确定执行方式(copy，online-rebuild，online-not-rebuild)。 更新数据字典的内存对象。 - 分配 row_log 对象记录数据变更的增量(仅 rebuild 类型需要)。 - 生成新的临时ibd文件 new_table(仅rebuild类型需要)。</p><p>Execute 阶段：降级EXCLUSIVE-MDL锁，允许读写。扫描old_table聚集索引(主键)中的每一条记录 rec。遍历new_table的聚集索引和二级索引，逐一处理。根据 rec 构造对应的索引项。将构造索引项插入 sort_buffer 块排序。将 sort_buffer 块更新到 new_table 的索引上。记录 online-ddl 执行过程中产生的增量(仅 rebuild 类型需要)。重放 row_log 中的操作到 new_table 的索引上(not-rebuild 数据是在原表上更新)。重放 row_log 中的DML操作到 new_table 的数据行上。</p><p>Commit阶段：当前 Block 为 row_log 最后一个时，禁止读写，升级到 EXCLUSIVE-MDL 锁。重做 row_log 中最后一部分增量。更新 innodb 的数据字典表。提交事务(刷事务的 redo 日志)。修改统计信息。rename 临时 ibd 文件，frm文件。变更完成，释放 EXCLUSIVE-MDL 锁。</p><h5 id="3、instant-算法"><a href="#3、instant-算法" class="headerlink" title="3、instant 算法"></a>3、instant 算法</h5><p>MySQL 8.0.12 才提出的新算法，目前只支持添加列等少量操作，利用 8.0 新的表结构设计，可以直接修改表的 metadata 数据，省掉了 rebuild 的过程，极大的缩短了 DDL 语句的执行时间。</p><h5 id="4、pt-online-schema-change"><a href="#4、pt-online-schema-change" class="headerlink" title="4、pt-online-schema-change"></a>4、pt-online-schema-change</h5><p>借鉴了 copy 算法的思路，由外部工具来完成临时表的建立，数据同步，用临时表替换源表这三个步骤。其中数据同步是利用 MySQL 的触发器来实现的，会少量影响到线上业务的 QPS 及 SQL 响应时间。</p><h5 id="三、mysql-8-0特性instant-add-column"><a href="#三、mysql-8-0特性instant-add-column" class="headerlink" title="三、mysql 8.0特性instant add column"></a>三、mysql 8.0特性instant add column</h5><h5 id="1、instant-add-column原理"><a href="#1、instant-add-column原理" class="headerlink" title="1、instant add column原理"></a>1、instant add column原理</h5><p>mysql数据库针对亿级别的大表加字段是痛苦的，需要对表进行重建，MySQL 5.7 支持 Online DDL，大部分 DDL 不影响对表的读取和写入，但是依然会消耗非常多的时间，且占用额外的磁盘空间，并会造成主从延迟。所以大表 DDL 仍是一件令 DBA 头痛的事。而mysql8.0使用instant ADD COLUMN特性，只需很短的时间，字段就加好了，享受MongoDB那样的非结构化存储的灵活方便,无形中减少了开发的工作量。</p><p>快速加列采用的是 instant 算法，使得添加列时不再需要 rebuild 整个表，只需要在表的 metadata 中记录新增列的基本信息即可。在 alter 语句后增加 ALGORITHM&#x3D;INSTANT 即代表使用 instant 算法， 如果未明确指定，则支持 instant 算法的操作会默认使用。如果 ALGORITHM&#x3D;INSTANT 指定但不支持，则操作立即失败并显示错误。</p><p>下表概述了对列操作的在线 DDL 支持。星号表示附加信息、异常或依赖项。</p><table><thead><tr><th>Operation</th><th>Instant</th><th>In Place</th><th>Rebuilds Table</th><th>Permits Concurrent DML</th><th>Only Modifies Metadata</th></tr></thead><tbody><tr><td>Adding a column</td><td>Yes*</td><td>Yes</td><td>No*</td><td>Yes*</td><td>Yes</td></tr><tr><td>Dropping a column</td><td>Yes*</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Renaming a column</td><td>Yes*</td><td>Yes</td><td>No</td><td>Yes*</td><td>Yes</td></tr><tr><td>Reordering columns</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>Setting a column default value</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>Changing the column data type</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>Extending <code>VARCHAR</code> column size</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>Dropping the column default value</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>Changing the auto-increment value</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td><td>No*</td></tr><tr><td>Making a column <code>NULL</code></td><td>No</td><td>Yes</td><td>Yes*</td><td>Yes</td><td>No</td></tr><tr><td>Making a column <code>NOT NULL</code></td><td>No</td><td>Yes*</td><td>Yes*</td><td>Yes</td><td>No</td></tr><tr><td>Modifying the definition of an <code>ENUM</code> or <code>SET</code> column</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td></tr></tbody></table><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">一般情况下的建议：如果使用的是 MySQL <span class="hljs-number">5</span>.<span class="hljs-number">5</span> 或者 MySQL <span class="hljs-number">5</span>.<span class="hljs-number">6</span>，推荐使用 gh-ost<br>如果使用的是 MySQL <span class="hljs-number">5</span>.<span class="hljs-number">7</span>，索引等不涉及修改数据的操作，建议使用默认的 inplace 算法。如果涉及到修改数据(例如增加列)，不关心主<br>从同步延时的情况下使用默认的 inplace 算法，关心主从同步延时的情况下使用 gh-ost<br>如果使用的是 MySQL <span class="hljs-number">8</span>.<span class="hljs-number">0</span>，推荐使用 MySQL 默认的算法设置，在语句不支持 instant 算法并且在意主从同步延时的情况下使用gh-ost<span class="hljs-number">1.2.3.4</span>.<br></code></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>更多信息可以查看mysql官方文档</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html"> https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql自增主键存储以及不连续的原因</title>
    <link href="/2020/04/22/mysql%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E5%AD%98%E5%82%A8%E4%BB%A5%E5%8F%8A%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <url>/2020/04/22/mysql%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E5%AD%98%E5%82%A8%E4%BB%A5%E5%8F%8A%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<p>自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率</p><p>但实际上，MySQL 的自增主键并不能保证一定是连续递增的。</p><p>下面举个例子来看下，如下所示创建一张表：</p><p><img src="https://s5.51cto.com/oss/202212/06/8423be962d3ee0f6791415862a724f10d27587.png" alt="图片"></p><p>自增值保存在哪里？</p><p>使用 insert into test_pk values(null, 1, 1) 插入一行数据，再执行 show create table 命令来看一下表的结构定义：</p><p><img src="https://s5.51cto.com/oss/202212/06/c1d71aa19e9aaafd1233071dc3568a11518ffd.png" alt="图片"></p><p>上述表的结构定义存放在后缀名为 .frm 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 .frm 文件：</p><p><img src="https://s2.51cto.com/oss/202212/06/1553db7862697256c33892247e1499a65f304c.png" alt="图片"></p><p>从上述表结构可以看到，表定义里面出现了一个 AUTO_INCREMENT&#x3D;2，表示下一次插入数据时，如果需要自动生成自增值，会生成 id &#x3D; 2。</p><p>但需要注意的是，自增值并不会保存在这个表结构也就是 .frm 文件中，不同的引擎对于自增值的保存策略不同：</p><p>1）MyISAM 引擎的自增值保存在数据文件中</p><p>2）InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。</p><p>举个例子：我们现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT&#x3D;2，对吧。这时候，我们删除 id&#x3D;1 的行，AUTO_INCREMENT 还是 2。</p><p><img src="https://s2.51cto.com/oss/202212/06/15b37c416711345adc68633ab75e398ec94093.png" alt="图片"></p><p>但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。</p><p><img src="https://s8.51cto.com/oss/202212/06/03a648b7050e3a8c3cb68258a79b4e214b872f.png" alt="图片"></p><p><img src="https://s6.51cto.com/oss/202212/06/76448ee29fb4d4adac039306b7f1f835f2d5c8.png" alt="图片"></p><p>以上，是在我本地 MySQL 5.x 版本的实验，实际上，到了 MySQL 8.0 版本后，自增值的变更记录被放在了 redo log 中，提供了自增值持久化的能力，也就是实现了“如果发生重启，表的自增值可以根据 redo  log 恢复为 MySQL 重启前的值”</p><p>也就是说对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。</p><p>理解了 MySQL 自增值到底保存在哪里以后，我们再来看看自增值的修改机制，并以此引出第一种自增值不连续的场景。</p><h4 id="自增值不连续场景-1"><a href="#自增值不连续场景-1" class="headerlink" title="自增值不连续场景 1"></a>自增值不连续场景 1</h4><p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ul><li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li><li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li></ul><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 insert_num，当前的自增值是 autoIncrement_num：</p><p>如果 insert_num &lt; autoIncrement_num，那么这个表的自增值不变</p><p>如果 insert_num &gt;&#x3D; autoIncrement_num，就需要把当前自增值修改为新的自增值</p><p>也就是说，如果插入的 id 是 100，当前的自增值是 90，insert_num &gt;&#x3D; autoIncrement_num，那么自增值就会被修改为新的自增值即 101</p><p>一定是这样吗？</p><p>非也~</p><p>了解过分布式 id 的小伙伴一定知道，为了避免两个库生成的主键发生冲突，我们可以让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数</p><p>这个奇数偶数其实是通过 auto_increment_offset 和 auto_increment_increment 这两个参数来决定的，这俩分别用来表示自增的初始值和步长，默认值都是 1。</p><p>所以，上面的例子中生成新的自增值的步骤实际是这样的：从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 100  的值，作为新的自增值。</p><p>所以，这种情况下，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。</p><p>更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的</p><h4 id="自增值不连续场景-2"><a href="#自增值不连续场景-2" class="headerlink" title="自增值不连续场景 2"></a>自增值不连续场景 2</h4><p>举个例子，我们现在往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT&#x3D; 2，对吧</p><p><img src="https://s6.51cto.com/oss/202212/06/e6c18f6568aef6091280909bfebfb4a60d5b2d.png" alt="图片"></p><p>这时我再执行一条插入 (null,1,1) 的命令，很显然会报错 Duplicate entry，因为我们设置了一个唯一索引字段 a：</p><p><img src="https://s5.51cto.com/oss/202212/06/77b9dc713db0bd0d103505b240a00c00f51135.png" alt="图片"></p><p>但是，你会惊奇的发现，虽然插入失败了，但自增值仍然从 2 增加到了 3！</p><p>这是为啥？</p><p>我们来分析下这个 insert 语句的执行流程：</p><ul><li>执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1);</li><li>InnoDB 发现用户没有指定自增 id 的值，则获取表test_pk 当前的自增值 2；</li><li>将传入的记录改成 (2,1,1);</li><li>将表的自增值改成 3；</li><li>继续执行插入数据操作，由于已经存在 a&#x3D;1 的记录，所以报 Duplicate key error，语句返回</li></ul><p>可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。</p><p>这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id &#x3D; 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。</p><p>至此，我们已经罗列了两种自增主键不连续的情况：</p><ul><li>自增初始值和自增步长设置不为 1</li><li>唯一键冲突</li></ul><p>除此之外，事务回滚也会导致这种情况</p><h4 id="自增值不连续场景-3"><a href="#自增值不连续场景-3" class="headerlink" title="自增值不连续场景 3"></a>自增值不连续场景 3</h4><p>我们现在表里有一行 (1,1,1) 的记录，AUTO_INCREMENT &#x3D; 3：</p><p><img src="https://s8.51cto.com/oss/202212/06/d6c6199092cdae2ac3d461b8f7bb15b7de302c.png" alt="图片"></p><p>我们先插入一行数据 (null, 2, 2)，也就是 (3, 2, 2) 嘛，并且 AUTO_INCREMENT 变为 4：</p><p><img src="https://s2.51cto.com/oss/202212/06/54ea36170d283a8408a841429fe4571b3c58d0.png" alt="图片"></p><p>再去执行这样一段 SQL：</p><p><img src="https://s8.51cto.com/oss/202212/06/83fb55a80afc00888c16007b9670ec0b78f76a.png" alt="图片"></p><p>虽然我们插入了一条 (null, 3, 3) 记录，但是使用 rollback 进行回滚了，所以数据库中是没有这条记录的：</p><p><img src="https://s3.51cto.com/oss/202212/06/350e71c19095b2ced1c1778b742db066795a41.png" alt="图片"></p><p>在这种事务回滚的情况下，自增值并没有同样发生回滚！如下图所示，自增值仍然固执地从 4 增加到了 5：</p><p><img src="https://s8.51cto.com/oss/202212/06/b8a5ee4497ba8bb186b057c2bbb52bd7d8dd58.png" alt="图片"></p><p>所以这时候我们再去插入一条数据（null, 3, 3）的时候，主键 id 就会被自动赋为 5 了：</p><p><img src="https://s9.51cto.com/oss/202212/06/09e04d819d03f22c8228347276c569f5c5aee0.png" alt="图片"></p><p>那么，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去呢？回退回去的话不就不会发生自增 id 不连续了吗？</p><p>事实上，这么做的主要原因是为了提高性能。</p><p>我们直接用反证法来验证：假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？</p><p>现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请，对吧。</p><ul><li>假设事务 A 申请到了 id &#x3D; 1， 事务 B 申请到 id&#x3D;2，那么这时候表 t 的自增值是3，之后继续执行。</li><li>事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id &#x3D; 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id &#x3D; 2 的行，而当前的自增 id 值是 1。</li><li>接下来，继续执行的其他事务就会申请到 id&#x3D;2。这时，就会出现插入语句报错“主键冲突”。</li></ul><p><img src="https://s8.51cto.com/oss/202212/06/44f390b018649068b201008b6e54873be48ce7.png" alt="图片"></p><p>而为了解决这个主键冲突，有两种方法：</p><ul><li>每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id</li><li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id</li></ul><p>很显然，上述两个方法的成本都比较高，会导致性能问题。而究其原因呢，是我们假设的这个 “允许自增 id 回退”。</p><p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。</p><p>综上，已经分析了三种自增值不连续的场景，还有第四种场景：批量插入数据。</p><h4 id="自增值不连续场景-4"><a href="#自增值不连续场景-4" class="headerlink" title="自增值不连续场景 4"></a>自增值不连续场景 4</h4><p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p><ul><li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li><li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li><li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li><li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li></ul><p>注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！，因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p><p>而对于 insert … select、replace … select 和 load data 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种批量申请的策略，毕竟一个一个申请的话实在太慢了。</p><p>举个例子，假设我们现在这个表有下面这些数据：</p><p><img src="https://s5.51cto.com/oss/202212/06/52f93ec10530b3b822b9869ca9ab5d26bb5e6d.png" alt="图片"></p><p>我们创建一个和当前表 test_pk 有相同结构定义的表 test_pk2：</p><p><img src="https://s2.51cto.com/oss/202212/06/c3df70f61a5aaf02bfc4197e825d7cd6d6343a.png" alt="图片"></p><p>然后使用 insert…select 往 teset_pk2 表中批量插入数据：</p><p><img src="https://s3.51cto.com/oss/202212/06/11f14235046bc5a91d4177b0abc5db051802da.png" alt="图片"></p><p>可以看到，成功导入了数据。</p><p>再来看下 test_pk2 的自增值是多少：</p><p><img src="https://s4.51cto.com/oss/202212/06/8420f0a70791c7b507917953428195055c0286.png" alt="图片"></p><p>如上分析，是 8 而不是 6</p><p>具体来说，insert…select 实际上往表中插入了 5 行数据 （1 1）（2 2）（3 3）（4 4）（5 5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：</p><ul><li>第一次申请到了一个 id：id&#x3D;1</li><li>第二次被分配了两个 id：id&#x3D;2 和 id&#x3D;3</li><li>第三次被分配到了 4 个 id：id&#x3D;4、id &#x3D; 5、id &#x3D; 6、id&#x3D;7</li></ul><p>由于这条语句实际只用上了 5 个 id，所以 id&#x3D;6 和 id&#x3D;7 就被浪费掉了。之后，再执行 insert into test_pk2 values(null,6,6)，实际上插入的数据就是（8,6,6)：</p><p><img src="https://s7.51cto.com/oss/202212/06/135d92203485a60dba8443821c469751510bc3.png" alt="图片"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结下自增值不连续的四个场景：</p><ul><li>自增初始值和自增步长设置不为 1</li><li>唯一键冲突</li><li>事务回滚</li><li>批量插入（如insert…select 语句）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS原理详解</title>
    <link href="/2019/08/09/AQS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <url>/2019/08/09/AQS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h5 id="AQS-内部原理解析"><a href="#AQS-内部原理解析" class="headerlink" title="AQS 内部原理解析"></a>AQS 内部原理解析</h5><p>AQS 最核心的三大部分就是<strong>状态</strong>、<strong>队列</strong>和<strong>期望协作工具类去实现的获取&#x2F;释放等重要方法</strong>。</p><h5 id="state-状态"><a href="#state-状态" class="headerlink" title="state 状态"></a>state 状态</h5><p>第一个要讲解的是状态 state，如果 AQS 想要去管理或者想作为协作工具类的一个基础框架，那么它必然要管理一些状态，而这个状态在 AQS 内部就是用 state 变量去表示的。它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * The synchronization state.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure><p>而 state 的含义并不是一成不变的，它会<strong>根据具体实现类的作用不同而表示不同的含义</strong>，下面举几个例子。</p><p>比如说在信号量里面，state 表示的是剩余<strong>许可证的数量</strong>。如果最开始把 state 设置为 10，这就代表许可证初始一共有 10 个，然后当某一个线程取走一个许可证之后，这个 state 就会变为 9，所以信号量的 state 相当于是一个内部计数器。</p><p>再比如，在 CountDownLatch 工具类里面，state 表示的是<strong>需要“倒数”的数量</strong>。一开始假设把它设置为 5，当每次调用 CountDown 方法时，state 就会减 1，一直减到 0 的时候就代表这个门闩被放开。</p><p>下面再来看一下 state 在 ReentrantLock 中是什么含义，在 ReentrantLock 中它表示的是<strong>锁的占有情况</strong>。最开始是 0，表示没有任何线程占有锁；如果 state 变成 1，则就代表这个锁已经被某一个线程所持有了。</p><p>那为什么还会变成 2、3、4 呢？为什么会往上加呢？因为 ReentrantLock 是可重入的，同一个线程可以再次拥有这把锁就叫<strong>重入</strong>。如果这个锁被同一个线程多次获取，那么 state 就会逐渐的往上加，state 的值表示重入的次数。在释放的时候也是逐步递减，比如一开始是 4，释放一次就变成了 3，再释放一次变成了 2，这样进行的减操作，即便是减到 2 或者 1 了，都不代表这个锁是没有任何线程持有，只有当它减到 0 的时候，此时恢复到最开始的状态了，则代表现在没有任何线程持有这个锁了。所以，state 等于 0 表示锁不被任何线程所占有，代表这个锁当前是处于释放状态的，其他线程此时就可以来尝试获取了。</p><p>这就是 state 在不同类中不同含义的一个具体表现。举三个例子，如果未来有新的工具要利用到 AQS，它一定也需要利用 state，为这个类表示它所需要的业务逻辑和状态。</p><p>下面再来看一下关于 state 修改的问题，因为 state 是会被多个线程共享的，会被并发地修改，所以所有去修改 state 的方法都必须要保证 state 是线程安全的。可是 state 本身它仅仅是被 volatile 修饰的，volatile 本身并不足以保证线程安全，所以就来看一下，AQS 在修改 state 的时候具体利用了什么样的设计来保证并发安全。</p><p>举两个和 state 相关的方法，分别是 compareAndSetState 及 setState，它们的实现已经由 AQS 去完成了，也就是说，直接调用这两个方法就可以对 state 进行线程安全的修改。下面就来看一下这两个方法的源码是怎么实现的。</p><ul><li>先来看一下 compareAndSetState 方法，这是一个非常熟悉的 CAS 操作，这个方法的代码，如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br><br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>方法里面只有一行代码，即 return unsafe.compareAndSwapInt(this, stateOffset, expect, update)，这个方法已经非常熟悉了，它利用了 Unsafe 里面的 CAS 操作，利用 CPU 指令的原子性保证了这个操作的原子性，与之前介绍过的原子类去保证线程安全的原理是一致的。</p><ul><li>接下来看一下 setState 方法的源码，如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br><br>    state = newState;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它去修改 state 值的时候非常直截了当，直接把 state &#x3D; newState，这样就直接赋值了。你可能会感到困惑，这里并没有进行任何的并发安全处理，没有加锁也没有 CAS，那如何能保证线程安全呢？</p><p>这里就要说到 volatile 的作用了，前面在学习 volatile 关键字的时候，知道了它适用于两种场景，其中一种场景就是，当<strong>对基本类型的变量进行直接赋值时</strong>，如果加了 volatile 就可以保证它的线程安全。注意，这是 volatile 的非常典型的使用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * The synchronization state.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure><p>可以看出，state 是 int 类型的，属于基本类型，并且这里的 setState 方法内是对 state 直接赋值的，它不涉及读取之前的值，也不涉及在原来值的基础上再修改，所以仅仅利用 volatile 就可以保证在这种情况下的并发安全，这就是 setState 方法线程安全的原因。</p><p>下面对 state 进行总结，在 AQS 中有 state 这样的一个属性，是被 volatile 修饰的，会被并发修改，它代表当前工具类的某种状态，在不同的类中代表不同的含义。</p><h5 id="FIFO-队列"><a href="#FIFO-队列" class="headerlink" title="FIFO 队列"></a>FIFO 队列</h5><p>下面再来看看 AQS 的第二个核心部分，<strong>FIFO 队列</strong>，即先进先出队列，这个队列最主要的作用是存储等待的线程。假设很多线程都想要同时抢锁，那么大部分的线程是抢不到的，那怎么去处理这些抢不到锁的线程呢？就得需要有一个队列来存放、管理它们。所以 AQS 的一大功能就是充当线程的“<strong>排队管理器</strong>”。</p><p>当多个线程去竞争同一把锁的时候，就需要用<strong>排队机制</strong>把那些没能拿到锁的线程串在一起；而当前面的线程释放锁之后，这个管理器就会挑选一个合适的线程来尝试抢刚刚释放的那把锁。所以 AQS 就一直在维护这个队列，并把等待的线程都放到队列里面。</p><p>这个队列内部是双向链表的形式，其数据结构看似简单，但是要想维护成一个线程安全的双向队列却非常复杂，因为要考虑很多的多线程并发问题。来看一下 AQS 作者 Doug Lea 给出的关于这个队列的一个图示：</p><p><img src="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/assets/Ciqc1F6pW3CAHYjKAACSEPDrUoc078.png" alt="插图1.png"></p><p>（此图引用自<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">英文文档中的图</a>）</p><p>在队列中，分别用 head 和 tail 来表示头节点和尾节点，两者在初始化的时候都指向了一个空节点。头节点可以理解为“当前持有锁的线程”，而在头节点之后的线程就被阻塞了，它们会等待被唤醒，唤醒也是由 AQS 负责操作的。</p><h5 id="获取-释放方法"><a href="#获取-释放方法" class="headerlink" title="获取&#x2F;释放方法"></a>获取&#x2F;释放方法</h5><p>下面就来看一看 AQS 的第三个核心部分，获取&#x2F;释放方法。在 AQS 中除了刚才讲过的 state 和队列之外，还有一部分非常重要，那就是<strong>获取和释放相关的重要方法</strong>，这些方法是协作工具类的<strong>逻辑</strong>的<strong>具体体现</strong>，需要每一个协作工具类<strong>自己去实现</strong>，所以在不同的工具类中，它们的实现和含义各不相同。</p><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>首先来看一下获取方法。获取操作通常会依赖 state 变量的值，根据 state 值不同，协作工具类也会有不同的逻辑，并且在获取的时候也经常会阻塞，下面就让来看几个具体的例子。</p><p>比如 ReentrantLock 中的 lock 方法就是其中一个“获取方法”，执行时，如果发现 state 不等于 0 且当前线程不是持有锁的线程，那么就代表这个锁已经被其他线程所持有了。这个时候，当然就获取不到锁，于是就让该线程进入阻塞状态。</p><p>再比如，Semaphore 中的 acquire 方法就是其中一个“获取方法”，作用是获取许可证，此时能不能获取到这个许可证也取决于 state 的值。如果 state 值是正数，那么代表还有剩余的许可证，数量足够的话，就可以成功获取；但如果 state 是 0，则代表已经没有更多的空余许可证了，此时这个线程就获取不到许可证，会进入阻塞状态，所以这里同样也是和 state 的值相关的。</p><p>再举个例子，CountDownLatch 获取方法就是 await 方法（包含重载方法），作用是“等待，直到倒数结束”。执行 await 的时候会判断 state 的值，如果 state 不等于 0，线程就陷入阻塞状态，直到其他线程执行倒数方法把 state 减为 0，此时就代表现在这个门闩放开了，所以之前阻塞的线程就会被唤醒。</p><p>总结一下，“获取方法”在不同的类中代表不同的含义，但往往<strong>和 state 值相关</strong>，也经常会让线程进入<strong>阻塞</strong>状态，这也同样证明了 state 状态在 AQS 类中的重要地位。</p><h5 id="释放方法"><a href="#释放方法" class="headerlink" title="释放方法"></a>释放方法</h5><p>释放方法是站在获取方法的对立面的，通常和刚才的获取方法配合使用。刚才讲的获取方法可能会让线程阻塞，比如说获取不到锁就会让线程进入阻塞状态，但是释放方法通常是<strong>不会阻塞线程</strong>的。</p><p>比如在 Semaphore 信号量里面，释放就是 release 方法（包含重载方法），release() 方法的作用是去释放一个许可证，会让 state 加 1；而在 CountDownLatch 里面，释放就是 countDown 方法，作用是倒数一个数，让 state 减 1。所以也可以看出，在不同的实现类里面，他们对于 state 的操作是截然不同的，需要由每一个协作类根据自己的逻辑去具体实现。</p><h5 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h5><p>下面再进行一些拓展阅读，本课时是把 AQS 的核心结构拎出来讲解的，对于了解 AQS 内部结构有很大好处，但是并不足以包含 AQS 的全貌。如果有兴趣进一步深入理解 AQS ，可以选择学习相关的拓展资源：</p><ul><li>第一个资源是 AQS 作者本人 Doug Lea 所写的一篇论文，这篇论文自然是非常宝贵的学习资料，<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">请点击这里查看</a>；</li><li>第二个是来自 Javadoop 博客对于 AQS 的源码分析的文章，感兴趣的话也可以阅读，<a href="https://javadoop.com/post/AbstractQueuedSynchronizer">请点击这里查看</a>。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本课时介绍了 AQS 最重要的三个部分。第一个是 state，它是一个数值，在不同的类中表示不同的含义，往往代表一种状态；第二个是一个队列，该队列用来存放线程；第三个是“获取&#x2F;释放”的相关方法，需要利用 AQS 的工具类根据自己的逻辑去实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池复用原理</title>
    <link href="/2019/06/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86/"/>
    <url>/2019/06/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h5 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h5><p>在ThreadPoolExecutor中共有七个参数：</p><ul><li><strong>corePoolSize</strong>：核心线程数，核心线程会一直存活，即使没有任务需要执行（除非allowCoreThreadTimeOut参数设置为true，这样的话即使是核心线程也会被超时销毁）；</li><li><strong>maximumPoolSize</strong>：线程池中允许的最大线程数；</li><li><strong>keepAliveTime</strong>：维护工作线程所允许的空闲时间，如果工作线程等待的时间超过了keepAliveTime，则会被销毁；</li><li><strong>unit</strong>：指定keepAliveTime的单位，如TimeUnit.SECONDS；</li><li><strong>workQueue</strong>：用来保存等待被执行任务的阻塞队列。常用的有：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue和PriorityBlockingQueue等；</li><li><strong>threadFactory</strong>：线程工厂，提供创建新线程的功能。默认的实现是Executors.defaultThreadFactory()，即通过new Thread的方式；</li><li><strong>handler</strong>：如果当前阻塞队列已满，并且当前的线程数量已超过了最大线程数，则会执行相应的拒绝策略。具体有四种（也可以自己实现）：</li><li><ul><li>AbortPolicy：默认实现，会直接抛出RejectedExecutionException；</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li><li>DiscardPolicy：直接抛弃，任务不执行；</li><li>DiscardOldestPolicy：丢弃阻塞队列中最靠前的任务，并执行当前任务。</li></ul></li></ul><p>我们知道线程池有核心线程和非核心线程之分，其中核心线程是一直存活在线程池中的，而非核心线程是在执行完任务之后超时销毁的。当Thread执行完Runnable任务之后就会销毁，而且就算执行完任务之后把线程挂起也没有办法再去执行其他任务，<strong>那线程池是如何做到核心线程复用的呢？</strong></p><p>![image-20220309161728804](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220309161728804.png)</p><p>总结上图的流程：有新的任务需要执行，并且当前线程池的线程数小于核心线程数，则创建一个核心线程来执行。如果当前线程数大于核心线程数，则会将除了核心线程处理的任务之外剩下的任务加入到阻塞队列中等待执行。如果队列已满，则在当前线程数不大于最大线程数的前提下，创建新的非核心线程，处理完毕后等到达keepAliveTime空闲时间后会被直接销毁。<strong>注意，不一定销毁的就是这些非核心线程，核心线程也可能被销毁，只要减到剩余线程数到达核心线程数就行。核心线程和非核心线程的区别仅在于判断是否到达阈值时有区别：核心线程判断的是核心线程数，而非核心线程判断的是最大线程数。仅此一个区别。</strong></p><p>下面看代码。首先来看一下执行线程任务的方法，里面很简单，就是根据工作线程数量去执行不同的策略，里面分成了3种情况，但是都会执行<code>addWoker()</code>方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span>(<span class="hljs-params">Runnable command</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-built_in">int</span> c = ctl.<span class="hljs-keyword">get</span>();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 如果当前活跃线程数小于核心线程数，就会添加一个worker来执行任务；</span><br><span class="hljs-comment">         * 具体来说，新建一个核心线程放入线程池中，并把任务添加到该线程中。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>            <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>                <span class="hljs-keyword">return</span>;<br>            c = ctl.<span class="hljs-keyword">get</span>();<br>        &#125;<br><br>      <span class="hljs-comment">//程序执行到这里，说明要么活跃线程数大于核心线程数；要么addWorker()失败</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 如果当前线程池是运行状态，会把任务添加到队列</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>            <span class="hljs-built_in">int</span> recheck = ctl.<span class="hljs-keyword">get</span>();<br>            <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; <span class="hljs-keyword">remove</span>(command))<br>                reject(command);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>                addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br><br>       <span class="hljs-comment">//程序执行到这里，说明要么线程状态不是RUNNING；要么workQueue队列已经满了</span><br><br>        <span class="hljs-comment">//调用addWorker方法去创建非核心线程，</span><br>        <span class="hljs-comment">//如果当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>            reject(command);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个方法就和名字一样，添加一个工人来完成任务；而这个工人就是Thread，任务就是Runnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>       ...省略一些不重要的<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//Worker是实现了Runnable接口的包装类</span><br>            w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>            <span class="hljs-comment">//Thread是在Worker构造方法创建的</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>                mainLock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// Recheck while holding lock.</span><br>                    <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                    <span class="hljs-comment">// shut down before lock acquired.</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br>                  <br>                    <span class="hljs-comment">//检查线程池状态，分为2种情况</span><br>                    <span class="hljs-comment">//1、线程池处于RUNNING</span><br>                   <span class="hljs-comment">//2、线程池处于SHUTDOWN并且firstTask==null</span><br>                   <span class="hljs-comment">//这2种情况都会创建Worker来执行队列中的任务</span><br>                    <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                        <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                        workers.add(w);<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                        <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                            largestPoolSize = s;<br>                        <span class="hljs-comment">//重新设置标识位</span><br>                        workerAdded = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    mainLock.unlock();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                    <span class="hljs-comment">//启动线程</span><br>                    t.start();<br>                    workerStarted = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (! workerStarted)<br>                addWorkerFailed(w);<br>        &#125;<br>        <span class="hljs-keyword">return</span> workerStarted;<br>    &#125;<br></code></pre></td></tr></table></figure><p>到这里，我们大概可以知道是通过创建Worker来执行任务的，而且线程是在Worker内部创建的，我们也能猜到Thread需要的Runnable应该也在Worker内部，所有我们继续看一下Worker类。</p><p><strong>Worker</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br>    &#123;<br>     <br>        <span class="hljs-keyword">final</span> Thread thread;<br>        <span class="hljs-comment">/** Initial task to run.  Possibly null. */</span><br>        Runnable firstTask;<br>        <span class="hljs-comment">/** Per-thread task counter */</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates with given first task and thread from ThreadFactory.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> firstTask the first task (null if none)</span><br><span class="hljs-comment">         */</span><br>        Worker(Runnable firstTask) &#123;<br>            setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>            <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>            <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/** Delegates main run loop to outer runWorker  */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            runWorker(<span class="hljs-built_in">this</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><p>Worker居然是一个Runnable任务，而且Worker的构造方法中创建了Thread对象。这样的话，在之前的<code>addWorker()</code>方法中调用<code>t.start();</code>就会执行到Worker的<code>run()</code>方法。</p><p><strong>继续来看看<code>runWorker()</code>方法，这里很关键，一定要仔细看。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">final <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span>(<span class="hljs-params">Worker w</span>)</span> &#123;<br>        Thread wt = Thread.currentThread();<br>        <span class="hljs-comment">//这个就是addWorker传进来的Runnable</span><br>        Runnable task = w.firstTask;<br>        w.firstTask = <span class="hljs-literal">null</span>;<br>        w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>        boolean completedAbruptly = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//如果task不为null或从workQueue中获取任务不为null</span><br>            <span class="hljs-comment">//就会一直执行</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>                w.<span class="hljs-keyword">lock</span>();<br>                <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>                <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>                <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>                <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br><br>                <span class="hljs-comment">//检查线程池状态，如果线程池处于中断状态，将调用interrupt将线程中断。 </span><br>                <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.<span class="hljs-keyword">get</span>(), STOP) ||<br>                     (Thread.interrupted() &amp;&amp;<br>                      runStateAtLeast(ctl.<span class="hljs-keyword">get</span>(), STOP))) &amp;&amp;<br>                    !wt.isInterrupted())<br>                    <span class="hljs-comment">//中断线程</span><br>                    wt.interrupt();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    beforeExecute(wt, task);<br>                    Throwable thrown = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//线程任务执行啦</span><br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        afterExecute(task, thrown);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                    w.completedTasks++;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            completedAbruptly = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            processWorkerExit(w, completedAbruptly);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里的关键在于这个<code>while()</code>条件判断，当第一次创建Worker时就有任务，当执行完这个任务后，这个方法并没有结束，而是不断地调用<code>getTask()</code>方法从阻塞队列中获取任务然后调用task.run()执行任务。</p><p><strong>getTask()获取任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>            <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>            <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>                decrementWorkerCount();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>            <span class="hljs-comment">// 1.allowCoreThreadTimeOut表示是否允许核心线程超时销毁，默认是false,也就是说核心线程即使空闲也不会被销毁</span><br>          <span class="hljs-comment">//当然，如果设置为true，核心线程是会销毁的</span><br>          <span class="hljs-comment">//这样的话，只有正在工作的线程数大于核心线程数才会为true，否则返回false</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>            <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>                &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>                <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//2.如果timed为true，通过poll取任务；如果为false，通过take取任务</span><br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                    workQueue.take();<br>                <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                timedOut = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>                timedOut = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个方法是通过一个死循环取任务，取任务的话是通过<code>workQueue</code>这个阻塞队列去完成的，在默认不改变<code>allowCoreThreadTimeOut</code>的前提下，如果工作线程数大于核心线程数，则通过<code>poll()</code>从队列取任务；如果工作线程数小于等于核心线程数，则通过<code>take()</code>从队列取任务；这2个方法等区别是<code>take()</code>取任务时，如果队列中没有任务了会调用<code>await()</code>阻塞当前线程。这样的话，是不是已经搞清楚线程池中的核心线程复用的原因了。</p><p>线程的唤醒是在<code>execute</code>时，当调用<code>workQueue.offer()</code>方法，将任务放入阻塞队列时，会调用<code>Condition.signal()</code>方法唤醒一个之前阻塞的线程。这部分不细讲，感兴趣的同学自行查看。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>1、当Thread的run方法执行完一个任务之后，会循环地从阻塞队列中取任务来执行，这样执行完一个任务之后就不会立即销毁了；</li><li>2、当工作线程数小于等于核心线程数，那些空闲的核心线程再去队列取任务的时候，如果队列中的Runnable数量为0，就会阻塞当前线程，这样线程就不会回收了</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring循环依赖</title>
    <link href="/2019/03/12/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <url>/2019/03/12/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Service</span><br>public class A &#123;<br>    <span class="hljs-variable">@Autowired</span><br>    private B b;<br>&#125;<br><br><span class="hljs-variable">@Service</span><br>public class B &#123;<br>    <span class="hljs-variable">@Autowired</span><br>    private A a;<br>&#125;<br><br><span class="hljs-comment">//或者自己依赖自己</span><br><span class="hljs-variable">@Service</span><br>public class A &#123;<br>    <span class="hljs-variable">@Autowired</span><br>    private A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这两种方式都是循环依赖，应该很好理解，当然也可以是三个 Bean 甚至更多的 Bean 相互依赖，原理都是一样的。</p><p>这种循环依赖可能会产生问题，例如 A 要依赖 B，发现 B 还没创建。</p><p>于是开始创建 B ，创建的过程发现 B 要依赖 A， 而 A 还没创建好呀，因为它要等 B 创建好。</p><h5 id="Spring-如何解决循环依赖"><a href="#Spring-如何解决循环依赖" class="headerlink" title="Spring 如何解决循环依赖"></a>Spring 如何解决循环依赖</h5><p>上面这种循环依赖在实际场景中是会出现的，所以 Spring 需要解决这个问题，那如何解决呢？</p><p>关键就是提前暴露未完全创建完毕的 Bean。</p><p>在 Spring 中，只有同时满足以下两点才能解决循环依赖的问题：</p><ol><li>依赖的 Bean 必须都是单例</li><li>依赖注入的方式，必须不全是构造器注入，且 beanName 字母序在前的不能是构造器注入</li></ol><h5 id="为什么必须都是单例"><a href="#为什么必须都是单例" class="headerlink" title="为什么必须都是单例"></a>为什么必须都是单例</h5><p>如果从源码来看的话，循环依赖的 Bean 是原型模式，会直接抛错：</p><p><img src="https://image.z.itpub.net/zitpub.net/JPG/2022-04-15/04A822D642097E97B4992D810B4C1B72.jpg" alt="img"></p><p>所以 Spring 只支持单例的循环依赖，但是为什么呢？</p><p>按照理解，如果两个 Bean 都是原型模式的话。</p><p>那么创建 A1 需要创建一个 B1。</p><p>创建 B1 的时候要创建一个 A2。</p><p>创建 A2 又要创建一个 B2。</p><p>创建 B2 又要创建一个 A3。</p><p>创建 A3 又要创建一个 B3…..</p><p>因为原型模式都需要创建新的对象，不能跟用以前的对象。</p><p>如果是单例的话，创建 A 需要创建 B，而创建的 B 需要的是之前的个 A， 不然就不叫单例了，对吧？</p><p>具体做法就是：先创建 A，此时的 A 是不完整的（没有注入 B），用个 map 保存这个不完整的 A，再创建 B ，B 需要 A。</p><p>所以从那个 map 得到“不完整”的 A，此时的 B 就完整了，然后 A 就可以注入 B，然后 A 就完整了，B 也完整了，且它们是相互依赖的。</p><h5 id="为什么不能全是构造器注入"><a href="#为什么不能全是构造器注入" class="headerlink" title="为什么不能全是构造器注入"></a>为什么不能全是构造器注入</h5><p>在 Spring 中创建 Bean 分三步:</p><ol><li>实例化，createBeanInstance，就是 new 了个对象</li><li>属性注入，populateBean， 就是 set 一些属性值</li><li>初始化，initializeBean，执行一些 aware 接口中的方法，initMethod，AOP代理等</li></ol><p>明确了上面这三点，再结合我上面说的“不完整的”，我们来理一下。</p><p>如果全是构造器注入，比如<code>A(B b)</code>，那表明在 new 的时候，就需要得到 B，此时需要 new B 。</p><p>但是 B 也是要在构造的时候注入 A ，即<code>B(A a)</code>，这时候 B 需要在一个 map 中找到不完整的 A ，发现找不到。</p><p>为什么找不到？因为 A 还没 new 完呢，所以找到不完整的 A，因此如果全是构造器注入的话，那么 Spring 无法处理循环依赖。</p><h5 id="一个set注入，一个构造器注入一定能成功？"><a href="#一个set注入，一个构造器注入一定能成功？" class="headerlink" title="一个set注入，一个构造器注入一定能成功？"></a>一个set注入，一个构造器注入一定能成功？</h5><p>假设我们 A 是通过 set 注入 B，B 通过构造函数注入 A，此时是成功的。</p><p>我们来分析下：实例化 A 之后，可以在 map 中存入 A，开始为 A 进行属性注入，发现需要 B。</p><p>此时 new B，发现构造器需要 A，此时从 map 中得到 A ，B 构造完毕。</p><p>B 进行属性注入，初始化，然后 A 注入 B 完成属性注入，然后初始化 A。</p><p>整个过程很顺利，没毛病。</p><p>假设 A 是通过构造器注入 B，B 通过 set 注入 A，此时是失败的。</p><p>我们来分析下：实例化 A，发现构造函数需要 B， 此时去实例化 B。</p><p>然后进行 B 的属性注入，从 map 里面找不到 A，因为 A 还没 new 成功，所以 B 也卡住了，然后就 gg。</p><p>看到这里，仔细思考的小伙伴可能会说，可以先实例化 B 啊，往 map 里面塞入不完整的 B，这样就能成功实例化 A 了啊。</p><p>确实，思路没错但是 Spring 容器是按照字母序创建 Bean 的，A 的创建永远排在 B 前面。</p><p>现在我们总结一下：</p><ul><li>如果循环依赖都是构造器注入，则失败</li><li>如果循环依赖不完全是构造器注入，则可能成功，可能失败，具体跟BeanName的字母序有关系。</li></ul><h5 id="Spring-解决循环依赖全流程"><a href="#Spring-解决循环依赖全流程" class="headerlink" title="Spring 解决循环依赖全流程"></a>Spring 解决循环依赖全流程</h5><p>明确了 Spring 创建 Bean 的三步骤之后，我们再来看看它为单例搞的三个 map：</p><ol><li>一级缓存，singletonObjects，存储所有已创建完毕的单例 Bean （完整的 Bean）</li><li>二级缓存，earlySingletonObjects，存储所有仅完成实例化，但还未进行属性注入和初始化的 Bean</li><li>三级缓存，singletonFactories，存储能建立这个 Bean 的一个工厂，通过工厂能获取这个 Bean，延迟化 Bean 的生成，工厂生成的 Bean 会塞入二级缓存</li></ol><p>这三个 map 是如何配合的呢？</p><ol><li>首先，获取单例 Bean 的时候会通过 BeanName 先去 singletonObjects（一级缓存） 查找完整的 Bean，如果找到则直接返回，否则进行步骤 2。</li><li>看对应的 Bean 是否在创建中，如果不在直接返回找不到，如果是，则会去 earlySingletonObjects （二级缓存）查找 Bean，如果找到则返回，否则进行步骤 3</li><li>去 singletonFactories （三级缓存）通过 BeanName 查找到对应的工厂，如果存着工厂则通过工厂创建 Bean ，并且放置到 earlySingletonObjects 中。</li><li>如果三个缓存都没找到，则返回 null。</li></ol><p>从上面的步骤我们可以得知，如果查询发现 Bean 还未创建，到第二步就直接返回 null，不会继续查二级和三级缓存。</p><p>返回 null 之后，说明这个 Bean 还未创建，这个时候会标记这个 Bean 正在创建中，然后再调用 createBean 来创建 Bean，而实际创建是调用方法 doCreateBean。</p><p>doCreateBean 这个方法就会执行上面我们说的三步骤：</p><ol><li>实例化</li><li>属性注入</li><li>初始化</li></ol><p>在实例化 Bean 之后，会往 singletonFactories 塞入一个工厂，而调用这个工厂的 getObject 方法，就能得到这个 Bean。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">addSingletonFactory<span class="hljs-function"><span class="hljs-params">(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</span>;</span><br></code></pre></td></tr></table></figure><p>要注意，此时 Spring 是不知道会不会有循环依赖发生的，但是它不管，反正往 singletonFactories 塞这个工厂，这里就是提前暴露。</p><p>然后就开始执行属性注入，这个时候 A 发现需要注入 B，所以去 getBean(B)，此时又会走一遍上面描述的逻辑，到了 B 的属性注入这一步。</p><p>此时 B 调用 getBean(A)，这时候一级缓存里面找不到，但是发现 A 正在创建中的，于是去二级缓存找，发现没找到，于是去三级缓存找，然后找到了。</p><p>并且通过上面提前在三级缓存里暴露的工厂得到 A，然后将这个工厂从三级缓存里删除，并将 A 加入到二级缓存中。</p><p>然后结果就是 B 属性注入成功。</p><p>紧接着 B 调用 initializeBean 初始化，终返回，此时 B 已经被加到了一级缓存里 。</p><p>这时候就回到了 A 的属性注入，此时注入了 B，接着执行初始化，后 A 也会被加到一级缓存里，且从二级缓存中删除 A。</p><p>Spring 解决依赖循环就是按照上面所述的逻辑来实现的。</p><p>重点就是在对象实例化之后，都会在三级缓存里加入一个工厂，提前对外暴露还未完整的 Bean，这样如果被循环依赖了，对方就可以利用这个工厂得到一个不完整的 Bean，破坏了循环的条件。</p><h5 id="为什么循环依赖需要三级缓存，二级不够吗？"><a href="#为什么循环依赖需要三级缓存，二级不够吗？" class="headerlink" title="为什么循环依赖需要三级缓存，二级不够吗？"></a><strong>为什么循环依赖需要三级缓存，二级不够吗？</strong></h5><p>上面都说了那么多了，那我们思考下，解决循环依赖需要三级缓存吗？</p><p>很明显，如果仅仅只是为了破解循环依赖，二级缓存够了，压根就不必要三级。</p><p>你思考一下，在实例化 Bean A 之后，我在二级 map 里面塞入这个 A，然后继续属性注入。</p><p>s发现 A 依赖 B 所以要创建 Bean B，这时候 B 就能从二级 map 得到 A ，完成 B 的建立之后， A 自然而然能完成。</p><p>所以为什么要搞个三级缓存，且里面存的是创建 Bean 的工厂呢？</p><p>我们来看下调用工厂的 getObject 到底会做什么，实际会调用下面这个方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">getEarlyBeanReference</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> beanName, RootBeanDefinition mbd, <span class="hljs-built_in">Object</span> bean</span>) &#123;<br>    <span class="hljs-title class_">Object</span> exposedObject = bean;<br>    <span class="hljs-keyword">if</span> (!mbd.<span class="hljs-title function_">isSynthetic</span>() &amp;&amp; <span class="hljs-title function_">hasInstantiationAwareBeanPostProcessors</span>()) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">SmartInstantiationAwareBeanPostProcessor</span> bp : <span class="hljs-title function_">getBeanPostProcessorCache</span>().<span class="hljs-property">smartInstantiationAware</span>) &#123;<br>            exposedObject = bp.<span class="hljs-title function_">getEarlyBeanReference</span>(exposedObject, beanName);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点就在中间的判断，如果 false，返回就是参数传进来的 bean，没任何变化。</p><p>如果是 true 说明有 InstantiationAwareBeanPostProcessors 。</p><p>且循环的是 smartInstantiationAware 类型，如有这个 BeanPostProcessor 说明 Bean 需要被 aop 代理。</p><p>我们都知道如果有代理的话，那么我们想要直接拿到的是代理对象。</p><p>也就是说如果 A 需要被代理，那么 B 依赖的 A 是已经被代理的 A，所以我们不能返回 A 给 B，而是返回代理的 A 给 B。</p><p>这个工厂的作用就是判断这个对象是否需要代理，如果否则直接返回，如果是则返回代理对象。</p><p>那这跟三级缓存有什么关系呢，我可以在要放到二级缓存的时候判断这个 Bean 是否需要代理，如果要直接放代理的对象不就完事儿了。</p><p>这其实跟 Bean 的生命周期有关系。</p><p>正常代理对象的生成是基于后置处理器，是在被代理的对象初始化后期调用生成的，所以如果你提早代理了其实是违背了 Bean 定义的生命周期。</p><p>所以 Spring 先在一个三级缓存放置一个工厂，如果产生循环依赖，那么就调用这个工厂提早得到代理对象。</p><p>如果没产生依赖，这个工厂根本不会被调用，所以 Bean 的生命周期就是对的。</p><p>至此，我想你应该明白为什么会有三级缓存了。</p><p>也明白，其实破坏循环依赖，其实只有二级缓存就够了，但是碍于生命周期的问题，提前暴露工厂延迟代理对象的生成。</p><p>对了，不用担心三级缓存因为没有循环依赖，数据堆积的问题，终单例 Bean 创建完毕都会加入一级缓存，此时会清理下面的二、三级缓存。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&scene=21#wechat_redirect"><img src="https://image.z.itpub.net/zitpub.net/JPG/2022-04-15/C5D3CA3C9918CE4B360C2A4E090ABC15.jpg" alt="img"></a></p><p>好了，看到这里想必你应该对 Spring 的循环依赖很清晰了，并且面试的时候肯定也难不倒你了。</p><p>我稍微总结下：</p><ul><li>有构造器注入，不一定会产生问题，具体得看是否都是构造器注和 BeanName 的字母序</li><li>如果单纯为了打破循环依赖，不需要三级缓存，两级就够了。</li><li>三级缓存是否为延迟代理的创建，尽量不打破 Bean 的生命周期</li></ul><hr><p>![image-20230603150748062](&#x2F;Users&#x2F;lindinghao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230603150748062.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
